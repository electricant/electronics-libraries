* Library of Standard 74 TTL Family Digital Models
*
*  Copyright OrCAD, Inc. 1998 All Rights Reserved.
*
*
* $Revision:   1.9  $
* $Author:   RPEREZ  $
* $Date:   16 Apr 1998 13:32:32  $
*
*
*$
*-------------------------------------------------------------------------
* 7400  Quadruple 2-input Positive-Nand Gates    
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn   06/23/89	Update interface and model names
*
.subckt 7400  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(2) DPWR DGND
+	A B   Y 
+	D_00 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_00 ugate (
+	tplhty=11ns	tplhmx=22ns
+	tphlty=7ns	tphlmx=15ns
+	)
*$
*---------------------------------------------------------------------
* 7401  Quadruple 2-input Positive-Nand Gates with Open-Collector Outputs 
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn 	06/23/89	Update interface and model names
*
.subckt 7401  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(2) DPWR DGND
+	A B   Y 
+	D_01 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_01 ugate (
+	tplhty=35ns	tplhmx=55ns
+	tphlty=8ns	tphlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7402  Quadruple 2-input Positive-Nor Gates       
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 7402  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nor(2) DPWR DGND
+	A B   Y 
+	D_02 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_02 ugate (
+	tplhty=12ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7403  Quadruple 2-input Positive-Nand Gates with Open-Collector Outputs       
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 7403  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(2) DPWR DGND
+	A B   Y 
+	D_03 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_03 ugate (
+	tplhty=35ns	tplhmx=45ns
+	tphlty=8ns	tphlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7404  Hex Inverters       
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 7404  A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 inv DPWR DGND
+	A   Y 
+	D_04 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_04 ugate (
+	tplhty=12ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7405  Hex Inverters with Open-Collector Outputs      
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 7405  A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 inv DPWR DGND
+	A   Y 
+	D_05 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_05 ugate (
+	tplhty=40ns	tplhmx=55ns
+	tphlty=8ns	tphlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7406  Hex Inverter Buffers/Drivers with Open-Collector High-Voltage Outputs 
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 7406  A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 inv DPWR DGND
+	A   Y 
+	D_06 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_06 ugate (
+	tplhty=10ns	tplhmx=15ns
+	tphlty=15ns	tphlmx=23ns
+	)
*$
*-------------------------------------------------------------------------
* 7407  Hex Buffers/Drivers with Open-Collector High-Voltage Outputs
* 
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 7407  A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 buf DPWR DGND
+	A   Y 
+	D_07 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_07 ugate (
+	tplhty=6ns	tplhmx=10ns
+	tphlty=20ns	tphlmx=30ns
+	)
*$
*-------------------------------------------------------------------------
* 7408  Quadruple 2-input Positive-And Gates      
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 7408  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 and(2) DPWR DGND
+	A B   Y 
+	D_08 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_08 ugate (
+	tplhty=17.5ns	tplhmx=27ns
+	tphlty=12ns	tphlmx=19ns
+	)
*$
*-------------------------------------------------------------------------
* 7409  Quadruple 2-input Positive-And Gates with Open-Collector Outputs      
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 7409  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 and(2) DPWR DGND
+	A B   Y 
+	D_09 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_09 ugate (
+	tplhty=21ns	tplhmx=32ns
+	tphlty=16ns	tphlmx=24ns
+	)
*$
*-------------------------------------------------------------------------
* 7410  Triple 3-input Positive-Nand Gates      
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 7410  A B C Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(3) DPWR DGND
+	A B C   Y 
+	D_10 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_10 ugate (
+	tplhty=11ns	tplhmx=22ns
+	tphlty=7ns	tphlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7411  Triple 3-input Positive-And Gates
*
* 1989 National Semiconductor
*
.subckt 7411  A B C Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 and(3) DPWR DGND
+	A B C   Y 
+	D_11 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_11 ugate (
+	tplhmx=27ns
+	tphlmx=19ns
+	)
*$
*--------------------------------------------------------------------------
* 7412  Triple 3-input Positive-Nand Gates with Open-Collector Outputs      
* 
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 7412  A B C Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(3) DPWR DGND
+	A B C   Y 
+	D_12 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_12 ugate (
+	tplhty=35ns	tplhmx=45ns
+	tphlty=8ns	tphlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7413  Dual 4-input Positive-Nand Schmitt Triggers      
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 7413  A B C D Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* Note: These devices are modeled as simple Nand gates.
*       Hysteresis is modeled in the AtoD interface
*
U1 nand(4) DPWR DGND
+	A B C D   Y 
+	D_13 IO_STD_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_13 ugate (
+	tplhty=18ns	tplhmx=27ns
+	tphlty=15ns	tphlmx=22ns
+	)
*$
*-------------------------------------------------------------------------
* 7414  Hex Schmitt-Trigger Inverters      
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 7414  A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* Note: These devices are modeled as simple inverters
*       Hysteresis is modeled in the AtoD interface
*
U1 inv DPWR DGND
+	A   Y 
+	D_14 IO_STD_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_14 ugate (
+	tplhty=15ns	tplhmx=22ns
+	tphlty=15ns	tphlmx=22ns
+	)
*$
*-------------------------------------------------------------------------
* 7416  Hex Inverter Buffers/Drivers with Open-Collector High-Voltage Outputs 
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names
*
.subckt 7416  A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 inv DPWR DGND
+	A   Y 
+	D_16 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_16 ugate (
+	tplhty=10ns	tplhmx=15ns
+	tphlty=15ns	tphlmx=23ns
+	)
*$
*-------------------------------------------------------------------------
* 7417  Hex Buffers/Drivers with Open-Collector High-Voltage Outputs   
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names
*
.subckt 7417  A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 buf DPWR DGND
+	A   Y 
+	D_17 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_17 ugate (
+	tplhty=6ns	tplhmx=10ns
+	tphlty=20ns	tphlmx=30ns
+	)
*$
*-------------------------------------------------------------------------
* 7420  Dual 4-input Positive-Nand Gates       
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names
*
.subckt 7420  A B C D Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(4) DPWR DGND
+	A B C D   Y 
+	D_20 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_20 ugate (
+	tplhty=12ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7422  Dual 4-input Positive-Nand Gates with Open-Collector Outputs      
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names
*
.subckt 7422  A B C D Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(4) DPWR DGND
+	A B C D   Y 
+	D_22 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_22 ugate (
+	tplhty=35ns	tplhmx=45ns
+	tphlty=8ns	tphlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7423  Dual 4-input Nor Gates with Strobe
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names
*
.subckt 7423  1A 1B 1C 1D 1G X XBAR 1Y 2A 2B 2C 2D 2G 2Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* --- NOTE ---
*
* The x and xbar inputs of this gate should only come from the following
* gates:
*	'60
* 
* PSpice, however, will not check that it is properly connected.
*
UIBUF bufa(2) DPWR DGND
+	1G 2G   1G_BUF 2G_BUF 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U1 inv DPWR DGND
+	XBAR   XBARC 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U11 aoi(2,5) DPWR DGND
+	1A	1G_BUF
+	1B	1G_BUF
+	1C	1G_BUF
+	1D	1G_BUF
+	X	XBARC
+	1Y
+	D_23 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U21 aoi(2,4) DPWR DGND
+	2A 2G_BUF 2B 2G_BUF 2C 2G_BUF 2D 2G_BUF   2Y 
+	D_23 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_23 ugate (
+	tplhty=13ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7425  Dual 4-input Nor Gates with Strobe      
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names
*
.subckt 7425  A B C D G Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 or(4) DPWR DGND
+	A B C D   X 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U2 nand(2) DPWR DGND
+	X G   Y 
+	D_25 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_25 ugate (
+	tplhty=13ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7426  High-Voltage Interface Positive-Nand Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names
*
.subckt 7426  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(2) DPWR DGND
+	A B   Y 
+	D_26 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_26 ugate (
+	tplhty=16ns	tplhmx=24ns
+	tphlty=11ns	tphlmx=17ns
+	)
*$
*-------------------------------------------------------------------------
* 7427  Triple 3-input Positive-Nor Gates           
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names
*
.subckt 7427  A B C Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nor(3) DPWR DGND
+	A B C   Y 
+	D_27 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_27 ugate (
+	tplhty=10ns	tplhmx=15ns
+	tphlty=7ns	tphlmx=11ns
+	)
*$
*-------------------------------------------------------------------------
* 7428  Quadruple 2-input Positive-Nor Buffers
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names
*
.subckt 7428  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nor(2) DPWR DGND
+	A B   Y 
+	D_28 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_28 ugate (
+	tplhty=6ns	tplhmx=9ns
+	tphlty=8ns	tphlmx=12ns
+	)
*$
*-------------------------------------------------------------------------
* 7430  8-input Positive-Nand Gates        
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names
*
.subckt 7430  A B C D E F G H Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(8) DPWR DGND
+	A B C D E F G H   Y 
+	D_30 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_30 ugate (
+	tplhty=13ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7432  Quadruple 2-input Positive-Or Gates           
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names
*
.subckt 7432  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 or(2) DPWR DGND
+	A B   Y 
+	D_32 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_32 ugate (
+	tplhty=10ns	tplhmx=15ns
+	tphlty=14ns	tphlmx=22ns
+	)
*$
*-------------------------------------------------------------------------
* 7433  Quadruple 2-input Positive-Nor Buffers w/ Open-Collector Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names
*
.subckt 7433  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nor(2) DPWR DGND
+	A B   Y 
+	D_33 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_33 ugate (
+	tplhty=10ns	tplhmx=15ns
+	tphlty=12ns	tphlmx=18ns
+	)
*$
*-------------------------------------------------------------------------
* 7437  Quadruple 2-input Positive-Nand Buffers
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names
*
.subckt 7437  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(2) DPWR DGND
+	A B   Y 
+	D_37 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_37 ugate (
+	tplhty=13ns	tphlty=8ns
+	tplhmx=22ns	tphlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7438  Quadruple 2-input Positive-Nand Buffers w/ Open-Collector Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names
*
.subckt 7438  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(2) DPWR DGND
+	A B   Y 
+	D_38 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_38 ugate (
+	tplhty=14ns	tplhmx=22ns
+	tphlty=11ns	tphlmx=18ns
+	)
*$
*-------------------------------------------------------------------------
* 7439  Quadruple 2-input Positive Nand Buffers with Open-Collector Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	08/10/89	Update interface and model names
*
.subckt 7439  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(2) DPWR DGND
+	A B   Y 
+	D_39 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_39 ugate (
+	tphlmx=18ns	tplhmx=22ns
+	)
*$
*-------------------------------------------------------------------------
* 7440  Dual 4-input Positive-Nand Buffers
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/26/89	Update interface and model names
*
.subckt 7440  A B C D Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(4) DPWR DGND
+	A B C D   Y 
+	D_40 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_40 ugate (
+	tplhty=13ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7442A  DECODER BCD-DECIMAL 4-10 LINE
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   7-30-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 7442A   A_I B_I C_I D_I
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U42ALOG LOGICEXP (4,14) DPWR DGND
+ A_I B_I C_I D_I
+ A   B   C   D
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   A    = { A_I }
+   B    = { B_I }
+   C    = { C_I }
+   D    = { D_I }
+   ABAR = { ~A }
+   BBAR = { ~B }
+   CBAR = { ~C }
+   DBAR = { ~D }
+   Y0   = { ~(DBAR & CBAR & BBAR & ABAR ) }
+   Y1   = { ~(DBAR & CBAR & BBAR & A    ) }
+   Y2   = { ~(DBAR & CBAR & B    & ABAR ) }
+   Y3   = { ~(DBAR & CBAR & B    & A    ) }
+   Y4   = { ~(DBAR & C    & BBAR & ABAR ) }
+   Y5   = { ~(DBAR & C    & BBAR & A    ) }
+   Y6   = { ~(DBAR & C    & B    & ABAR ) }
+   Y7   = { ~(DBAR & C    & B    & A    ) }
+   Y8   = { ~(D    & CBAR & BBAR & ABAR ) }
+   Y9   = { ~(D    & CBAR & BBAR & A    ) }
*
U42ADLY PINDLY (10,0,4) DPWR DGND
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9
+ A B C D
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ADDRA = { CHANGED(A,0) }
+   ADDRB = { CHANGED(B,0) }
+   ADDRC = { CHANGED(C,0) }
+   ADDRD = { CHANGED(D,0) }
+
+ PINDLY:
+   Y0_O = {
+     CASE (
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,14NS,25NS)
+       )
+     }
+   Y1_O = {
+     CASE (
+       ADDRA         , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y2_O = {
+     CASE (
+       ADDRB         , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y3_O = {
+     CASE (
+       ADDRA | ADDRB  , DELAY(-1,17NS,30NS),
+                TRN_HL, DELAY(-1,14NS,25NS),
+                TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y4_O = {
+     CASE (
+       ADDRC         , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y5_O = {
+     CASE (
+       ADDRA | ADDRC  , DELAY(-1,17NS,30NS),
+                TRN_HL, DELAY(-1,14NS,25NS),
+                TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y6_O = {
+     CASE (
+       ADDRB | ADDRC  , DELAY(-1,17NS,30NS),
+                TRN_HL, DELAY(-1,14NS,25NS),
+                TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y7_O = {
+     CASE (
+       ADDRA | ADDRB | ADDRC, DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y8_O = {
+     CASE (
+       ADDRD         , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y9_O = {
+     CASE (
+       ADDRA | ADDRD, DELAY(-1,17NS,30NS),
+                TRN_HL, DELAY(-1,14NS,25NS),
+                TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
*
.ENDS
*
*$
*------------------------------------------------------------------------
* 7443A  DECODER EXCESS-3-DECIMAL 4-10 LINE
*
* THE TTL DATA BOOK, VOLUME 2, STANDARD, S, LS, TTL; TI, 1985
* JLS   7-30-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 7443A   A_I B_I C_I D_I
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U43ALOG LOGICEXP (4,14) DPWR DGND
+ A_I B_I C_I D_I
+ A   B   C   D
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   A    = { A_I }
+   B    = { B_I }
+   C    = { C_I }
+   D    = { D_I }
+   ABAR = { ~A }
+   BBAR = { ~B }
+   CBAR = { ~C }
+   DBAR = { ~D }
+   Y0   = { ~(DBAR & CBAR & B    & A    ) }
+   Y1   = { ~(DBAR & C    & BBAR & ABAR ) }
+   Y2   = { ~(DBAR & C    & BBAR & A    ) }
+   Y3   = { ~(DBAR & C    & B    & ABAR ) }
+   Y4   = { ~(DBAR & C    & B    & A    ) }
+   Y5   = { ~(D    & CBAR & BBAR & ABAR ) }
+   Y6   = { ~(D    & CBAR & BBAR & A    ) }
+   Y7   = { ~(D    & CBAR & B    & ABAR ) }
+   Y8   = { ~(D    & CBAR & B    & A    ) }
+   Y9   = { ~(D    & C    & BBAR & ABAR ) }
*
U43ADLY PINDLY (10,0,4) DPWR DGND
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9
+ A B C D
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ADDRA = { CHANGED(A,0) }
+   ADDRB = { CHANGED(B,0) }
+   ADDRC = { CHANGED(C,0) }
+   ADDRD = { CHANGED(D,0) }
+
+ PINDLY:
+   Y0_O = {
+     CASE (
+       ADDRA | ADDRB , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y1_O = {
+     CASE (
+       ADDRC         , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y2_O = {
+     CASE (
+       ADDRA | ADDRC , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y3_O = {
+     CASE (
+       ADDRB | ADDRC , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y4_O = {
+     CASE (
+       ADDRA | ADDRB | ADDRC, DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y5_O = {
+     CASE (
+       ADDRD         , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y6_O = {
+     CASE (
+       ADDRA | ADDRD , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y7_O = {
+     CASE (
+       ADDRB | ADDRD , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y8_O = {
+     CASE (
+       ADDRA | ADDRB | ADDRD, DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y9_O = {
+     CASE (
+       ADDRC | ADDRD , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
*
.ENDS
*
*$
*------------------------------------------------------------------------
* 7444A  DECODER GRAY-DECIMAL 4-10 LINE
*
* THE TTL DATA BOOK, VOLUME 2, STANDARD, S, LS, TTL; 1985, TI
* JLS   7-30-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 7444A   A_I B_I C_I D_I
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U44ALOG LOGICEXP (4,14) DPWR DGND
+ A_I B_I C_I D_I
+ A   B   C   D
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   A    = { A_I }
+   B    = { B_I }
+   C    = { C_I }
+   D    = { D_I }
+   ABAR = { ~A }
+   BBAR = { ~B }
+   CBAR = { ~C }
+   DBAR = { ~D }
+   Y0   = { ~(DBAR & CBAR & B    & ABAR ) }
+   Y1   = { ~(DBAR & C    & B    & ABAR ) }
+   Y2   = { ~(DBAR & C    & B    & A    ) }
+   Y3   = { ~(DBAR & C    & BBAR & A    ) }
+   Y4   = { ~(DBAR & C    & BBAR & ABAR ) }
+   Y5   = { ~(D    & C    & BBAR & ABAR ) }
+   Y6   = { ~(D    & C    & BBAR & A    ) }
+   Y7   = { ~(D    & C    & B    & A    ) }
+   Y8   = { ~(D    & C    & B    & ABAR ) }
+   Y9   = { ~(D    & CBAR & B    & ABAR ) }
*
U44ADLY PINDLY (10,0,4) DPWR DGND
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9
+ A B C D
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ADDRA = { CHANGED(A,0) }
+   ADDRB = { CHANGED(B,0) }
+   ADDRC = { CHANGED(C,0) }
+   ADDRD = { CHANGED(D,0) }
+
+ PINDLY:
+   Y0_O = {
+     CASE (
+       ADDRB         , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y1_O = {
+     CASE (
+       ADDRB | ADDRC , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y2_O = {
+     CASE (
+       ADDRA | ADDRB | ADDRC, DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y3_O = {
+     CASE (
+       ADDRA | ADDRC , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y4_O = {
+     CASE (
+       ADDRC         , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y5_O = {
+     CASE (
+       ADDRC | ADDRD , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y6_O = {
+     CASE (
+       ADDRA | ADDRC | ADDRD, DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y7_O = {
+     CASE (
+       ADDRA | ADDRB | ADDRC | ADDRD, DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y8_O = {
+     CASE (
+       ADDRB | ADDRC | ADDRD, DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
+   Y9_O = {
+     CASE (
+       ADDRB | ADDRD , DELAY(-1,17NS,30NS),
+               TRN_HL, DELAY(-1,14NS,25NS),
+               TRN_LH, DELAY(-1,10NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 7445  DECODER/DRIVER BCD-DECIMAL WITH OPEN COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-25-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 7445   A_I B_I C_I D_I
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
X1   A_I B_I C_I D_I
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O   DPWR DGND   74145
+ PARAMS: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 7446A  DECODER/DRIVER BCD-7 SEGMENT WITH OPEN COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*    
.SUBCKT 7446A   INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
X1   INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O   DPWR DGND   7447A
+ PARAMS: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 7447A  DECODER/DRIVER BCD-7 SEGMENT WITH OPEN COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*    
.SUBCKT 7447A   INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 OR(6) DPWR DGND
+ LT RBIBAR INA INB INC IND
+ BIBAR/RBOBAR_B
+ D0_GATE IO_STD 
+ IO_LEVEL={IO_LEVEL}
*
U47ALOG LOGICEXP (7,13) DPWR DGND
+ INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ INA   INB   INC   IND   RBIBAR   LT
+ OUTA OUTB OUTC OUTD OUTE OUTF OUTG
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   INA    = { INA_I }
+   INB    = { INB_I }
+   INC    = { INC_I }
+   IND    = { IND_I }
+   RBIBAR = { RBIBAR_I }
+   LTBAR  = { LTBAR_I }
+   BIBAR/RBOBAR  = { BIBAR/RBOBAR_B }
+
+   LT     = { ~LTBAR }
+   ALT    = { ~(INA & LTBAR) }
+   BLT    = { ~(INB & LTBAR) }
+   CLT    = { ~(INC & LTBAR) }
+   DLT    = { ~IND }
+   ABI    = { ~(ALT & BIBAR/RBOBAR) }
+   BBI    = { ~(BLT & BIBAR/RBOBAR) }
+   CBI    = { ~(CLT & BIBAR/RBOBAR) }
+   DBI    = { ~(DLT & BIBAR/RBOBAR) }
+
+   OUTA   = { (BBI & DBI) | (ALT & CBI) | (ABI & BLT & CLT & DLT) }
+   OUTB   = { (BBI & DBI) | (ABI & BLT & CBI) | (ALT & BBI & CBI) }
+   OUTC   = { (CBI & DBI) | (ALT & BBI & CLT) }
+   OUTD   = { (ABI & BLT & CLT) | (ALT & BLT & CBI) | (ABI & BBI & CBI) }
+   OUTE   = {  ABI | (BLT & CBI) }
+   OUTF   = { (ABI & BBI) | (BBI & CLT) | (ABI & CLT & DLT) }
+   OUTG   = { (ABI & BBI & CBI) | (BLT & CLT & DLT & LTBAR) }
*
U47ADLY_OC PINDLY (7,0,0) DPWR DGND
+ OUTA OUTB OUTC OUTD OUTE OUTF OUTG
+
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ IO_STD_OC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O =
+     { DELAY(-1,-1,100NS) }
*
.ENDS
*
*$
*------------------------------------------------------------------------
* 7448  DECODER/DRIVER BCD-7 SEGMENT WITH INTERNAL PULLUPS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*    
.SUBCKT 7448   INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 OR(6) DPWR DGND
+ LT RBIBAR INA INB INC IND
+ BIBAR/RBOBAR_B
+ D0_GATE IO_STD 
+ IO_LEVEL={IO_LEVEL}
*
U48LOG LOGICEXP (7,13) DPWR DGND
+ INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ INA   INB   INC   IND   RBIBAR   LT
+ OUTA OUTB OUTC OUTD OUTE OUTF OUTG
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   INA    = { INA_I }
+   INB    = { INB_I }
+   INC    = { INC_I }
+   IND    = { IND_I }
+   RBIBAR = { RBIBAR_I }
+   LTBAR  = { LTBAR_I }
+   BIBAR/RBOBAR  = { BIBAR/RBOBAR_B }
+
+   LT     = { ~LTBAR }
+   ALT    = { ~(INA & LTBAR) }
+   BLT    = { ~(INB & LTBAR) }
+   CLT    = { ~(INC & LTBAR) }
+   DLT    = { ~IND }
+   ABI    = { ~(ALT & BIBAR/RBOBAR) }
+   BBI    = { ~(BLT & BIBAR/RBOBAR) }
+   CBI    = { ~(CLT & BIBAR/RBOBAR) }
+   DBI    = { ~(DLT & BIBAR/RBOBAR) }
+
+   OUTA   = { ~((BBI & DBI) | (ALT & CBI) | (ABI & BLT & CLT & DLT)) }
+   OUTB   = { ~((BBI & DBI) | (ABI & BLT & CBI) | (ALT & BBI & CBI)) }
+   OUTC   = { ~((CBI & DBI) | (ALT & BBI & CLT)) }
+   OUTD   = { ~((ABI & BLT & CLT) | (ALT & BLT & CBI) | (ABI & BBI & CBI)) }
+   OUTE   = { ~( ABI | (BLT & CBI)) }
+   OUTF   = { ~((ABI & BBI) | (BBI & CLT) | (ABI & CLT & DLT)) }
+   OUTG   = { ~((ABI & BBI & CBI) | (BLT & CLT & DLT & LTBAR)) }
*
U48DLY PINDLY (7,0,0) DPWR DGND
+ OUTA OUTB OUTC OUTD OUTE OUTF OUTG
+
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O =
+     { DELAY(-1,-1,100NS) }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 7449  DECODER/DRIVER BCD-7 SEGMENT WITH OPEN COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 7449   INA_I INB_I INC_I IND_I BIBAR_I
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U49LOG LOGICEXP (5,7) DPWR DGND
+ INA_I INB_I INC_I IND_I BIBAR_I
+ OUTA OUTB OUTC OUTD OUTE OUTF OUTG
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   INA   = { INA_I }
+   INB   = { INB_I }
+   INC   = { INC_I }
+   IND   = { IND_I }
+   BIBAR = { BIBAR_I }
+
+   ABAR  = { ~INA }
+   BBAR  = { ~INB }
+   CBAR  = { ~INC }
+   DBAR  = { ~IND }
+   ABI   = { ~(ABAR & BIBAR) }
+   BBI   = { ~(BBAR & BIBAR) }
+   CBI   = { ~(CBAR & BIBAR) }
+   DBI   = { ~(DBAR & BIBAR) }
+
+   OUTA  = { ~((BBI & DBI) | (ABAR & CBI) | (ABI & BBAR & CBAR & DBAR)) }
+   OUTB  = { ~((BBI & DBI) | (ABI & BBAR & CBI) | (ABAR & BBI & CBI)) }
+   OUTC  = { ~((CBI & DBI) | (ABAR & BBI & CBAR)) }
+   OUTD  = { ~((ABI & BBAR & CBAR) | (ABAR & BBAR & CBI) |
+               (ABI & BBI & CBI)) }
+   OUTE  = { ~( ABI | (BBAR & CBI)) }
+   OUTF  = { ~((ABI & BBI) | (BBI & CBAR) | (ABI & CBAR & DBAR)) }
+   OUTG  = { ~((ABI & BBI & CBI) | (BBAR & CBAR & DBAR)) }
*
U49DLY_OC PINDLY (7,0,0) DPWR DGND
+ OUTA OUTB OUTC OUTD OUTE OUTF OUTG
+
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ IO_STD_OC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O =
+     { DELAY(-1,-1,100NS) }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 7450 	Dual 2-wide 2-input And-Or-Invert Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/27/89	Update interface and model names
*
.subckt 7450  1A 1B 1C 1D X XBAR 1Y 2A 2B 2C 2D 2Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* --- NOTE ---
* The x and xbar inputs of gate 1 of this chip can only come from the 
* following gates:
*	'50
*	'60
* PSpice, however, will not check that these are properly connected.
*
U1V inv DPWR DGND
+	XBAR   XBARC 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U1 aoi(2,3) DPWR DGND
+	1A 1B 1C 1D X XBARC   1Y 
+	D_50_1 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 aoi(2,2) DPWR DGND
+	2A 2B 2C 2D   2Y 
+	D_50_1 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_50_1 ugate (
+	tplhty=13ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7451  And-Or-Invert Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/27/89	Update interface and model names
*
.subckt 7451  A B C D Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 aoi(2,2) DPWR DGND
+	A B C D   Y 
+	D_51 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_51 ugate (
+	tplhty=13ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7453  Expandable 4-wide And-Or-Invert Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/27/89	Update interface and model names
*
.subckt 7453  A B C D E F G H X XBAR Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* --- NOTE ---
* The x and xbar inputs of this gate should only come from the following
* chips:
*	'60
*	'62
* PSpice, however, will not check that these are properly connected.
*
U1 inv DPWR DGND
+	XBAR   XBARC 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U2 aoi(2,5) DPWR DGND
+	A	B
+	C	D
+	E	F
+	G	H
+	X	XBARC
+	Y
+	D_53 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_53 ugate (
+	tplhty=13ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7454  4-wide And-Or-Invert Gates
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/27/89	Update interface and model names
*
.subckt 7454  A B C D E F G H Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 aoi(2,4) DPWR DGND
+	A B C D E F G H   Y 
+	D_54 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_54 ugate (
+	tplhty=13ns	tplhmx=22ns
+	tphlty=8ns	tphlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7460  Dual 4-input Expanders
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/28/89	Update interface and model names
*
.subckt 7460  A B C D X XBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* --- NOTE ---
* this gate should only be connected to the following expandable gates:
*	'23
*	'50
*	'53
* connected by both x and xbar connections
* PSpice, however, will not check that these are correctly connected.
* ALSO  this gate has no propagation delay.
* There is a total propagation delay in the last level NOR gate in the
* above chips, so when properly connected, the expanded combination will
* work correctly.
*
U1 and(4) DPWR DGND
+	A B C D   X 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U2 inv DPWR DGND
+	X   XBAR 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
.ends
*
*$
*-------------------------------------------------------------------------
* 7470  And-Gated J-K Positive-Edge-Triggered Flip-Flops with Preset & Clear
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/28/89	Update interface and model names
*
.subckt 7470  CLK PREBAR CLRBAR J1 J2 JBAR K1 K2 KBAR Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1V inva(3) DPWR DGND
+	CLK JBAR KBAR   CLKBAR J3 K3 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U2A anda(3,2) DPWR DGND
+	J3 J1 J2 K3 K1 K2   J K 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U3 jkff(1) DPWR DGND
+	PREBAR CLRBAR CLKBAR   J K   Q QBAR 
+	D_70 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_70 ueff (
+	tppcqlhmx=50ns	tppcqhlmx=50ns
+	tpclkqlhty=27ns	tpclkqlhmx=50ns
+	tpclkqhlty=18ns	tpclkqhlmx=50ns
+	twclkhmx=20ns	twclkhty=20ns
+	twclklmx=30ns	twclklty=30ns
+	twpclmx=25ns	twpclty=25ns
+	tsudclkmx=20ns	tsudclkmn=20ns
+	thdclkmx=5ns	thdclkmn=5ns
+	)
*$
*-------------------------------------------------------------------------
* 7472  And Gated J-K Master-Slave Flip-Flops with Preset and Clear
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	08/11/89	Update interface and model names
*
.subckt 7472  PREBAR CLRBAR CLK J1 J2 J3 K1 K2 K3 Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 bufa(2) DPWR DGND
+	PREBAR CLRBAR   PREB CLRB 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U2 buf DPWR DGND
+	CLK   CLK_BUF 
+	D_72_1 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U3 anda(3,2) DPWR DGND
+	J1 J2 J3 K1 K2 K3   J K 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U4 inva(3) DPWR DGND
+	J K CLK_BUF   JB KB CLKB 
+	D0_GATE IO_STD 
UF1 srff(1) DPWR DGND
+	PREB CLRB CLK_BUF   W1 W2   Y YB 
+	D_72_2 IO_STD MNTYMXDLY={MNTYMXDLY} 
UF2 srff(1) DPWR DGND
+	PREB CLRB CLKB   Y YB   Q1 QB1 
+	D_72_3 IO_STD MNTYMXDLY={MNTYMXDLY} 
U5 ao(3,2) DPWR DGND
+	J K QBD J KB $D_HI   W1 
+	D_72_4 IO_STD 
U6 ao(3,2) DPWR DGND
+	J K QD JB K $D_HI   W2 
+	D_72_4 IO_STD 
U7 bufa(4) DPWR DGND
+	Q1 Q1 QB1 QB1   Q QD QBAR QBD 
+	D_72_4 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_72_1 ugate (
+	tplhty=6ns	tplhmx=6ns
+	)
.model D_72_2 ugff (
+	twghmn=20ns	twpclmn=25ns
+	)
.model D_72_3 ugff (
+	twghmn=47ns	twpclmn=25ns
+	tppcqhlty=19ns	tppcqhlmx=34ns
+	tppcqlhty=10ns	tppcqlhmx=19ns
+	tpgqlhty=10ns	tpgqlhmx=19ns
+	tpgqhlty=19ns	tpgqhlmx=34ns
+	)
.model D_72_4 ugate (
+	tphlty=6ns	tphlmx=6ns
+	tplhty=6ns	tplhmx=6ns
+	)
*$
*-------------------------------------------------------------------------
* 7473  Dual J-K Flip-Flops with Clear      
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/28/89	Update interface and model names
*
.subckt 7473  CLK CLRBAR J K Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(3) DPWR DGND
+	CLRBAR J K   CLRBAR_BUF J_BUF K_BUF 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U2BUF buf DPWR DGND
+	CLK   CLK_BUF 
+	D_73_4 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U1 inva(3) DPWR DGND
+	CLK_BUF J_BUF K_BUF   CLKBAR JB KB 
+	D0_GATE IO_STD 
U2A ao(3,2) DPWR DGND
+	J_BUF QBAR_BUFD K_BUF J_BUF KB $D_HI   W1 
+	D_73_3 IO_STD MNTYMXDLY={MNTYMXDLY} 
U2B ao(3,2) DPWR DGND
+	J_BUF K_BUF Q_BUFD $D_HI JB K_BUF   W2 
+	D_73_3 IO_STD MNTYMXDLY={MNTYMXDLY} 
U3 srff(1) DPWR DGND
+	$D_HI CLRBAR_BUF CLK_BUF   W1 W2   Y YB 
+	D_73_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U4 srff(1) DPWR DGND
+	$D_HI CLRBAR_BUF CLKBAR   Y YB   QBUF QBAR_BUF 
+	D_73_2 IO_STD MNTYMXDLY={MNTYMXDLY} 
UOBUF bufa(2) DPWR DGND
+	QBUF QBAR_BUF   Q QBAR 
+	D_73_3 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UBUF bufa(2) DPWR DGND
+	QBUF QBAR_BUF   Q_BUFD QBAR_BUFD 
+	D_73_3 IO_STD MNTYMXDLY={MNTYMXDLY} 
.ends
*
.model D_73_1 ugff (
+	twghmx=14ns	twghty=14ns
+	twpclmx=25ns	twpclty=25ns
+	)
.model D_73_2 ugff (
+	tppcqlhty=10ns	tppcqlhmx=19ns
+	tppcqhlty=19ns	tppcqhlmx=34ns
+	tpgqlhty=10ns	tpgqlhmx=19ns
+	tpgqhlty=19ns	tpgqhlmx=34ns
+	twghmx=47ns	twghty=47ns
+	twpclmx=25ns	twpclty=25ns
+	)
.model D_73_3 ugate (
+	tplhty=6ns	tplhmx=6ns
+	tphlty=6ns	tphlmx=6ns
+	)
.model D_73_4 ugate (
+	tplhmn=6ns	tplhmx=6ns
+	)
*$
*-------------------------------------------------------------------------
* 7474  Dual D-Type Positive-Edge-Triggered Flip-Flops with Preset and Clear
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/28/89	Update interface and model names
*
.subckt 7474  1CLRBAR 1D 1CLK 1PREBAR 1Q 1QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UFF1 dff(1) DPWR DGND
+	1PREBAR 1CLRBAR 1CLK   1D   1Q 1QBAR 
+	D_74 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_74 ueff (
+	twpclmn=30ns	twclklmn=37ns
+	twclkhmn=30ns	tsudclkmn=20ns
+	thdclkmn=5ns	tppcqlhmx=25ns
+	tppcqhlmx=40ns	tpclkqlhty=14ns
+	tpclkqlhmx=25ns	tpclkqhlty=20ns
+	tpclkqhlmx=40ns
+	)
*$
*-------------------------------------------------------------------------
* 7475  4-bit bistable latches (dual 2-bit common clock)
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/28/89	Update interface and model names
*
.subckt 7475  1D 2D C 1Q 1QBAR 2Q 2QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(3) DPWR DGND
+	1D 2D C   1D_BUF 2D_BUF C_BUF 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U12 dltch(2) DPWR DGND
+	$D_HI $D_HI C_BUF   1D_BUF 2D_BUF   1Q 2Q $D_NC $D_NC 
+	D_75_1 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U12B dltch(2) DPWR DGND
+	$D_HI $D_HI C_BUF   1D_BUF 2D_BUF   $D_NC $D_NC 1QBAR 2QBAR 
+	D_75_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_75_1 ugff (
+	twghmx=20ns	tsudgmx=20ns
+	thdgmx=5ns	tpgqlhty=16ns
+	tpgqlhmx=30ns	tpgqhlty=7ns
+	tpgqhlmx=15ns	tpdqlhty=16ns
+	tpdqlhmx=30ns	tpdqhlty=14ns
+	tpdqhlmx=25ns
+	)
.model D_75_2 ugff (
+	twghmx=20ns	tsudgmx=20ns
+	thdgmx=5ns	tpgqlhty=16ns
+	tpgqlhmx=30ns	tpgqhlty=7ns
+	tpgqhlmx=15ns	tpdqlhty=24ns
+	tpdqlhmx=40ns	tpdqhlty=7ns
+	tpdqhlmx=15ns
+	)
*$
*-------------------------------------------------------------------------
* 7476  Dual J-K Flip-Flops with Preset and Clear    
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/28/89	Update interface and model names
*
.subckt 7476  CLK PREBAR CLRBAR J K Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* --NOTE--
* The standard Flip-Flops are pulse triggered
*
*
UIBUF bufa(4) DPWR DGND
+	PREBAR CLRBAR J K   PREBAR_BUF CLRBAR_BUF J_BUF K_BUF 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U1 srff(1) DPWR DGND
+	PREBAR_BUF CLRBAR_BUF CLK_BUF   W1 W2   Y YB 
+	D_76_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U2 srff(1) DPWR DGND
+	PREBAR_BUF CLRBAR_BUF CLKBAR   Y YB   Q2 QB2 
+	D_76_2 IO_STD MNTYMXDLY={MNTYMXDLY} 
U2BUF buf DPWR DGND
+	CLK   CLK_BUF 
+	D_76_4 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U3 inva(3) DPWR DGND
+	CLK_BUF J_BUF K_BUF   CLKBAR JB KB 
+	D0_GATE IO_STD 
U4 ao(3,2) DPWR DGND
+	J_BUF K_BUF QB2D J_BUF KB $D_HI   W1 
+	D_76_3 IO_STD MNTYMXDLY={MNTYMXDLY} 
U5 ao(3,2) DPWR DGND
+	J_BUF K_BUF Q2D JB K_BUF $D_HI   W2 
+	D_76_3 IO_STD MNTYMXDLY={MNTYMXDLY} 
UBUF bufa(2) DPWR DGND
+	Q2 QB2   Q2D QB2D 
+	D_76_3 IO_STD MNTYMXDLY={MNTYMXDLY} 
UOBUF bufa(2) DPWR DGND
+	Q2 QB2   Q QBAR 
+	D_76_3 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_76_1 ugff (
+	twghmx=14ns	twghty=14ns
+	twpclmx=25ns	twpclty=25ns
+	)
.model D_76_2 ugff (
+	tppcqlhty=10ns	tppcqlhmx=19ns
+	tppcqhlty=19ns	tppcqhlmx=34ns
+	tpgqlhty=10ns	tpgqlhmx=19ns
+	tpgqhlty=19ns	tpgqhlmx=34ns
+	twghmx=47ns	twghty=47ns
+	twpclmx=25ns	twpclty=25ns
+	)
.model D_76_3 ugate (
+	tplhty=6ns	tplhmx=6ns
+	tphlty=6ns	tphlmx=6ns
+	)
.model D_76_4 ugate (
+	tplhmn=6ns	tplhmx=6ns
+	)
*$
*-------------------------------------------------------------------------
* 7477  4-bit bistable latches 
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/28/89	Update interface and model names
*
.subckt 7477  1D 2D C 1Q 2Q
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* There are actually 2 2-bit latches(per 1 control) in the real IC.  The model
* here for the IC contains only 1 2-bit latches.  If 4-bit latches is needed,
* please use the SUBCKT twice.
*
UIBUF buf DPWR DGND
+	C   C_BUF 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U1 dltch(2) DPWR DGND
+	$D_HI $D_HI C_BUF   1D 2D   1Q 2Q $D_NC $D_NC 
+	D_77 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_77 ugff (
+	twghmx=20ns	tsudgmx=20ns
+	thdgmx=5ns	tpgqlhty=16ns
+	tpgqlhmx=30ns	tpgqhlty=7ns
+	tpgqhlmx=15ns	tpdqlhty=16ns
+	tpdqlhmx=30ns	tpdqhlty=14ns
+	tpdqhlmx=25ns
+	)
*$
*-------------------------------------------------------------------------
*
*  7480 GATED FULL ADDERS
*
*  The TTL Data Book, Vol 2, 1985, TI
*  MCG 07/09/93 
*
*  NOTE - This gate uses wire-and logic with the input nodes being the
*         product of A1 and A2 with A* (similarly with the B input nodes).
*         This model does not simulate conflicts.  In order for this model
*         to be accurate, when A* is used as an input, A1 or A2 must be low,
*         and when A1 and A2 are used as inputs, A* must be open or used to
*         perform wire_and logic.  The same rules apply for the B inputs.
*
.SUBCKT 7480 CN_I   A1_I A2_I ASTAR_I AC_I   B1_I B2_I BSTAR_I BC_I  
+ SIGMA_O SIGMABAR_O CNPLUS1BAR_O
+ optional: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U7480 LOGICEXP(9,12) DPWR DGND
+ A1_I A2_I ASTAR_I AC_I B1_I B2_I BSTAR_I BC_I CN_I 
+ A1   A2   ASTAR   AC   B1   B2   BSTAR   BC   CN 
+ SIGMA SIGMABAR CNPLUS1BAR
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+
*  OUTPUT ASSIGNMENTS
+
+   CN      = { CN_I }
+   A1      = { A1_I } 
+   A2      = { A2_I } 
+   ASTAR   = { ASTAR_I } 
+   AC      = { AC_I } 
+   B1      = { B1_I } 
+   B2      = { B2_I } 
+   BSTAR   = { BSTAR_I } 
+   BC      = { BC_I } 
+
* THREE TEMPORARY ASSIGNMENTS
+
+   A       = { ~AC | ~ASTAR | (A1 & A2) }
+   B       = { ~BC | ~BSTAR | (B1 & B2) }
+   SIGMABUF= { A ^ (B ^ CN)}
+
* THE REST OF THE OUTPUTS
+
+   CNPLUS1BAR = { (~B & ~CN) | (~A & ~B) | (~A & ~CN) }
+   SIGMA   = { SIGMABUF }
+   SIGMABAR= { ~SIGMABUF }
*
U80DLY PINDLY (3,0,9) DPWR DGND
+ CNPLUS1BAR SIGMA SIGMABAR
+ CN AC A1 A2 ASTAR BC B1 B2 BSTAR
+ CNPLUS1BAR_O SIGMA_O SIGMABAR_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CNCHG     = { CHANGED(CN,0) }
+
+   A_B_1_2CHG    = { CHANGED(A1,0)    | CHANGED(A2,0) | CHANGED(B1,0)    | CHANGED(B2,0) }
+   A_B_C_STARCHG = { CHANGED(ASTAR,0) | CHANGED(AC,0) | CHANGED(BSTAR,0) | CHANGED(BC,0) }
+
+ PINDLY:
+   CNPLUS1BAR_O = {
+     CASE(
+       CNCHG & TRN_LH, DELAY(-1,13NS,17NS),
+       CNCHG & TRN_HL, DELAY(-1,8NS,12NS),
+       A_B_1_2CHG & TRN_LH, DELAY(-1,66NS,90NS),
+       A_B_1_2CHG & TRN_HL, DELAY(-1,55NS,80NS),
+       A_B_C_STARCHG & TRN_LH, DELAY(-1,18NS,25NS),
+       A_B_C_STARCHG & TRN_HL, DELAY(-1,38NS,55NS),
+       DELAY(-1,0NS,0NS)
+   	)
+     }
+   SIGMABAR_O = {
+     CASE(
+       CNCHG & TRN_LH, DELAY(-1,13NS,17NS),
+       CNCHG & TRN_HL, DELAY(-1,8NS,12NS),
+       A_B_1_2CHG & TRN_LH, DELAY(-1,86NS,120NS),
+       A_B_1_2CHG & TRN_HL, DELAY(-1,73NS,100NS),
+       A_B_C_STARCHG & TRN_LH, DELAY(-1,38NS,55NS),
+       A_B_C_STARCHG & TRN_HL, DELAY(-1,56NS,75NS),
+       DELAY(-1,0NS,0NS)
+       )
+     }
+   SIGMA_O = {
+     CASE(
+       CNCHG & TRN_LH, DELAY(-1,28NS,33NS),
+       CNCHG & TRN_HL, DELAY(-1,13NS,17NS),
+       A_B_1_2CHG & TRN_LH, DELAY(-1,101NS,135NS),
+       A_B_1_2CHG & TRN_HL, DELAY(-1,79NS,105NS),
+       A_B_C_STARCHG & TRN_LH, DELAY(-1,52NS,70NS),
+       A_B_C_STARCHG & TRN_HL, DELAY(-1,62NS,80NS),
+       DELAY(-1,0NS,0NS)
+       )
+     }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 7482 2-BIT BINARY FULL ADDERS
*
* THE TTL DATA BOOK, VOL 2, STANDARD, S, LS, TTL, 1985, TI
* NH 8/25/92         REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*   SINCE THE PROP DELAY FROM A1/B1 TO SUM1 IS NOT GIVEN, THE PROP  DELAY
*   FROM B2 TO SUM2 WILL BE USED AS THE PROP DELAY FROM Ai/Bi TO SUMi & C2
*
.SUBCKT 7482 C0_I A1_I B1_I A2_I B2_I SUM1_O SUM2_O C2_O
+ OPTIONAL: DPWR = $G_DPWR DGND = $G_DGND
+ PARAMS:   MNTYMXDLY=0  IO_LEVEL=0
*
U82LOG LOGICEXP(5,8) DPWR DGND
+ C0_I A1_I B1_I A2_I B2_I
+ C0   A1   B1   A2   B2   SUM1 SUM2 C2
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   C0 = { C0_I }
+   A1 = { A1_I }
+   B1 = { B1_I }
+   A2 = { A2_I }
+   B2 = { B2_I }
+   A2BAR = { ~A2 }
+   B2BAR = { ~B2 }
+
+   C0A1B1 = { ~( (C0 & A1) | (C0 & B1) | (A1 & B1) ) }
+   SUM1 = { (C0 & C0A1B1) | (A1 & C0A1B1) | (B1 & C0A1B1) | (C0 & A1 & B1) }
+   C2 = { ~( ( C0A1B1 & A2BAR) | (C0A1B1 & B2BAR) | (A2BAR & B2BAR) ) }
+   SUM2 = { ~( (C0A1B1 & C2) | (C2 & A2BAR) | (C2 & B2BAR) |
+               (A2BAR & B2BAR & C0A1B1) ) }
*
U82DLY PINDLY (3,0,5) DPWR DGND
+ SUM1 SUM2 C2
+ C0 A1 B1 A2 B2
+ SUM1_O SUM2_O C2_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+  ANY_CH_AB = { CHANGED(A2,0) | CHANGED(B2,0) | CHANGED(A1,0) | CHANGED(B1,0) }
+
+ PINDLY:
+   SUM1_O = {
+     CASE(
+       CHANGED(C0,0) & TRN_HL, DELAY(-1,-1,40NS),
+       ANY_CH_AB & TRN_LH, DELAY(-1,-1,40NS),
+       ANY_CH_AB & TRN_HL, DELAY(-1,-1,35NS),
+       CHANGED(C0,0) & TRN_LH, DELAY(-1,-1,34NS),
+       DELAY(-1,-1,41NS)                       ;DEFAULT
+       )
+     }
+   SUM2_O = {
+     CASE(
+       ANY_CH_AB & TRN_LH, DELAY(-1,-1,40NS),
+       CHANGED(C0,0) & TRN_HL, DELAY(-1,-1,42NS),
+       CHANGED(C0,0) & TRN_LH, DELAY(-1,-1,38NS),
+       ANY_CH_AB & TRN_HL, DELAY(-1,-1,35NS),
+       DELAY(-1,-1,43NS)                       ;DEFAULT
+       )
+     }
+   C2_O = {
+     CASE(
+       ANY_CH_AB & TRN_LH, DELAY(-1,-1,40NS),
+       ANY_CH_AB & TRN_HL, DELAY(-1,-1,35NS),
+       CHANGED(C0,0) & TRN_HL, DELAY(-1,17NS,27NS),
+       CHANGED(C0,0) & TRN_LH, DELAY(-1,12NS,19NS),
+       DELAY(-1,18NS,41NS)                     ;DEFAULT
+       )
+     }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 7483A 4-BIT BINARY FULL ADDERS WITH FAST CARRY
*
* TTL LOGIC STANDARD TTL, SCHOTTKY, LOW-POWER SCHOTTKY DATA BOOK, 1988, TI
* NH 8/25/92         REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 7483A C0_I A1_I A2_I A3_I A4_I B1_I B2_I B3_I B4_I C4_O
+             SUM1_O SUM2_O SUM3_O SUM4_O
+ OPTIONAL: DPWR = $G_DPWR DGND = $G_DGND
+ PARAMS:   MNTYMXDLY = 0  IO_LEVEL = 0
*
U83ALOG LOGICEXP(9,14) DPWR DGND
+ C0_I A1_I A2_I A3_I A4_I B1_I B2_I B3_I B4_I
+ C0 A1 A2 A3 A4 B1 B2 B3 B4 C4 SUM1 SUM2 SUM3 SUM4
+ D0_GATE IO_STD IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
+   C0 = { C0_I }
+   A1 = { A1_I }
+   A2 = { A2_I }
+   A3 = { A3_I }
+   A4 = { A4_I }
+   B1 = { B1_I }
+   B2 = { B2_I }
+   B3 = { B3_I }
+   B4 = { B4_I }
+
+   NAND4 = { ~(A4 & B4) }
+   NAND3 = { ~(A3 & B3) }
+   NAND2 = { ~(A2 & B2) }
+   NAND1 = { ~(A1 & B1) }
+   NOR4 = { ~(A4 | B4) }
+   NOR3 = { ~(A3 | B3) }
+   NOR2 = { ~(A2 | B2) }
+   NOR1 = { ~(A1 | B1) }
+   C0BAR = { ~C0 }
+
+   SUM1 = { (NAND1 & ~NOR1) ^ C0 }
+   SUM2 = { (NAND2 & ~NOR2) ^ (~(NOR1 | (NAND1 & C0BAR))) }
+   SUM3 = { (NAND3 & ~NOR3) ^ (~(NOR2 | (NOR1 & NAND2) |
+            (NAND2 & NAND1 & C0BAR))) }
+   SUM4 = { (NAND4 & ~NOR4) ^ (~(NOR3 | (NOR2 & NAND3) |
+            (NOR1 & NAND3 & NAND2) | (NAND3 & NAND2 & NAND1 & C0BAR))) }
+   C4 = { ~( NOR4 | (NOR3 & NAND4) | (NOR2 & NAND4 & NAND3) |
+             (NOR1 & NAND4 & NAND3 & NAND2) |
+             (NAND4 & NAND3 & NAND2 & NAND1 & C0BAR) ) }
*
U83ADLY PINDLY (5,0,9) DPWR DGND
+ SUM1 SUM2 SUM3 SUM4 C4
+ C0 A1 A2 A3 A4 B1 B2 B3 B4
+ SUM1_O SUM2_O SUM3_O SUM4_O C4_O
+ IO_STD MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+
+ BOOLEAN:
+   ANY_CH_AB = { CHANGED(A1,0) | CHANGED(B1,0) | CHANGED(A2,0) |
+                 CHANGED(B2,0) | CHANGED(A3,0) | CHANGED(B3,0) |
+                 CHANGED(A4,0) | CHANGED(B4,0) }
+
+
+ PINDLY:
+   SUM1_O SUM2_O SUM3_O SUM4_O = {
+     CASE(
+       ANY_CH_AB, DELAY(-1,16NS,24NS),
+       CHANGED(C0,0) & TRN_LH, DELAY(-1,14NS,21NS),
+       CHANGED(C0,0) & TRN_HL, DELAY(-1,12NS,21NS),
+       DELAY(-1,17NS,25NS)                       ;DEFAULT
+       )
+     }
+   C4_O = {
+     CASE(
+       CHANGED(C0,0) & TRN_HL, DELAY(-1,11NS,16NS),
+       ANY_CH_AB & TRN_HL, DELAY(-1,11NS,16NS),
+       (ANY_CH_AB | CHANGED(C0,0)) & TRN_LH, DELAY(-1,9NS,14NS),
+       DELAY(-1,12NS,17NS)                     ;DEFAULT
+       )
+     }
*
.ENDS
*
*$
*--------------------------------------------------------------------------
* 7485 4-BIT MAGNITUDE COMPARATOR
*
* NOTE : THE SPECS FOR 1,2,AND 3 GATE LEVELS PROP DELAYS ARE GIVEN; HOWEVER,
*        ONLY PROP DELAY FOR 3 GATE LEVELS IS USED IN THIS LIBRARY.
*
* THE TTL LOGIC STANDARD TTL, SCHOTTKY, LOW-POWER SCHOTTKY DATABOOK, 1988, TI
* KN   8-20-92      REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 7485 A3_I A2_I A1_I A0_I B3_I B2_I B1_I B0_I
+ AGBIN_I AEBIN_I ALBIN_I AGBOUT_O AEBOUT_O ALBOUT_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U85LOG LOGICEXP(11,14) DPWR DGND
+ A3_I A2_I A1_I A0_I B3_I B2_I B1_I B0_I AGBIN_I AEBIN_I ALBIN_I
+ A3   A2   A1   A0   B3   B2   B1   B0   AGBIN   AEBIN   ALBIN
+ AGBOUT AEBOUT ALBOUT
+ D0_GATE
+ IO_STD IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
*   BUFFER:
+   A3     = { A3_I }
+   A2     = { A2_I }
+   A1     = { A1_I }
+   A0     = { A0_I }
+   B3     = { B3_I }
+   B2     = { B2_I }
+   B1     = { B1_I }
+   B0     = { B0_I }
+   AGBIN  = { AGBIN_I }
+   AEBIN  = { AEBIN_I }
+   ALBIN  = { ALBIN_I }
+
*   INTERMEDIATE TERMS:
+   C3     = { ~(A3 & B3) }
+   C2     = { ~(A2 & B2) }
+   C1     = { ~(A1 & B1) }
+   C0     = { ~(A0 & B0) }
+   A3C3    = { A3 & C3 }
+   A2C2    = { A2 & C2 }
+   A1C1    = { A1 & C1 }
+   A0C0    = { A0 & C0 }
+   B3C3    = { B3 & C3 }
+   B2C2    = { B2 & C2 }
+   B1C1    = { B1 & C1 }
+   B0C0    = { B0 & C0 }
+   D3      = { ~(A3C3 | B3C3) }
+   D2      = { ~(A2C2 | B2C2) }
+   D1      = { ~(A1C1 | B1C1) }
+   D0      = { ~(A0C0 | B0C0) }
+   D32     = { D3 & D2 }
+   D31     = { D32 & D1 }
+   D30     = { D31 & D0 }
+
*   OUTPUT ASSIGNMENTS:
+   AGBOUT  = { ~B3C3 & ~(B2C2 & D3) & ~(B1C1 & D32) & ~(B0C0 & D31) &
+               ~(ALBIN & D30) & ~(AEBIN & D30) }
+   AEBOUT  = { D30 & AEBIN }
+   ALBOUT  = { ~(AEBIN & D30) & ~(AGBIN & D30) & ~(A0C0 & D31) &
+               ~(A1C1 & D32)  & ~(A2C2 & D3)   & ~A3C3 }
*
U85DLY PINDLY (3,0,11) DPWR DGND
+ AGBOUT AEBOUT ALBOUT
+ A3 A2 A1 A0 B3 B2 B1 B0 AGBIN AEBIN ALBIN
+ AGBOUT_O AEBOUT_O ALBOUT_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+  DATA_CHANGE = { CHANGED(A3,0) | CHANGED(A2,0) | CHANGED(A1,0) | CHANGED(A0,0)
+              | CHANGED(B3,0) | CHANGED(B2,0) | CHANGED(B1,0) | CHANGED(B0,0) }
+  AEBIN_CHANGE = { CHANGED(AEBIN,0) }
+  ABIN_CHANGE  = { AEBIN_CHANGE | CHANGED(ALBIN,0) | CHANGED(AGBIN,0) }
+
+ PINDLY:
+   AGBOUT_O ALBOUT_O = { ;AGBOUT & ALBOUT HAS THE SAME DELAY SO CAN BE GROUPPED
+     CASE(
+       DATA_CHANGE & TRN_LH,  DELAY(-1,17NS,26NS),
+       DATA_CHANGE & TRN_HL,  DELAY(-1,20NS,30NS),
+       ABIN_CHANGE  & TRN_LH, DELAY(-1,7NS,11NS),
+       ABIN_CHANGE  & TRN_HL, DELAY(-1,11NS,17NS),
+                              DELAY(-1,21NS,31NS)  ;DEFAULT
+     )
+   }
+   AEBOUT_O = {
+     CASE(
+       DATA_CHANGE  & TRN_LH, DELAY(-1,23NS,35NS),
+       DATA_CHANGE  & TRN_HL, DELAY(-1,20NS,30NS),
+       AEBIN_CHANGE & TRN_LH, DELAY(-1,13NS,20NS),
+       AEBIN_CHANGE & TRN_HL, DELAY(-1,11NS,17NS),
+                              DELAY(-1,24NS,36NS)  ;DEFAULT
+     )
+   }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 7486  Quadruple 2-input Exclusive-Or Gates      
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/29/89	Update interface and model names
*
.subckt 7486  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(2) DPWR DGND
+	A B   A_BUF B_BUF 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U1 or(2) DPWR DGND
+	A_BUF B_BUF   C 
+	D_86_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U2 nand(2) DPWR DGND
+	A_BUF B_BUF   D 
+	D_86_2 IO_STD MNTYMXDLY={MNTYMXDLY} 
U3 and(2) DPWR DGND
+	C D   Y 
+	D_86_3 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_86_1 ugate (
+	tplhty=9ns	tplhmx=17ns
+	tphlty=5ns	tphlmx=11ns
+	)
.model D_86_2 ugate (
+	tplhty=12ns	tplhmx=24ns
+	tphlty=7ns	tphlmx=16ns
+	)
.model D_86_3 ugate (
+	tplhty=6ns	tplhmx=6ns
+	tphlty=6ns	tphlmx=6ns
+	)
*$
*-------------------------------------------------------------------------
* 7490A  COUNTER DECADE 4-BIT, ASYNCHRONOUS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   7-2-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*	    
.SUBCKT 7490A   R91_I R92_I CKA_I CKB_I R01_I R02_I   QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(1) DPWR DGND
+ SET9BAR CLRBAR   CKA     $D_HI $D_HI   QA $D_NC
+ D0_EFF IO_STD
U2 JKFF(1) DPWR DGND
+ $D_HI   CLRBAR23 CKB     QDBAR $D_HI   QB $D_NC 
+ D0_EFF IO_STD
U3 JKFF(1) DPWR DGND
+ $D_HI   CLRBAR23 QB      $D_HI $D_HI   QC $D_NC 
+ D0_EFF IO_STD
U4 JKFF(1) DPWR DGND
+ SET9BAR CLRBAR   CKB     J4    QD      QD QDBAR 
+ D0_EFF IO_STD
U90ALOG LOGICEXP (8,10) DPWR DGND
+ R91_I R92_I CKA_I CKB_I R01_I R02_I   QB QC
+ R91   R92   CKA   CKB   R01   R02     J4     SET9BAR  CLRBAR  CLRBAR23  
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   R91      = { R91_I }
+   R92      = { R92_I }
+   CKA      = { CKA_I }
+   CKB      = { CKB_I }
+   R01      = { R01_I }
+   R02      = { R02_I }
+   SET9BAR  = { ~(R91 & R92) }
+   CLRBAR   = { ~(R01 & R02) }
+   CLRBAR23 = { CLRBAR & SET9BAR }
+   J4       = { QB & QC }
*
U90ADLY PINDLY (4,0,8) DPWR DGND
+ QA QB QC QD
+ CKA CKB CLRBAR SET9BAR R01 R02 R91 R92
+ QA_O QB_O QC_O QD_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLOCKEDA = { CHANGED_HL(CKA,0) }
+   CLOCKEDB = { CHANGED_HL(CKB,0) }
+   SETNINE  = { CHANGED_HL(SET9BAR,0) }
+
+ PINDLY:
+   QA_O = {
+     CASE (
+       CLOCKEDA & TRN_LH, DELAY(-1,10NS,16NS),
+       CLOCKEDA & TRN_HL, DELAY(-1,12NS,18NS),
+                 SETNINE, DELAY(-1,20NS,30NS),
+       DELAY(-1,26NS,40NS)
+       )
+     }
+   QB_O = {
+     CASE (
+       CLOCKEDB & TRN_LH, DELAY(-1,10NS,16NS),
+       CLOCKEDB & TRN_HL, DELAY(-1,14NS,21NS),
+       DELAY(-1,26NS,40NS)
+       )
+     }
+   QC_O = {
+     CASE (
+       CLOCKEDB & TRN_LH, DELAY(-1,21NS,32NS),
+       CLOCKEDB & TRN_HL, DELAY(-1,23NS,35NS),
+       DELAY(-1,26NS,40NS)
+       )
+     }
+   QD_O = {
+     CASE (
+                 SETNINE, DELAY(-1,20NS,30NS),
+                  TRN_LH, DELAY(-1,21NS,32NS),
+       CLOCKEDB & TRN_HL, DELAY(-1,23NS,35NS),
+       DELAY(-1,26NS,40NS)
+       )
+     }
+
+ FREQ:
+   NODE           = CKA
+   MAXFREQ        = 32MEGHZ
+ FREQ:
+   NODE           = CKB
+   MAXFREQ        = 16MEGHZ
+ WIDTH:
+   NODE           = CKA
+   MIN_LO         = 15NS
+   MIN_HI         = 15NS
+ WIDTH:
+   NODE           = CKB
+   MIN_LO         = 30NS
+   MIN_HI         = 30NS
+ WIDTH:
+   NODE           = R01
+   MIN_LO         = 15NS
+   WHEN           = { SET9BAR!='0 }
+ WIDTH:
+   NODE           = R02
+   MIN_LO         = 15NS
+   WHEN           = { SET9BAR!='0 }
+ WIDTH:
+   NODE           = R91
+   MIN_LO         = 15NS
+ WIDTH:
+   NODE           = R92
+   MIN_LO         = 15NS
+ SETUP_HOLD:
+   DATA(2)        = R01 R02
+   CLOCK HL       = CKA
+   RELEASETIME_LH = 25NS
+   WHEN           = { SET9BAR!='0 & CHANGED(CLRBAR,25NS) }
+ SETUP_HOLD:
+   DATA(2)        = R01 R02
+   CLOCK HL       = CKB
+   RELEASETIME_LH = 25NS
+   WHEN           = { SET9BAR!='0 & CHANGED(CLRBAR,25NS) }
+ SETUP_HOLD:
+   DATA(2)        = R91 R92
+   CLOCK HL       = CKA
+   RELEASETIME_LH = 25NS
+   WHEN           = { CHANGED(SET9BAR,25NS) }
+ SETUP_HOLD:
+   DATA(2)        = R91 R92
+   CLOCK HL       = CKB
+   RELEASETIME_LH = 25NS
+   WHEN           = { CHANGED(SET9BAR,25NS) }
*														
.ENDS
*
*$
*-------------------------------------------------------------------------
* 7491A 8-BIT SHIFT REGISTERS
*
* THE TTL LOGIC STANDARD TTL, SCHOTTKY, LOW-POWER SCHOTKKY DATA BOOK, 1988, TI
* NH 7/13/92          REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 7491A CLK_I A_I B_I QH_O QHBAR_O
+ OPTIONAL:  DPWR=$G_DPWR   DGND=$G_DGND
+ PARAMS:    MNTYMXDLY=0    IO_LEVEL=0
*
U1 BUFA(3) DPWR DGND CLK_I A_I B_I CLK A B
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
*
U2 NAND(2) DPWR DGND A B KA
+ D0_GATE   IO_STD
*
U3 INVA(2) DPWR DGND CLK KA CLKBAR JA
+ D0_GATE   IO_STD
*
U5 JKFF(8) DPWR DGND $D_HI $D_HI CLKBAR
+ JA QA QB QC QD QE QF QG KA QABAR QBBAR QCBAR QDBAR QEBAR QFBAR QGBAR
+ QA QB QC QD QE QF QG QH QABAR QBBAR QCBAR QDBAR QEBAR QFBAR QGBAR QHBAR
+ D0_EFF  IO_STD
*
U91DLY PINDLY (2,0,3) DPWR DGND
+ QH QHBAR
+ CLK A B
+ QH_O QHBAR_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY}  IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   QH_O QHBAR_O = {
+     CASE(
+       CHANGED_LH(CLK,0) & TRN_LH, DELAY(-1,24NS,40NS),
+       CHANGED_LH(CLK,0) & TRN_HL, DELAY(-1,27NS,40NS),
+       DELAY(-1,28NS,41NS)         ;DEFAULT
+       )
+     }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 10MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 25NS
+   MIN_LO = 25NS
+
+ SETUP_HOLD:
+   DATA(2) A B
+   CLOCK LH = CLK
+   SETUPTIME = 25NS
*
.ENDS
*
*$
*------------------------------------------------------------------------
* 7492A  COUNTER DIVIDE-BY-12 4-BIT, ASYNCHRONOUS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-3-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
* NOTICE -- THE CKA TO QD PIN DELAY IS NOT INCLUDED IN THIS MODEL SINCE
*           THE DIV2 AND DIV8 SECTIONS OF THE COUNTER ACT INDEPENDENTLY. 
*	    
.SUBCKT 7492A   CKA_I CKB_I R01_I R02_I   QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CKA   $D_HI $D_HI   QA $D_NC
+ D0_EFF  IO_STD
U2 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CKB   QCBAR $D_HI   QB $D_NC 
+ D0_EFF  IO_STD
U3 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CKB   QB    $D_HI   QC QCBAR 
+ D0_EFF  IO_STD
U4 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QC    $D_HI $D_HI   QD $D_NC 
+ D0_EFF  IO_STD
U5 BUFA(4) DPWR DGND
+ CKA_I CKB_I R01_I R02_I   CKA CKB R01 R02
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U6 NAND(2) DPWR DGND
+ R01 R02   CLRBAR 
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
*
U92ADLY PINDLY (4,0,5) DPWR DGND
+ QA QB QC QD
+ CKA CKB CLRBAR R01 R02
+ QA_O QB_O QC_O QD_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLOCKEDA = { CHANGED_HL(CKA,0) }
+   CLOCKEDB = { CHANGED_HL(CKB,0) }
+   CLEARED  = { CHANGED_HL(CLRBAR,0) }
+
+ PINDLY:
+   QA_O = {
+     CASE (
+                  TRN_LH, DELAY(-1,10NS,16NS),
+       CLOCKEDA & TRN_HL, DELAY(-1,12NS,18NS),
+       DELAY(-1,26NS,40NS)
+       )
+     }
+   QB_O QC_O = {
+     CASE (
+                  TRN_LH, DELAY(-1,10NS,16NS),
+       CLOCKEDB & TRN_HL, DELAY(-1,14NS,21NS),
+       DELAY(-1,26NS,40NS)
+       )
+     }
+   QD_O = {
+     CASE (
+                  TRN_LH, DELAY(-1,21NS,32NS),
+       CLOCKEDB & TRN_HL, DELAY(-1,23NS,35NS),
+       DELAY(-1,26NS,40NS)
+       )
+     }
+
+ FREQ:
+   NODE           = CKA
+   MAXFREQ        = 32MEGHZ
+ FREQ:
+   NODE           = CKB
+   MAXFREQ        = 16MEGHZ
+ WIDTH:
+   NODE           = CKA
+   MIN_LO         = 15NS
+   MIN_HI         = 15NS
+ WIDTH:
+   NODE           = CKB
+   MIN_LO         = 30NS
+   MIN_HI         = 30NS
+ WIDTH:
+   NODE           = R01
+   MIN_HI         = 15NS
+ WIDTH:
+   NODE           = R02
+   MIN_HI         = 15NS
+ SETUP_HOLD:
+   DATA(2)        = R01 R02
+   CLOCK HL       = CKA
+   RELEASETIME_HL = 25NS
+   WHEN           = { CHANGED(CLRBAR,25NS) }
+ SETUP_HOLD:
+   DATA(2)        = R01 R02
+   CLOCK HL       = CKB
+   RELEASETIME_HL = 25NS
+   WHEN           = { CHANGED(CLRBAR,25NS) }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 7493A  COUNTER BINARY 4-BIT, ASYNCHRONOUS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   6-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
* NOTICE -- THE CKA TO QD PIN DELAY IS NOT INCLUDED IN THIS MODEL SINCE
*           THE DIV2 AND DIV8 SECTIONS OF THE COUNTER ACT INDEPENDENTLY. 
*	    
.SUBCKT 7493A   CKA_I CKB_I R01_I R02_I   QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CKA   $D_HI $D_HI     QA $D_NC
+ D0_EFF  IO_STD
U2 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CKB   $D_HI $D_HI     QB $D_NC 
+ D0_EFF  IO_STD
U3 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QB    $D_HI $D_HI     QC $D_NC 
+ D0_EFF  IO_STD
U4 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QC    $D_HI $D_HI     QD $D_NC 
+ D0_EFF  IO_STD
U5 BUFA(4) DPWR DGND
+ CKA_I CKB_I R01_I R02_I   CKA CKB R01 R02
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U6 NAND(2) DPWR DGND
+ R01 R02   CLRBAR 
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
*
U93ADLY PINDLY (4,0,5) DPWR DGND
+ QA QB QC QD
+ CKA CKB CLRBAR R01 R02
+ QA_O QB_O QC_O QD_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLOCKEDA = { CHANGED_HL(CKA,0) }
+   CLOCKEDB = { CHANGED_HL(CKB,0) }
+   CLEARED  = { CHANGED_HL(CLRBAR,0) }
+
+ PINDLY:
+ QA_O = {
+   CASE (
+                TRN_LH, DELAY(-1,10NS,16NS),
+     CLOCKEDA & TRN_HL, DELAY(-1,12NS,18NS),
+     DELAY(-1,26NS,40NS)
+     )
+   }
+ QB_O = {
+   CASE (
+                TRN_LH, DELAY(-1,10NS,16NS),
+     CLOCKEDB & TRN_HL, DELAY(-1,14NS,21NS),
+     DELAY(-1,26NS,40NS)
+     )
+   }
+ QC_O = {
+   CASE (
+                TRN_LH, DELAY(-1,21NS,32NS),
+     CLOCKEDB & TRN_HL, DELAY(-1,23NS,35NS),
+     DELAY(-1,26NS,40NS)
+     )
+   }
+ QD_O = {
+   CASE (
+     CLEARED,  DELAY(-1,26NS,40NS),
+     DELAY(-1,34NS,51NS)
+     )
+   }
+
+ FREQ:
+   NODE           = CKA
+   MAXFREQ        = 32MEGHZ
+ FREQ:
+   NODE           = CKB
+   MAXFREQ        = 16MEGHZ
+ WIDTH:
+   NODE           = CKA
+   MIN_LO         = 15NS
+   MIN_HI         = 15NS
+ WIDTH:
+   NODE           = CKB
+   MIN_LO         = 30NS
+   MIN_HI         = 30NS
+ WIDTH:
+   NODE           = R01
+   MIN_HI         = 15NS
+ WIDTH:
+   NODE           = R02
+   MIN_HI         = 15NS
+ SETUP_HOLD:
+   DATA(2)        = R01 R02
+   CLOCK HL       = CKA
+   RELEASETIME_HL = 25NS
+   WHEN           = { CHANGED(CLRBAR,25NS) }
+ SETUP_HOLD:
+   DATA(2)        = R01 R02
+   CLOCK HL       = CKB
+   RELEASETIME_HL = 25NS
+   WHEN           = { CHANGED(CLRBAR,25NS) }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 7494  4-BIT SHIFT REGISTERS
*
* THE TTL DATA BOOK, VOL 2, 1988, TI
* NH 7/1/92          REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 7494 CLR_I CLK_I SER_I PE1_I P1A_I P1B_I P1C_I P1D_I
+ PE2_I P2A_I P2B_I P2C_I P2D_I QD_O
+ OPTIONAL: DPWR = $G_DPWR   DGND = $G_DGND
+ PARAMS:   MNTYMXDLY = 0    IO_LEVEL = 0
*
U94LOG LOGICEXP(13,20) DPWR  DGND
+ CLR_I CLK_I SER_I PE1_I P1A_I P1B_I P1C_I P1D_I PE2_I P2A_I P2B_I P2C_I P2D_I
+ CLR CLK SER PE1 P1A P1B P1C P1D PE2 P2A P2B P2C P2D SERBAR CLKBAR CLRBAR
+  PRESETA PRESETB PRESETC PRESETD
+ D0_GATE   IO_STD   IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
*
* OUTPUT ASSIGNMENT
*
+   CLR = { CLR_I }
+   CLK = { CLK_I }
+   SER = { SER_I }
+   PE1 = { PE1_I }
+   P1A = { P1A_I }
+   P1B = { P1B_I }
+   P1C = { P1C_I }
+   P1D = { P1D_I }
+   PE2 = { PE2_I }
+   P2A = { P2A_I }
+   P2B = { P2B_I }
+   P2C = { P2C_I }
+   P2D = { P2D_I }
*
+   PRESETA = { ~( (PE1 & P1A) | (PE2 & P2A) ) }
+   PRESETB = { ~( (PE1 & P1B) | (PE2 & P2B) ) }
+   PRESETC = { ~( (PE1 & P1C) | (PE2 & P2C) ) }
+   PRESETD = { ~( (PE1 & P1D) | (PE2 & P2D) ) }
+   SERBAR = { ~SER }
+   CLKBAR = { ~CLK }
+   CLRBAR = { ~CLR }
*
U1 JKFF(1) DPWR DGND PRESETA CLRBAR CLKBAR SER SERBAR QA QABAR
+ D0_EFF IO_STD
*
U2 JKFF(1) DPWR DGND PRESETB CLRBAR CLKBAR QA QABAR QB QBBAR
+ D0_EFF IO_STD
*
U3 JKFF(1) DPWR DGND PRESETC CLRBAR CLKBAR QB QBBAR QC QCBAR
+ D0_EFF IO_STD
*
U4 JKFF(1) DPWR DGND PRESETD CLRBAR CLKBAR QC QCBAR LQD QDBAR
+ D0_EFF IO_STD
*
U94DLY PINDLY (1,0,17) DPWR DGND
+ LQD
+ CLK CLR PE1 P1D PE2 P2D SER P1A P1B P1C P2A P2B P2C PRESETA PRESETB PRESETC PRESETD
+ QD_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY}   IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   PRESET = { (PE1!='0 & P1D!='0) | (PE2!='0 & P2D!='0) }
+
+ PINDLY:
+   QD_O = {
+     CASE(
+        PRESET, DELAY(-1,-1,35NS),
+        CHANGED_LH(CLR,0) & TRN_HL, DELAY(-1,-1,40NS),
+        CHANGED_LH(CLK,0), DELAY(-1,25NS,40NS),
+        DELAY(11NS,26NS,41NS)           ;DEFAULT
+        )
+      }
+
+ BOOLEAN:
+   PE1_EN = { PE1!='0 }
+   PE2_EN = { PE2!='0 }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 10MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 35NS
+   MIN_LO = 35NS
+
+ WIDTH:
+   NODE = CLR
+   MIN_HI = 30NS
+
+ WIDTH:
+   NODE = P1A
+   MIN_HI = 30NS
+   WHEN = { PE1_EN }
+
+ WIDTH:
+   NODE = P2A
+   MIN_HI = 30NS
+   WHEN = { PE2_EN }
+
+ WIDTH:
+   NODE = P1B
+   MIN_HI = 30NS
+   WHEN = { PE1_EN }
+
+ WIDTH:
+   NODE = P2B
+   MIN_HI = 30NS
+   WHEN = { PE2_EN  }
+
+ WIDTH:
+   NODE = P1C
+   MIN_HI = 30NS
+   WHEN = { PE1_EN }
+
+ WIDTH:
+   NODE = P2C
+   MIN_HI = 30NS
+   WHEN = { PE2_EN }
+
+ WIDTH:
+   NODE = P1D
+   MIN_HI = 30NS
+   WHEN = { PE1_EN }
+
+ WIDTH:
+   NODE = P2D
+   MIN_HI = 30NS
+   WHEN = { PE2_EN }
+
+ SETUP_HOLD:
+   DATA(1) SER
+   CLOCK LH = CLK
+   SETUPTIME_HI = 35NS
+   SETUPTIME_LO = 25NS
+   WHEN = { CLR!='1 & PRESETA!='0 & PRESETB!='0 & PRESETC!='0 & PRESETD!='0 }
*
.ENDS
*
*$
*------------------------------------------------------------------------
* 7495A  4-BIT PARALLEL SHIFT REGISTERS
*
* THE TTL DATA BOOK, VOL 2, 1985, TI
* KN   7-29-92      REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 7495A MODE_I CLK1_I CLK2_I SER_I A_I B_I C_I D_I QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR   DGND=$G_DGND
+ PARAMS:   MNTYMXDLY=0    IO_LEVEL=0
*
U95ALOG LOGICEXP(11,17) DPWR DGND
+ MODE_I CLK1_I CLK2_I SER_I A_I B_I C_I D_I QA QB QC
+ MODE CLK1 CLK2 SER A B C D CLK JA JB JC JD KA KB KC KD
+ D0_GATE  IO_STD
+ IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   MODE = { MODE_I }
+   CLK1 = { CLK1_I }
+   CLK2 = { CLK2_I }
+   SER = { SER_I }
+   A   = { A_I }
+   B   = { B_I }
+   C   = { C_I }
+   D   = { D_I }
+
* INTERMEDIATE TERM
+   MODEBAR = { ~MODE }
+
+   CLK = { ((MODEBAR  & CLK1) | (MODE  & CLK2)) }
+   JA  = { (MODEBAR  & SER)   | (MODE  & A) }
+   JB  = { (MODEBAR  & QA) | (MODE  & B) }
+   JC  = { (MODEBAR  & QB) | (MODE  & C) }
+   JD  = { (MODEBAR  & QC) | (MODE  & D) }
+   KA = { ~JA }
+   KB = { ~JB }
+   KC = { ~JC }
+   KD = { ~JD }
*
U1 JKFF(4) DPWR DGND $D_HI $D_HI CLK
+ JA JB JC JD KA KB KC KD QA QB QC QD $D_NC  $D_NC $D_NC $D_NC
+ D0_EFF IO_STD
*
U95ADLY PINDLY (4,0,8) DPWR DGND
+ QA QB QC QD
+ CLK1 CLK2 MODE SER A B C D
+ QA_O QB_O QC_O QD_O
+ IO_STD  MNTYMXDLY={MNTYMXDLY}  IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+    CLK = { CHANGED_HL(CLK1,0) | CHANGED_HL(CLK2,0) }
+
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CLK & TRN_LH,  DELAY(-1,18NS,27NS),
+       CLK & TRN_HL,  DELAY(-1,21NS,32NS),
+                      DELAY(-1,22NS,33NS)  ;DEFAULT
+       )
+      }
+
+ FREQ:
+   NODE = CLK1
+   MAXFREQ = 25MEG
+
+ FREQ:
+   NODE = CLK2
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = CLK1
+   MIN_HI = 20NS
+
+ WIDTH:
+   NODE = CLK2
+   MIN_HI = 20NS
+
+ SETUP_HOLD:
+   DATA(4) A  B  C  D
+   CLOCK HL = CLK2
+   SETUPTIME = 15NS
+   WHEN = { MODE != '0 }
+
+ SETUP_HOLD:
+   DATA(1) SER
+   CLOCK HL = CLK1
+   SETUPTIME = 15NS
+   WHEN = { MODE != '1 }
+
+ SETUP_HOLD:          ; T_ENABLE1
+   DATA(1) MODE
+   CLOCK HL = CLK1
+   SETUPTIME_LO = 15NS
+   MESSAGE = "TENABLE1 IS NOT MET"
+
+ SETUP_HOLD:          ; T_ENABLE2
+   DATA(1) MODE
+   CLOCK HL = CLK2
+   SETUPTIME_HI = 15NS
+   MESSAGE = "TENABLE2 IS NOT MET"
+
+ SETUP_HOLD:          ; T_INHIBIT1
+   DATA(1) MODE
+   CLOCK LH = CLK1
+   SETUPTIME_HI = 5NS
+   MESSAGE = "TINHIBIT1 IS NOT MET"
+
+ SETUP_HOLD:          ; T_INHIBIT2
+   DATA(1) MODE
+   CLOCK LH = CLK2
+   SETUPTIME_LO = 5NS
+   MESSAGE = "TINHIBIT2 IS NOT MET"
*
.ENDS
*
*
*$
*--------------------------------------------------------------------------
* 7496  8-BIT PARALLEL-OUT SERIAL SHIFT REGISTERS
*
* THE TTL DATA BOOK, VOL 2, 1985, TI
* KN   7-1-92        REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 7496  CLRBAR_I CLK_I SER_I PRE_I A_I B_I C_I D_I E_I
+ QA_O QB_O QC_O QD_O QE_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 BUFA(9) DPWR DGND
+ CLRBAR_I CLK_I SER_I PRE_I A_I B_I C_I D_I E_I
+ CLRBAR  CLK  SER  PRE  A  B  C  D  E
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
*
U2 NANDA(2,5) DPWR DGND
+ PRE A  PRE B  PRE C  PRE D  PRE E
+ OUT_A  OUT_B  OUT_C  OUT_D  OUT_E
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
*
U3 DFF(1) DPWR DGND
+ OUT_A  CLRBAR  CLK
+ SER
+ QA
+ $D_NC
+ D0_EFF IO_STD
*
U4 DFF(1) DPWR DGND
+ OUT_B  CLRBAR  CLK
+ QA
+ QB
+ $D_NC
+ D0_EFF IO_STD
*
U5 DFF(1) DPWR DGND
+ OUT_C  CLRBAR  CLK
+ QB
+ QC
+ $D_NC
+ D0_EFF IO_STD
*
U6 DFF(1) DPWR DGND
+ OUT_D  CLRBAR  CLK
+ QC
+ QD
+ $D_NC
+ D0_EFF IO_STD
*
U7 DFF(1) DPWR DGND
+ OUT_E  CLRBAR  CLK
+ QD
+ QE
+ $D_NC
+ D0_EFF IO_STD
*
USTD96DLY PINDLY (5,0,4) DPWR DGND
+ QA QB QC QD QE
+ CLRBAR PRE CLK SER
+ QA_O QB_O QC_O QD_O QE_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+   QA_O QB_O QC_O QD_O QE_O = {
+     CASE(
+       CHANGED_LH(PRE,0),    DELAY(-1,28NS,35NS),
+       CHANGED_LH(CLK,0),    DELAY(-1,25NS,40NS),
+       CHANGED_HL(CLRBAR,0), DELAY(-1,-1,55NS),
+                             DELAY(-1,-1,56NS)  ;DEFAULT
+       )
+     }
+
+ FREQ:
+   NODE    = CLK
+   MAXFREQ = 10MEG
+
+ WIDTH:
+   NODE   = CLK
+   MIN_HI = 35NS
+   MIN_LO = 35NS
+
+ WIDTH:
+   NODE   = CLRBAR
+   MIN_LO = 30NS
+
+ WIDTH:
+   NODE   = PRE
+   MIN_HI = 30NS
+
+ SETUP_HOLD:
+   DATA(1)   = SER    ; NOR SETTING
+   CLOCK LH  = CLK    ; CHECK SERIAL INPUT SETUPTIME WHEN NOT CLEARING
+   SETUPTIME = 30NS
+   WHEN = { (CLRBAR != '0) & (PRE != '1) }
*
.ENDS
*
*
*$
*-------------------------------------------------------------------------
* 7497  RATE MULTIPLIER SYNCHRONOUS 6-BIT BINARY
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   7-10-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 7497   CLR_I STRBBAR_I CLK_I ENINBAR_I
+ B0_I B1_I B2_I B3_I B4_I B5_I UNICASBAR_I
+ Y_O ZBAR_O ENOUTBAR_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(6) DPWR DGND
+ $D_HI CLRBAR CLKBAR
+  TOGA  TOGB  TOGC  TOGD  TOGE  TOGF
+  TOGA  TOGB  TOGC  TOGD  TOGE  TOGF
+    QA    QB    QC    QD    QE    QF
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF  IO_STD
U2 DFF(1) DPWR DGND
+ $D_HI $D_HI CLKBAR
+ ENIN  ENINFALL  $D_NC
+ D0_EFF  IO_STD
*
U97LOG LOGICEXP (18,23) DPWR DGND
+ CLR_I  STRBBAR_I CLK_I  ENINBAR_I B0_I B1_I B2_I B3_I B4_I B5_I UNICASBAR_I
+ QA QB QC QD QE QF ENINFALL
+ CLR CLRBAR STRBBAR CLKBAR ENIN  ENINBAR B0   B1   B2  B3  B4  B5  UNICASBAR
+ TOGA TOGB TOGC TOGD TOGE TOGF   Y ZBAR ENOUTBAR CLK
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   CLR       = { CLR_I }
+   CLRBAR    = { ~CLR }
+   STRBBAR   = { STRBBAR_I }
+   CLK       = { CLK_I }
+   CLKBAR    = { ~CLK }
+   ENINBAR   = { ENINBAR_I }
+   ENIN      = { ~ENINBAR }
+   B0        = { B0_I }
+   B1        = { B1_I }
+   B2        = { B2_I }
+   B3        = { B3_I }
+   B4        = { B4_I }
+   B5        = { B5_I }
+   UNICASBAR = { UNICASBAR_I }
+   STRBCLK   = { CLKBAR & ~STRBBAR }
+   ENINRF    = { ENIN | ENINFALL }
+   TOGA      = { ENINRF }
+   TOGB      = { TOGA & QA }
+   TOGC      = { TOGB & QB }
+   TOGD      = { TOGC & QC }
+   TOGE      = { TOGD & QD }
+   TOGF      = { TOGE & QE }
+   ZBAR      = { ~( (B5 & STRBCLK & ~QA) |
+                    (B4 & STRBCLK &  QA & ~QB) |
+                    (B3 & STRBCLK &  QA &  QB & ~QC) |
+                    (B2 & STRBCLK &  QA &  QB &  QC & ~QD) |
+                    (B1 & STRBCLK &  QA &  QB &  QC &  QD & ~QE) |
+                    (B0 & STRBCLK &  QA &  QB &  QC &  QD &  QE & ~QF)
+                  )
+               }
+   Y         = { ~(UNICASBAR & ZBAR) }
+   ENOUTBAR  = { ~(ENIN & QA & QB & QC & QD & QE & QF) }
*
U97DLY PINDLY (3,0,12) DPWR DGND
+ Y ZBAR ENOUTBAR
+ CLR STRBBAR CLK ENINBAR B0 B1 B2 B3 B4 B5 UNICASBAR ENINFALL
+ Y_O ZBAR_O ENOUTBAR_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLEARED  = { CHANGED_LH(CLR,0) }
+   STROBED  = { CHANGED(STRBBAR,0) }
+   CLOCKED  = { CHANGED_LH(CLK,0) }
+   ENABLED  = { CHANGED(ENINBAR,0) }
+   RATECHG  = { CHANGED(B0,0) | CHANGED(B1,0) | CHANGED(B2,0) |
+                CHANGED(B3,0) | CHANGED(B4,0) | CHANGED(B5,0) }
+   CASCADED = { CHANGED(UNICASBAR,0) }
+
+ PINDLY:
+   Y_O = {
+     CASE (
+       CASCADED & TRN_HL, DELAY(-1, 6NS,10NS),
+       CASCADED & TRN_LH, DELAY(-1, 9NS,14NS),
+       RATECHG          , DELAY(-1,15NS,23NS),
+       STROBED  & TRN_LH, DELAY(-1,19NS,30NS),
+       CLOCKED  & TRN_HL, DELAY(-1,20NS,30NS),
+       STROBED  & TRN_HL, DELAY(-1,22NS,33NS),
+       CLEARED          , DELAY(-1,24NS,36NS),
+                  TRN_LH, DELAY(-1,26NS,39NS),
+       DELAY(-1,26NS,39NS)
+       )
+     }
+   ZBAR_O = {
+     CASE (
+       RATECHG & TRN_LH, DELAY(-1, 6NS,10NS),
+       RATECHG & TRN_HL, DELAY(-1, 9NS,14NS),
+       STROBED & TRN_LH, DELAY(-1,12NS,18NS),
+       STROBED & TRN_HL, DELAY(-1,15NS,23NS),
+       CLEARED         , DELAY(-1,15NS,23NS),
+                 TRN_LH, DELAY(-1,12NS,18NS),
+                 TRN_HL, DELAY(-1,17NS,26NS),
+       DELAY(-1,17NS,26NS)
+       )
+     }
+   ENOUTBAR_O = {
+     CASE (
+       ENABLED & TRN_LH, DELAY(-1,13NS,20NS),
+       ENABLED & TRN_HL, DELAY(-1,14NS,21NS),
+                 TRN_LH, DELAY(-1,19NS,30NS),
+                 TRN_HL, DELAY(-1,22NS,33NS),
+       DELAY(-1,22NS,33NS)
+       )
+     }
+
+ FREQ:
+   NODE      = CLK
+   MAXFREQ   = 25MEGHZ
+ WIDTH:
+   NODE      = CLK
+   MIN_LO    = 20NS
+   MIN_HI    = 20NS
+ WIDTH:
+   NODE      = CLR
+   MIN_HI    = 15NS
+ SETUP_HOLD:
+   DATA(1)   = ENINBAR
+   CLOCK LH  = CLK			
+   SETUPTIME = 25NS
+   WHEN      = { CLR!='1 }
+ SETUP_HOLD:
+   DATA(1)   = ENINBAR
+   CLOCK HL  = CLK			
+   HOLDTIME  = 20NS
+   WHEN      = { CLR!='1 }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74100  8-Bit Bistable Latches
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	08/17/89	Update interface and model names
*
.subckt 74100  1C 1D1 1D2 1D3 1D4 1Q1 1Q2 1Q3 1Q4
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* There are 2 4-bit latches in the real 74100 IC.  However, the model here is 
* designed with only 1 4-bit latch. In case of 8-bit latches needed, please use 
* the SUBCKT twice. 
*
U1 dltch(4) DPWR DGND
+	$D_HI	$D_HI	1C
+	1D1	1D2	1D3	1D4
+	1Q1	1Q2	1Q3	1Q4	$D_NC	$D_NC	$D_NC	$D_NC
+	D_100 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_100 ugff (
+	twghmn=20ns	tsudgmn=20ns
+	thdgmn=5ns	tpgqlhty=16ns
+	tpgqlhmx=30ns	tpgqhlty=7ns
+	tpgqhlmx=15ns	tpdqlhty=16ns
+	tpdqlhmx=30ns	tpdqhlty=14ns
+	tpdqhlmx=25ns
+	)
*$
*-------------------------------------------------------------------------
* 74104  Gated J-K Master-Slave Flip-Flops
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	08/18/89	Update interface and model names
*
.subckt 74104  CLK PREBAR CLRBAR JK J1 J2 J3 K1 K2 K3 Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 bufa(3) DPWR DGND
+	CLRBAR PREBAR CLK   CLRB PREB CLK_BUF 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U2 anda(4,2) DPWR DGND
+	J1	J2	J3	JK
+	K1	K2	K3	JK
+	J1	K1
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U3 bufa(2) DPWR DGND
+	J1 K1   J11 K11 
+	D0_GATE IO_LS 
U4 bufa(2) DPWR DGND
+	J1 K2   J11 K11 
+	D_104_1 IO_LS MNTYMXDLY={MNTYMXDLY} 
U5 inva(3) DPWR DGND
+	CLK_BUF J11 K11   CLKB J11B K11B 
+	D0_GATE IO_STD 
U6 ao(3,2) DPWR DGND
+	J11 K11 QB1 J11 K11B $D_HI   J 
+	D0_GATE IO_STD 
U7 ao(3,2) DPWR DGND
+	J11 K11 Q1 J11B K11 $D_HI   K 
+	D0_GATE IO_STD 
UE1 jkff(1) DPWR DGND
+	PREB CLRB CLK_BUF   J K   Y YB 
+	D_104_2 IO_STD MNTYMXDLY={MNTYMXDLY} 
UE2 jkff(1) DPWR DGND
+	PREB CLRB CLKB   Y YB   QD QBD 
+	D_104_3 IO_STD MNTYMXDLY={MNTYMXDLY} 
U8 bufa(4) DPWR DGND
+	QD QD QBD QBD   Q1 Q QB1 QBAR 
+	D_104_4 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_104_1 ugate (
+	tplhmn=25ns	tplhmx=25ns
+	)
.model D_104_2 ueff (
+	twclklmn=15ns	twpclmn=20ns
+	tsudclkmn=10ns
+	)
.model D_104_3 ueff (
+	twclkhmn=15ns	twpclmn=20ns
+	tppcqlhty=3ns	tppcqlhmx=9ns
+	tppcqhlty=10ns	tppcqhlmx=19ns
+	tpclkqlhty=3ns	tpclkqlhmx=9ns
+	tpclkqhlty=10ns	tpclkqhlmx=19ns
+	)
.model D_104_4 ugate (
+	tphlty=6ns	tphlmx=6ns
+	tplhty=6ns	tplhmx=6ns
+	)
*$
*-------------------------------------------------------------------------
* 74105  Gated J-K Master-Slave Flip-Flops
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	08/18/89	Update interface and model names
*
.subckt 74105  CLK PREBAR CLRBAR JK J1 J2BAR J3 K1 K2BAR K3 Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 bufa(3) DPWR DGND
+	CLRBAR PREBAR CLK   CLRB PREB CLK_BUF 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U2 anda(4,2) DPWR DGND
+	J1	J2	J3	JK
+	K1	K2	K3	JK
+	J1	K1
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U3 bufa(2) DPWR DGND
+	J1 K1   J11 K11 
+	D0_GATE IO_LS 
U4 bufa(2) DPWR DGND
+	J1 K2   J11 K11 
+	D_105_1 IO_LS MNTYMXDLY={MNTYMXDLY} 
U5 inva(5) DPWR DGND
+	CLK_BUF	J2BAR	K2BAR	J11	K11
+	CLKB	J2	K2	J11B	K11B
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U6 ao(3,2) DPWR DGND
+	J11 K11 QB1 J11 K11B $D_HI   J 
+	D0_GATE IO_STD 
U7 ao(3,2) DPWR DGND
+	J11 K11 Q1 J11B K11 $D_HI   K 
+	D0_GATE IO_STD 
UE1 jkff(1) DPWR DGND
+	PREB CLRB CLK_BUF   J K   Y YB 
+	D_105_2 IO_STD MNTYMXDLY={MNTYMXDLY} 
UE2 jkff(1) DPWR DGND
+	PREB CLRB CLKB   Y YB   QD QBD 
+	D_105_3 IO_STD MNTYMXDLY={MNTYMXDLY} 
U8 bufa(4) DPWR DGND
+	QD QD QBD QBD   Q1 Q QB1 QBAR 
+	D_105_4 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_105_1 ugate (
+	tplhmn=25ns	tplhmx=25ns
+	)
.model D_105_2 ueff (
+	twclklmn=15ns	twpclmn=20ns
+	tsudclkmn=10ns
+	)
.model D_105_3 ueff (
+	twclkhmn=15ns	twpclmn=20ns
+	tppcqlhty=3ns	tppcqlhmx=9ns
+	tppcqhlty=10ns	tppcqhlmx=19ns
+	tpclkqlhty=3ns	tpclkqlhmx=9ns
+	tpclkqhlty=10ns	tpclkqhlmx=19ns
+	)
.model D_105_4 ugate (
+	tphlty=6ns	tphlmx=6ns
+	tplhty=6ns	tplhmx=6ns
+	)
*$
*-------------------------------------------------------------------------
* 74107  Dual J-K Flip-Flops with Clear
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/29/89	Update interface and model names
* jgt   04/20/95        Changed to use jkff's to avoid ambiguity latchup
*                       problems inherent in use of srff's w/feedback.
*
.subckt 74107  CLK CLRBAR J K Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(3) DPWR DGND
+	CLRBAR J K   CLRBAR_BUF J_BUF K_BUF 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U2BUF buf DPWR DGND
+	CLK   CLK_BUF 
+	D_107_4 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U1 JKff(1) DPWR DGND
+	$D_HI CLRBAR_BUF CLKBAR   W1 W2   Y YB
+	D_107_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U2 JKff(1) DPWR DGND
+	$D_HI CLRBAR_BUF CLK_BUF   Y YB   QBUF QBAR_BUF 
+	D_107_2 IO_STD MNTYMXDLY={MNTYMXDLY} 
U3 inva(3) DPWR DGND
+	CLK_BUF J_BUF K_BUF   CLKBAR JB KB 
+	D0_GATE IO_STD 
U4 ao(3,2) DPWR DGND
+	J_BUF K_BUF QBAR_BUFD J_BUF KB $D_HI   W1 
+	D_107_3 IO_STD MNTYMXDLY={MNTYMXDLY} 
U5 ao(3,2) DPWR DGND
+	J_BUF K_BUF QBUFD JB K_BUF $D_HI   W2 
+	D_107_3 IO_STD MNTYMXDLY={MNTYMXDLY} 
UBUF bufa(4) DPWR DGND
+	QBUF QBAR_BUF QBUF QBAR_BUF   Q QBAR QBUFD QBAR_BUFD 
+	D_107_3 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_107_1 ueff (
+	tppcqlhty=10ns	tppcqlhmx=15ns
+	tppcqhlty=10ns	tppcqhlmx=15ns
+	tpclkqlhty=10ns	tpclkqlhmx=16ns
+	tpclkqhlty=18ns	tpclkqhlmx=28ns
+	twclkhmx=20ns	twclklmx=20ns
+	twclkhty=20ns	twclklty=20ns
+	twpclmx=20ns	twpclty=20ns
+	tsudclkmx=10ns	tsudclkty=20ns
+	thdclkmx=6ns	thdclkty=6ns
+	)
.model D_107_2 ueff (
+	tppcqlhty=10ns	tppcqlhmx=19ns
+	tppcqhlty=19ns	tppcqhlmx=34ns
+	tpclkqlhty=10ns	tpclkqlhmx=19ns
+	tpclkqhlty=19ns	tpclkqhlmx=34ns
+	twclkhmx=20ns	twclklmx=20ns
+	twclkhty=20ns	twclklty=20ns
+	twpclmx=20ns	twpclty=20ns
+	tsudclkmx=10ns	tsudclkty=20ns
+	thdclkmx=6ns	thdclkty=6ns
+	)
.model D_107_3 ugate (
+	tplhty=6ns	tplhmx=6ns
+	tphlty=6ns	tphlmx=6ns
+	)
.model D_107_4 ugate (
+	tplhmn=6ns	tplhmx=6ns
+	)
*$
*-------------------------------------------------------------------------
* 74109  Dual J-KBar Positive-Edge-Triggered Flip-Flops w/ Preset & Clear    
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/30/89	Update interface and model names
*
.subckt 74109  CLK PREBAR CLRBAR J KBAR Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(3) DPWR DGND
+	PREBAR CLRBAR J   PREBAR_BUF CLRBAR_BUF J_BUF 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U1 jkff(1) DPWR DGND
+	PREBAR_BUF CLRBAR_BUF CLKBAR   J_BUF K   $D_NC QBAR 
+	D_109_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U2 jkff(1) DPWR DGND
+	PREBAR_BUF CLRBAR_BUF CLKBAR   J_BUF K   Q $D_NC 
+	D_109_2 IO_STD MNTYMXDLY={MNTYMXDLY} 
U3 inva(2) DPWR DGND
+	CLK KBAR   CLKBAR K 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_109_1 ueff (
+	tppcqlhty=10ns	tppcqlhmx=15ns
+	tppcqhlty=10ns	tppcqhlmx=15ns
+	tpclkqlhty=10ns	tpclkqlhmx=16ns
+	tpclkqhlty=18ns	tpclkqhlmx=28ns
+	twclkhmx=20ns	twclklmx=20ns
+	twclkhty=20ns	twclklty=20ns
+	twpclmx=20ns	twpclty=20ns
+	tsudclkmx=10ns	tsudclkty=20ns
+	thdclkmx=6ns	thdclkty=6ns
+	)
.model D_109_2 ueff (
+	tppcqlhty=23ns	tppcqlhmx=35ns
+	tppcqhlty=17ns	tppcqhlmx=25ns
+	tpclkqlhty=10ns	tpclkqlhmx=16ns
+	tpclkqhlty=18ns	tpclkqhlmx=28ns
+	twclkhmx=20ns	twclklmx=20ns
+	twclkhty=20ns	twclklty=20ns
+	twpclmx=20ns	twpclty=20ns
+	tsudclkmx=10ns	tsudclkty=20ns
+	thdclkmx=6ns	thdclkty=6ns
+	)
*$
*-------------------------------------------------------------------------
* 74110  And-Gated J-K Master-Slave Flip-Flops with Data Lockout
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	08/18/89	Update interface and model names
*
.subckt 74110  CLK PREBAR CLRBAR J1 J2 J3 K1 K2 K3 Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(2) DPWR DGND
+	PREBAR CLRBAR   PREBAR_BUF CLRBAR_BUF 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U1 inv DPWR DGND
+	CLK   CLKBAR 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U2 anda(3,2) DPWR DGND
+	J1 J2 J3 K1 K2 K3   J K 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U3 jkff(1) DPWR DGND
+	PREBAR_BUF CLRBAR_BUF CLKBAR   J K   QI $D_NC 
+	D_110_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U4 dff(1) DPWR DGND
+	PREBAR_BUF CLRBAR_BUF CLKBAR   QI   Q QBAR 
+	D_110_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_110_1 ueff (
+	tsudclkmn=20ns	thdclkmn=5ns
+	twclkhmn=25ns	twclklmn=25ns
+	twpclmn=25ns
+	)
.model D_110_2 ueff (
+	tppcqlhty=12ns	tppcqlhmx=20ns
+	tsudclkmn=20ns	thdclkmn=5ns
+	tppcqhlty=18ns	tppcqhlmx=25ns
+	tpclkqlhty=20ns	tpclkqlhmx=30ns
+	tpclkqhlty=13ns	tpclkqhlmx=20ns
+	twclkhmn=25ns	twpclmn=25ns
+	)
*$
*-------------------------------------------------------------------------
* 74111  Dual J-K Master-Slave Flip-Flops with Data Lockout        
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	06/30/89	Update interface and model names
*
.subckt 74111  CLK PREBAR CLRBAR J K Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(2) DPWR DGND
+	PREBAR CLRBAR   PREBAR_BUF CLRBAR_BUF 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
UA inv DPWR DGND
+	CLK   CLKBAR 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U1 jkff(1) DPWR DGND
+	PREBAR_BUF CLRBAR_BUF CLKBAR   J K   QI $D_NC 
+	D_111_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U2 dltch(1) DPWR DGND
+	PREBAR_BUF CLRBAR_BUF CLK   QI   Q QBAR 
+	D_111_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_111_1 ueff (
+	thdclkty=30ns	thdclkmx=30ns
+	twclkhty=25ns	twclkhmx=25ns
+	twclklty=25ns	twclklmx=25ns
+	twpclty=25ns	twpclmx=25ns
+	)
.model D_111_2 ugff (
+	tppcqlhty=12ns	tppcqlhmx=18ns
+	tppcqhlty=21ns	tppcqhlmx=30ns
+	tpgqlhty=12ns	tpgqlhmx=17ns
+	tpgqhlty=20ns	tpgqhlmx=30ns
+	twghmx=25ns	twghty=25ns
+	twpclmx=25ns	twpclty=25ns
+	)
*$
*-------------------------------------------------------------------------
*
*  74116 DUAL 4-BIT LATCHES WITH CLEAR
*
*  The TTL Data Book, Vol 2, 1985, TI
*  MCG 07/09/93
*
.SUBCKT 74116 C1BAR_I C2BAR_I CLRBAR_I D1_I D2_I D3_I D4_I  Q1 Q2 Q3 Q4
+ optional: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U116_1 BUFA(7) DPWR  DGND
+ D1_I D2_I D3_I D4_I C1BAR_I C2BAR_I CLRBAR_I
+ D1   D2   D3   D4   C1BAR   C2BAR   CLRBAR
+ D0_GATE IO_STD
*
U116_2 DLTCH(4)
+ DPWR  DGND
+ $D_HI CLRBAR LAT
+ D1    D2    D3    D4
+ Q1    Q2    Q3    Q4
+ $D_NC $D_NC $D_NC $D_NC
+ D_74116 IO_STD 
*
U116_3 INVA(2)
+ DPWR  DGND
+ C1BAR C2BAR 
+ C1    C2    
+ D0_GATE IO_STD 
*
U116_4 AND(2)
+ DPWR  DGND
+ C1    C2
+ LAT
+ D0_GATE IO_STD 
*
U116CON CONSTRAINT(7) DPWR DGND
+ CLRBAR C1BAR C2BAR D1 D2 D3 D4 
+ IO_STD
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 18NS
+   MIN_HI = 18NS
+
+ WIDTH:
+   NODE = C1BAR
+   MIN_LO = 18NS
+   MIN_HI = 18NS
+
+ WIDTH:
+   NODE = C2BAR
+   MIN_LO = 18NS
+   MIN_HI = 18NS
+
+ SETUP_HOLD:
+   DATA(4) D1 D2 D3 D4
+   CLOCK LH = C1BAR
+   SETUPTIME_HI =  8NS
+   SETUPTIME_LO = 14NS
+   RELEASETIME  =  2NS
+   HOLDTIME     =  8NS
+
+ SETUP_HOLD:
+   DATA(4) D1 D2 D3 D4
+   CLOCK LH = C2BAR
+   SETUPTIME_HI =  8NS
+   SETUPTIME_LO = 14NS
+   RELEASETIME  =  2NS
+   HOLDTIME     =  8NS
+
+ SETUP_HOLD:
+   DATA(1) C1BAR 
+   CLOCK LH = CLRBAR
+   SETUPTIME    =  8NS
*
.ENDS
*
.MODEL D_74116 UGFF (
+  tpgqlhty =19ns  tpgqlhmx =30ns
+  tpgqhlty =15ns  tpgqhlmx =22ns
+  tpdqlhty =10ns  tpdqlhmx =15ns
+  tpdqhlty =12ns  tpdqhlmx =18ns
+  tppcqhlty=15ns  tppcqhlmx=22ns
+  )
*
*
*$
*-------------------------------------------------------------------------
* 74120  Dual Pulse Synchronizers/Drivers
*
* The TTL Data Book, Vol 2, 1985, TI
* atl 	 9/21/89	Update interface and model names
*
.subckt 74120  1M 1S1BAR 1S2BAR 1RBAR 1C 1Y 1YBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UBUF bufa(5) DPWR DGND
+	1M	1S1BAR	1S2BAR	1RBAR	1C
+	M	S1B	S2B	RB	C
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
UINV inv DPWR DGND
+	C   CB 
+	D0_GATE IO_STD 
USUP1 suhdck(3) DPWR DGND
+	C
+	S1B	S2B	RB
+	SU1	SU2	SU3	HD1	HD2	HD3
+	D_120_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
UX1 buf DPWR DGND
+	M   MBF 
+	D_120_2 IO_STD MNTYMXDLY={MNTYMXDLY} 
UX2 xor DPWR DGND
+	M MBF   CHK 
+	D0_GATE IO_STD 
UX3 dff(1) DPWR DGND
+	$D_HI $D_HI C   CHK   SUH1 $D_NC 
+	D_120_3 IO_STD MNTYMXDLY={MNTYMXDLY} 
UOEX or(7) DPWR DGND
+	SU1 SU2 SU3 HD1 HD2 HD3 SUH1   OEX 
+	D_120_4 IO_STD MNTYMXDLY={MNTYMXDLY} 
UCTRL nanda(3,2) DPWR DGND
+	$D_HI RB CT2 CT1 S1B S2B   CT1 CT2 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
UT nanda(3,4) DPWR DGND
+	CB	CT2	T3
+	CT2	T3	C0
+	C0	$D_HI	C
+	CT2	1M	C1
+	T0	T1	T2	T3
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
UC nanda(3,2) DPWR DGND
+	T0 T1 T2 T2 T3 $D_HI   C0 C1 
+	D_120_5 IO_STD MNTYMXDLY={MNTYMXDLY} 
*	Note:  IO_LS is used here to assure that indetermined state occurs
*	whenever set-up or hold time conditions are violated.
*
UT2X1 buf DPWR DGND
+	T2   T2X 
+	D0_GATE IO_LS 
UT2X2 buf3 DPWR DGND
+	$D_X   OEX   T2X 
+	D0_TGATE IO_LS 
UY inv DPWR DGND
+	T2X   1Y 
+	D_120_6 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UYB buf DPWR DGND
+	T2X   1YBAR 
+	D_120_7 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_120_1 usuhd (
+	tsumn=12ns	thdmn=3ns
+	)
.model D_120_2 ugate (
+	tphlmn=11.9ns
+	)
.model D_120_3 ueff (
+	thdclkmn=20ns
+	)
.model D_120_4 ugate (
+	tplhmn=0.1ns
+	)
.model D_120_5 ugate (
+	tplhmn=0.1ns	tphlmn=0.1ns
+	)
.model D_120_6 ugate (
+	tplhty=14ns	tplhmx=22ns
+	tphlty=17ns	tphlmx=25ns
+	)
.model D_120_7 ugate (
+	tplhty=10ns	tplhmx=16ns
+	tphlty=8ns	tphlmx=13ns
+	)
*$
*-------------------------------------------------------------------------
* 74125  Quadruple Bus Buffer with 3-state Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	07/05/89	Update interface and model names
*
.subckt 74125  A GBAR Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 buf3 DPWR DGND
+	A   G   Y 
+	D_125 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 inv DPWR DGND
+	GBAR   G 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_125 utgate (
+	tplhty=8ns	tplhmx=13ns
+	tphlty=12ns	tphlmx=18ns
+	tpzhty=11ns	tpzhmx=17ns
+	tpzlty=16ns	tpzlmx=25ns
+	tphzty=5ns	tphzmx=8ns
+	tplzty=7ns	tplzmx=12ns
+	)
*$
*-------------------------------------------------------------------------
* 74126  Quadruple Bus Buffer with 3-state Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	07/05/89	Update interface and model names
*
.subckt 74126  A G Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 buf3 DPWR DGND
+	A   G   Y 
+	D_126 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_126 utgate (
+	tplhty=8ns	tplhmx=13ns
+	tphlty=12ns	tphlmx=18ns
+	tpzhty=11ns	tpzhmx=18ns
+	tpzlty=16ns	tpzlmx=25ns
+	tphzty=10ns	tphzmx=16ns
+	tplzty=12ns	tplzmx=18ns
+	)
*$
*-------------------------------------------------------------------------
* 74128  Line Drivers
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	07/05/89	Update interface and model names
*
.subckt 74128  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nor(2) DPWR DGND
+	A B   Y 
+	D_128 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_128 ugate (
+	tplhty=6ns	tplhmx=9ns
+	tphlty=8ns	tphlmx=12ns
+	)
*$
*-------------------------------------------------------------------------
* 74132  Quadruple 2-input Positive-Nand Schmitt Triggers
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	07/05/89	Update interface and model names
*
.subckt 74132  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* Note: These devices are modeled as simple Nand gates.
*       Hysteresis is modeled by the AtoD interface.
*
U1 nand(2) DPWR DGND
+	A B   Y 
+	D_132 IO_STD_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_132 ugate (
+	tplhty=15ns	tplhmx=22ns
+	tphlty=15ns	tphlmx=22ns
+	)
*$
*-------------------------------------------------------------------------
* 74136  Quadruple 2-input Exclusive-Or Gates with Open-Collector Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* tdn	07/05/89	Update interface and model names
*
.subckt 74136  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(2) DPWR DGND
+	A B   A_BUF B_BUF 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U1 or(2) DPWR DGND
+	A_BUF B_BUF   C 
+	D_136_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U2 nand(2) DPWR DGND
+	A_BUF B_BUF   D 
+	D_136_2 IO_STD MNTYMXDLY={MNTYMXDLY} 
U3 and(2) DPWR DGND
+	C D   Y 
+	D_136_3 IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends 74136
*
.model D_136_1 ugate (
+	tplhty=12ns	tplhmx=18ns
+	)
.model D_136_2 ugate (
+	tplhty=14ns	tplhmx=22ns
+	tphlty=3ns	tphlmx=5ns
+	)
.model D_136_3 ugate (
+	tphlty=39ns	tphlmx=50ns
+	)
*$
*-------------------------------------------------------------------------
*
*  74141 BCD-TO-DECIMAL DECODER/DRIVER
*
*  The TTL Data Book, Vol 2, 1985, TI
*  MCG 07/09/93
*  NOTE: There is no timing data available.
*
.SUBCKT 74141 A_I B_I C_I D_I O0 O1 O2 O3 O4 O5 O6 O7 O8 O9
+ optional: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U141LOG LOGICEXP (4,10) DPWR DGND
+ A_I B_I C_I D_I
+ O0 O1 O2 O3 O4 O5 O6 O7 O8 O9
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   A      = { A_I }
+   B      = { B_I }
+   C      = { C_I }
+   D      = { D_I }
+
* OUTPUT ASSIGNMENTS
+
+   O0     = { ~D & ~C & ~B & ~A }
+   O1     = { ~D & ~C & ~B &  A }
+   O2     = { ~D & ~C &  B & ~A }
+   O3     = { ~D & ~C &  B &  A }
+   O4     = { ~D &  C & ~B & ~A }
+   O5     = { ~D &  C & ~B &  A }
+   O6     = { ~D &  C &  B & ~A }
+   O7     = { ~D &  C &  B &  A }
+   O8     = {  D & ~C & ~B & ~A }
+   O9     = {  D & ~C & ~B &  A }
*
.ENDS
*$
*-------------------------------------------------------------------------
*
*  74143 4-BIT COUNTER/LATCH, SEVEN SEGMENT LED/LAMP DRIVER
*
*  The TTL Data Book, Vol 2, 1985, TI
*  MCG 07/09/93
*
.SUBCKT 74143 
+ SCEIBAR_I PCEIBAR_I CLRBAR_I STRBBAR_I 
+ RBIBAR_I BI_I CLK_I DPI_I 
+ MAX_O QA_O QB_O QC_O QD_O RBOBAR
+ A B C D E F G DPO
+ optional: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U143_1LOG LOGICEXP(10,9) DPWR DGND
+ SCEIBAR_I PCEIBAR_I CLK_I CLRBAR_I STRBBAR_I
+ TQA TQB TQC TQD TQDBAR
+ T0 T1 T2 T3   CLRBAR STRB MAX CLK SCEIBAR
+ D0_GATE   IO_STD  IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   PCEIBAR     = { PCEIBAR_I }
+
* TWO OUTPUT ASSIGNMENTS
+
+   CLK         = { CLK_I }
+   SCEIBAR     = { SCEIBAR_I }
+
* INTERMEDIATE ASSIGNMENT
+
+   SPC         = { (~SCEIBAR) & (~PCEIBAR) & (~CLK) }
+
* OUTPUT ASSIGNMENTS
+
+   CLRBAR      = { CLRBAR_I }
+   STRB        = { ~STRBBAR_I }
+   T0          = { SPC }
+   T1          = { (TQA  & TQDBAR & SPC) }
+   T2          = { (TQB  & TQA    & SPC) }
+   T3          = { (TQA  & SPC    & (TQD | (TQC & TQB) ) ) }
+   MAX         = { ~( (~SCEIBAR) & TQA & TQD ) }
*
U143_TFF0 JKFF(1) DPWR DGND
+ $D_HI CLRBAR T0
+ $D_HI $D_HI
+ TQA   $D_NC
+ D0_EFF IO_STD
*
U143_TFF1 JKFF(1) DPWR DGND
+ $D_HI CLRBAR T1
+ $D_HI $D_HI
+ TQB   $D_NC
+ D0_EFF IO_STD
*
U143_TFF2 JKFF(1) DPWR DGND
+ $D_HI CLRBAR T2
+ $D_HI $D_HI
+ TQC   $D_NC
+ D0_EFF IO_STD
*
U143_TFF3 JKFF(1) DPWR DGND
+ $D_HI CLRBAR T3
+ $D_HI $D_HI
+ TQD   TQDBAR
+ D0_EFF IO_STD
*
U143DLATCH DLTCH(4) DPWR DGND
+ $D_HI $D_HI STRB
+ TQA   TQB   TQC   TQD
+ QA    QB    QC    QD
+ QABAR QBBAR QCBAR QDBAR
+ D0_GFF IO_STD 
*
U143_2LOG LOGICEXP(11,9) DPWR DGND
+ QA     QB    QC    QD
+ QABAR  QBBAR QCBAR QDBAR
+ RBIBAR_I BI_I    DPI_I
+ A B C D E F G DPO RBOBAR
+ D0_GATE   IO_STD IO_LEVEL={IO_LEVEL}
+     
+ LOGIC:
+   BI     = { BI_I }
+   RBIBAR = { RBIBAR_I }
+   DPI    = { DPI_I }
+
* INTERMEDIATE LOGIC
+
+   NODISPLAY = { BI | ((~RBIBAR) & QDBAR & QCBAR & QBBAR & QABAR) }
+
* OUTPUT LOGIC
+
+   a = { (~NODISPLAY & (QDBAR & QB         | QDBAR & QC & QA       | 
+                     QCBAR & QBBAR & QABAR | QD & QCBAR & QBBAR)) }
+
+   b = { (~NODISPLAY & (QDBAR & QCBAR      | QDBAR & QBBAR & QABAR | 
+                     QDBAR & QB & QA       | QD & QCBAR & QBBAR)) }
+
+   c = { (~NODISPLAY & (QDBAR & QC         | QDBAR & QA            | 
+                     QCBAR & QBBAR & QABAR | QD & QCBAR & QBBAR)) }
+
+   d = { (~NODISPLAY & (QDBAR & QB & QABAR | QDBAR & QCBAR & QB    | 
+                     QCBAR & QBBAR & QABAR | QD & QCBAR & QBBAR    | 
+                     QDBAR & QC & QBBAR & QA)) }
+
+   e = { (~NODISPLAY & (QDBAR & QB & QABAR | QCBAR & QBBAR & QABAR )) }
+
+   f = { (~NODISPLAY & (QDBAR & QC & QBBAR | QDBAR & QBBAR & QABAR | 
+                       QDBAR & QC & QABAR  | QD & QCBAR & QBBAR)) }
+
+   g = { (~NODISPLAY & (QDBAR & QB & QABAR | QDBAR & QCBAR & QB    | 
+                           QDBAR & QC & QBBAR  | QD & QCBAR & QBBAR)) }
+
+   dpo = { (~NODISPLAY & DPI) }
+
+   RBOBAR = { ~NODISPLAY }
*
U143DLY PINDLY (5,0,4) DPWR DGND
+ QA QB QC QD MAX
+ CLK SCEIBAR CLRBAR PCEIBAR
+ QA_O QB_O QC_O QD_O MAX_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CHANGED(CLK,0) & TRN_LH, DELAY(-1,28NS,45NS),
+       CHANGED(CLK,0) & TRN_HL, DELAY(-1,38NS,60NS),
+       CHANGED(CLRBAR,0) & TRN_HL, DELAY(-1,57NS,90NS),
+       DELAY(-1,57NS,90NS)
+   	)
+     }
+   MAX_O = {
+     CASE(
+       CHANGED(SCEIBAR,0) & TRN_LH, DELAY(-1,12NS,20NS),
+       CHANGED(SCEIBAR,0) & TRN_HL, DELAY(-1,23NS,35NS),
+       CHANGED(CLK,0) & TRN_LH, DELAY(-1,26NS,40NS),
+       CHANGED(CLK,0) & TRN_HL, DELAY(-1,29NS,45NS),
+       DELAY(-1,29NS,45NS)
+       )
+     }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 12MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 55NS
+   MIN_HI = 25NS
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 25NS
+   MIN_HI = 25NS
+
+ SETUP_HOLD:
+   DATA(2) PCEIBAR SCEIBAR 
+   CLOCK LH = CLK
+   SETUPTIME_HI = 30NS
+   SETUPTIME_LO = 30NS
+
+ SETUP_HOLD:
+   DATA(1)  CLRBAR
+   CLOCK LH = CLK
+   SETUPTIME_HI = 60NS
+   SETUPTIME_LO = 60NS
*
.ENDS
*$
*-------------------------------------------------------------------------
*
*  74144 4-BIT COUNTER/LATCH, SEVEN SEGMENT LED/LAMP DRIVER
*
*  The TTL Data Book, Vol 2, 1985, TI
*  MCG 07/09/93
*
.SUBCKT 74144 
+ SCEIBAR_I PCEIBAR_I CLRBAR_I STRBBAR_I 
+ RBIBAR_I BI_I CLK_I DPI_I 
+ MAX_O QA_O QB_O QC_O QD_O RBOBAR
+ A B C D E F G DPO
+ optional: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U144_1LOG LOGICEXP(10,9) DPWR DGND
+ SCEIBAR_I PCEIBAR_I CLK_I CLRBAR_I STRBBAR_I
+ TQA TQB TQC TQD TQDBAR
+ T0 T1 T2 T3   CLRBAR STRB MAX CLK SCEIBAR
+ D0_GATE   IO_STD  IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   PCEIBAR     = { PCEIBAR_I }
+
* TWO OUTPUT ASSIGNMENTS
+
+   CLK         = { CLK_I }
+   SCEIBAR     = { SCEIBAR_I }
+
* INTERMEDIATE ASSIGNMENT
+
+   SPC         = { (~SCEIBAR) & (~PCEIBAR) & (~CLK) }
+
* OUTPUT ASSIGNMENTS
+
+   CLRBAR      = { CLRBAR_I }
+   STRB        = { ~STRBBAR_I }
+   T0          = { SPC }
+   T1          = { (TQA  & TQDBAR & SPC) }
+   T2          = { (TQB  & TQA    & SPC) }
+   T3          = { (TQA  & SPC    & (TQD | (TQC & TQB) ) ) }
+   MAX         = { ~( (~SCEIBAR) & TQA & TQD ) }
*
U144_TFF0 JKFF(1) DPWR DGND
+ $D_HI CLRBAR T0
+ $D_HI $D_HI
+ TQA   $D_NC
+ D0_EFF IO_STD
*
U144_TFF1 JKFF(1) DPWR DGND
+ $D_HI CLRBAR T1
+ $D_HI $D_HI
+ TQB   $D_NC
+ D0_EFF IO_STD
*
U144_TFF2 JKFF(1) DPWR DGND
+ $D_HI CLRBAR T2
+ $D_HI $D_HI
+ TQC   $D_NC
+ D0_EFF IO_STD
*
U144_TFF3 JKFF(1) DPWR DGND
+ $D_HI CLRBAR T3
+ $D_HI $D_HI
+ TQD   TQDBAR
+ D0_EFF IO_STD
*
U144DLATCH DLTCH(4) DPWR DGND
+ $D_HI $D_HI STRB
+ TQA   TQB   TQC   TQD
+ QA    QB    QC    QD
+ QABAR QBBAR QCBAR QDBAR
+ D0_GFF IO_STD 
*
U144_2LOG LOGICEXP(11,9) DPWR DGND
+ QA     QB    QC    QD
+ QABAR  QBBAR QCBAR QDBAR
+ RBIBAR_I BI_I    DPI_I
+ A B C D E F G DPO RBOBAR
+ D0_GATE   IO_STD IO_LEVEL={IO_LEVEL}
+     
+ LOGIC:
+   BI     = { BI_I }
+   RBIBAR = { RBIBAR_I }
+   DPI    = { DPI_I }
+
* INTERMEDIATE LOGIC
+
+   NODISPLAY = { BI | ((~RBIBAR) & QDBAR & QCBAR & QBBAR & QABAR) }
+
* OUTPUT LOGIC
+
+   a = { (~NODISPLAY & (QDBAR & QB         | QDBAR & QC & QA       | 
+                     QCBAR & QBBAR & QABAR | QD & QCBAR & QBBAR)) }
+
+   b = { (~NODISPLAY & (QDBAR & QCBAR      | QDBAR & QBBAR & QABAR | 
+                     QDBAR & QB & QA       | QD & QCBAR & QBBAR)) }
+
+   c = { (~NODISPLAY & (QDBAR & QC         | QDBAR & QA            | 
+                     QCBAR & QBBAR & QABAR | QD & QCBAR & QBBAR)) }
+
+   d = { (~NODISPLAY & (QDBAR & QB & QABAR | QDBAR & QCBAR & QB    | 
+                     QCBAR & QBBAR & QABAR | QD & QCBAR & QBBAR    | 
+                     QDBAR & QC & QBBAR & QA)) }
+
+   e = { (~NODISPLAY & (QDBAR & QB & QABAR | QCBAR & QBBAR & QABAR )) }
+
+   f = { (~NODISPLAY & (QDBAR & QC & QBBAR | QDBAR & QBBAR & QABAR | 
+                       QDBAR & QC & QABAR  | QD & QCBAR & QBBAR)) }
+
+   g = { (~NODISPLAY & (QDBAR & QB & QABAR | QDBAR & QCBAR & QB    | 
+                           QDBAR & QC & QBBAR  | QD & QCBAR & QBBAR)) }
+
+   dpo = { (~NODISPLAY & DPI) }
+
+   RBOBAR = { ~NODISPLAY }
*
U144DLY PINDLY (5,0,4) DPWR DGND
+ QA QB QC QD MAX
+ CLK SCEIBAR CLRBAR PCEIBAR
+ QA_O QB_O QC_O QD_O MAX_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CHANGED(CLK,0) & TRN_LH, DELAY(-1,28NS,45NS),
+       CHANGED(CLK,0) & TRN_HL, DELAY(-1,38NS,60NS),
+       CHANGED(CLRBAR,0) & TRN_HL, DELAY(-1,57NS,90NS),
+       DELAY(-1,57NS,90NS)
+   	)
+     }
+   MAX_O = {
+     CASE(
+       CHANGED(SCEIBAR,0) & TRN_LH, DELAY(-1,12NS,20NS),
+       CHANGED(SCEIBAR,0) & TRN_HL, DELAY(-1,23NS,35NS),
+       CHANGED(CLK,0) & TRN_LH, DELAY(-1,26NS,40NS),
+       CHANGED(CLK,0) & TRN_HL, DELAY(-1,29NS,45NS),
+       DELAY(-1,29NS,45NS)
+       )
+     }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 12MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 55NS
+   MIN_HI = 25NS
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 25NS
+   MIN_HI = 25NS
+
+ SETUP_HOLD:
+   DATA(2) PCEIBAR SCEIBAR 
+   CLOCK LH = CLK
+   SETUPTIME_HI = 30NS
+   SETUPTIME_LO = 30NS
+
+ SETUP_HOLD:
+   DATA(1)  CLRBAR
+   CLOCK LH = CLK
+   SETUPTIME_HI = 60NS
+   SETUPTIME_LO = 60NS
*
.ENDS
*$
*-------------------------------------------------------------------------
* 74145  DECODER/DRIVER BCD-DECIMAL WITH OPEN COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-25-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74145   A_I B_I C_I D_I
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U145LOG LOGICEXP (4,10) DPWR DGND
+ A_I B_I C_I D_I
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   A    = { A_I }
+   B    = { B_I }
+   C    = { C_I }
+   D    = { D_I }
+   ABAR = { ~A }
+   BBAR = { ~B }
+   CBAR = { ~C }
+   DBAR = { ~D }
+   Y0   = { ~(DBAR & CBAR & BBAR & ABAR ) }
+   Y1   = { ~(DBAR & CBAR & BBAR & A    ) }
+   Y2   = { ~(DBAR & CBAR & B    & ABAR ) }
+   Y3   = { ~(DBAR & CBAR & B    & A    ) }
+   Y4   = { ~(DBAR & C    & BBAR & ABAR ) }
+   Y5   = { ~(DBAR & C    & BBAR & A    ) }
+   Y6   = { ~(DBAR & C    & B    & ABAR ) }
+   Y7   = { ~(DBAR & C    & B    & A    ) }
+   Y8   = { ~(D    & CBAR & BBAR & ABAR ) }
+   Y9   = { ~(D    & CBAR & BBAR & A    ) }
*
U145DLY PINDLY (10,0,0) DPWR DGND
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9
+
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ IO_STD_OC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O =
+     { DELAY(-1,-1,50NS) }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74147  PRIORITY ENCODER 10-4 LINE
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-31-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74147   IN1_I IN2_I IN3_I IN4_I IN5_I IN6_I IN7_I IN8_I IN9_I
+ A_O B_O C_O D_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U147LOG LOGICEXP (9,13) DPWR DGND
+ IN1_I IN2_I IN3_I IN4_I IN5_I IN6_I IN7_I IN8_I IN9_I
+ IN1   IN2   IN3   IN4   IN5   IN6   IN7   IN8   IN9
+ A B C D
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+ IN1    = { IN1_I }
+ IN2    = { IN2_I }
+ IN3    = { IN3_I }
+ IN4    = { IN4_I }
+ IN5    = { IN5_I }
+ IN6    = { IN6_I }
+ IN7    = { IN7_I }
+ IN8    = { IN8_I }
+ IN9    = { IN9_I }
+ IN1BAR = { ~IN1 }
+ IN2BAR = { ~IN2 }
+ IN3BAR = { ~IN3 }
+ IN4BAR = { ~IN4 }
+ IN5BAR = { ~IN5 }
+ IN6BAR = { ~IN6 }
+ IN7BAR = { ~IN7 }
+ IN8BAR = { ~IN8 }
+ IN9BAR = { ~IN9 }
+
+ D      = { IN8 & IN9 }
+ C      = { ~(D & (IN4BAR | IN5BAR | IN6BAR | IN7BAR)) }
+ B      = { ~(D & ((IN2BAR & IN4 & IN5) |
+             (IN3BAR & IN4 & IN5) | IN6BAR | IN7BAR)) }
+ A      = { ~(IN9BAR | D & ((IN1BAR & IN2 & IN4 & IN6) |
+             (IN3BAR & IN4 & IN6) | (IN5BAR & IN6) | IN7BAR)) }
*
U147DLY PINDLY (4,0,9) DPWR DGND
+ A B C D
+ IN1 IN2 IN3 IN4 IN5 IN6 IN7 IN8 IN9
+ A_O B_O C_O D_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   DATAHI   = { IN9=='1 & IN8=='1 & IN7=='1 & IN6=='1 & IN5=='1 &
+                IN4=='1 & IN3=='1 & IN2=='1 & IN1=='1 }
+
+ PINDLY:
+   A_O B_O C_O D_O = {
+     CASE (
+       DATAHI, DELAY(-1, 9NS,14NS),
+       TRN_HL, DELAY(-1, 7NS,11NS),
+       TRN_LH, DELAY(-1,13NS,19NS),
+       DELAY(-1,13NS,19NS)
+       )
+     }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74148  PRIORITY ENCODER 8-3 LINE
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74148   IN0_I IN1_I IN2_I IN3_I IN4_I IN5_I IN6_I IN7_I EI_I
+ A0_O A1_O A2_O GS_O EO_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U148LOG LOGICEXP (9,14) DPWR DGND
+ IN0_I IN1_I IN2_I IN3_I IN4_I IN5_I IN6_I IN7_I EI_I
+ IN0   IN1   IN2   IN3   IN4   IN5   IN6   IN7   EI
+ A0 A1 A2 GS EO
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+ IN0    = { IN0_I }
+ IN1    = { IN1_I }
+ IN2    = { IN2_I }
+ IN3    = { IN3_I }
+ IN4    = { IN4_I }
+ IN5    = { IN5_I }
+ IN6    = { IN6_I }
+ IN7    = { IN7_I }
+ EI     = { EI_I }
+ IN0BAR = { ~IN0 }
+ IN1BAR = { ~IN1 }
+ IN2BAR = { ~IN2 }
+ IN3BAR = { ~IN3 }
+ IN4BAR = { ~IN4 }
+ IN5BAR = { ~IN5 }
+ IN6BAR = { ~IN6 }
+ IN7BAR = { ~IN7 }
+ EIBAR  = { ~EI }
+
+ A0     = { ~(EIBAR & ((IN1BAR & IN2 & IN4 & IN6) |
+                       (IN3BAR & IN4 & IN6) | (IN5BAR & IN6) | IN7BAR)) }
+ A1     = { ~(EIBAR & ((IN2BAR & IN4 & IN5) |
+                       (IN3BAR & IN4 & IN5) | IN6BAR | IN7BAR)) }
+ A2     = { ~(EIBAR & (IN4BAR | IN5BAR | IN6BAR | IN7BAR)) }
+ EO     = { ~(IN0 & IN1 & IN2 & IN3 & IN4 & IN5 & IN6 & IN7 & EIBAR) }
+ GS     = { ~(EO & EIBAR) }
*
U148DLY PINDLY (5,0,9) DPWR DGND
+ A0 A1 A2 GS EO
+ IN0 IN1 IN2 IN3 IN4 IN5 IN6 IN7 EI
+ A0_O A1_O A2_O GS_O EO_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   DATAHI   = { IN7=='1 & IN6=='1 & IN5=='1 & IN4=='1 &
+                IN3=='1 & IN2=='1 & IN1=='1 & IN0=='1 }
+   ENABLE   = { CHANGED(EI,0) }
+
+ PINDLY:
+   A2_O A1_O A0_O= {
+     CASE (
+       ENABLE, DELAY(-1,10NS,15NS),
+       DATAHI, DELAY(-1,10NS,15NS),
+       TRN_HL, DELAY(-1, 9NS,14NS),
+       TRN_LH, DELAY(-1,13NS,19NS),
+       DELAY(-1,13NS,19NS)
+       )
+     }
+   GS_O = {
+     CASE (
+       ENABLE   & TRN_LH, DELAY(-1, 8NS,12NS),
+       ENABLE   & TRN_HL, DELAY(-1,10NS,15NS),
+                  TRN_LH, DELAY(-1,18NS,30NS),
+                  TRN_HL, DELAY(-1,14NS,25NS),
+       DELAY(-1,18NS,30NS)
+       )
+     }
+   EO_O = {
+     CASE (
+       ENABLE   & TRN_LH, DELAY(-1,10NS,15NS),
+       ENABLE   & TRN_HL, DELAY(-1,17NS,30NS),
+                  TRN_LH, DELAY(-1, 6NS,10NS),
+                  TRN_HL, DELAY(-1,14NS,25NS),
+       DELAY(-1,17NS,30NS)
+       )
+     }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74150  MULTIPLEXER/DATA SELECTOR 16-1 LINE
*
* THE TTL DATA BOOK, 1988, TI
* TC  08/20/92  REMODELED USING LOGICEXP, PINDLY, & CONSTRAINT DEVICES
*
.SUBCKT 74150 GBAR_I A_I B_I C_I D_I E0_I E1_I E2_I E3_I E4_I E5_I E6_I
+ E7_I E8_I E9_I E10_I E11_I E12_I E13_I E14_I E15_I W_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U150LOG LOGICEXP(21,22) DPWR DGND
+ GBAR_I A_I B_I C_I D_I E0_I E1_I E2_I E3_I E4_I E5_I E6_I E7_I E8_I E9_I
+ E10_I E11_I E12_I E13_I E14_I E15_I
+ GBAR A B C D E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 E10 E11 E12 E13 E14 E15 W
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   GBAR = { GBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   E0 = { E0_I }
+   E1 = { E1_I }
+   E2 = { E2_I }
+   E3 = { E3_I }
+   E4 = { E4_I }
+   E5 = { E5_I }
+   E6 = { E6_I }
+   E7 = { E7_I }
+   E8 = { E8_I }
+   E9 = { E9_I }
+   E10 = { E10_I }
+   E11 = { E11_I }
+   E12 = { E12_I }
+   E13 = { E13_I }
+   E14 = { E14_I }
+   E15 = { E15_I }
+   IA = { ~A }
+   IB = { ~B }
+   IC = { ~C }
+   ID = { ~D }
+   IG = { ~GBAR }
+   IE0 = { E0 & IA & IB & IC & ID & IG }
+   IE1 = { E1 & A & IB & IC & ID & IG }
+   IE2 = { E2 & IA & B & IC & ID & IG }
+   IE3 = { E3 & A & B & IC & ID & IG }
+   IE4 = { E4 & IA & IB & C & ID & IG }
+   IE5 = { E5 & A & IB & C & ID & IG }
+   IE6 = { E6 & IA & B & C & ID & IG }
+   IE7 = { E7 & A & B & C & ID & IG }
+   IE8 = { E8 & IA & IB & IC & D & IG }
+   IE9 = { E9 & A & IB & IC & D & IG }
+   IE10 = { E10 & IA & B & IC & D & IG }
+   IE11 = { E11 & A & B & IC & D & IG }
+   IE12 = { E12 & IA & IB & C & D & IG }
+   IE13 = { E13 & A & IB & C & D & IG }
+   IE14 = { E14 & IA & B & C & D & IG }
+   IE15 = { E15 & A & B & C & D & IG }
+   W = { ~(IE0 | IE1 | IE2 | IE3 | IE4 | IE5 | IE6 | IE7 | IE8 |
+     IE9 | IE10 | IE11 | IE12 | IE13 | IE14 | IE15) }
*
U150DLY PINDLY (1,0,21) DPWR DGND
+ W
+ GBAR A B C D E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 E10 E11 E12 E13 E14 E15
+ W_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   DATA = { CHANGED(E0,0) | CHANGED(E1,0) | CHANGED(E2,0) | CHANGED(E3,0) |
+     CHANGED(E4,0) | CHANGED(E5,0) | CHANGED(E6,0) | CHANGED(E7,0) |
+     CHANGED(E8,0) | CHANGED(E9,0) | CHANGED(E10,0) | CHANGED(E11,0) |
+     CHANGED(E12,0) | CHANGED(E13,0) | CHANGED(E14,0) | CHANGED(E15,0) }
+   SELECT = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+ PINDLY:
+   W_O = {
+     CASE(
+       SELECT & TRN_LH, DELAY(-1,23NS,35NS),
+       SELECT & TRN_HL, DELAY(-1,22NS,33NS),
+       CHANGED(GBAR,0) & TRN_HL, DELAY(-1,21NS,30NS),
+       CHANGED(GBAR,0) & TRN_LH, DELAY(-1,15.5NS,24NS),
+       DATA & TRN_HL, DELAY(-1,13NS,20NS),
+       DATA & TRN_LH, DELAY(-1,8.5NS,14NS),
+       DELAY(-1,24NS,36NS)
+       )
+     }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74151A  MULTIPLEXER/DATA SELECTOR 8-1 LINE
*
* THE TTL DATA BOOK, 1988, TI
* TC  08/20/92  REMODELED USING LOGICEXP, PINDLY, & CONSTRAINT DEVICES
*
.SUBCKT 74151A GBAR_I A_I B_I C_I D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I
+ Y_O W_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U151ALOG LOGICEXP(12,14) DPWR DGND
+ GBAR_I A_I B_I C_I D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I
+ GBAR A B C D0 D1 D2 D3 D4 D5 D6 D7 W Y
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   GBAR = { GBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D0 = { D0_I }
+   D1 = { D1_I }
+   D2 = { D2_I }
+   D3 = { D3_I }
+   D4 = { D4_I }
+   D5 = { D5_I }
+   D6 = { D6_I }
+   D7 = { D7_I }
+   IA = { ~A }
+   IB = { ~B }
+   IC = { ~C }
+   IG = { ~GBAR }
+   ID0 = { D0 & IA & IB & IC & IG }
+   ID1 = { D1 & A & IB & IC & IG }
+   ID2 = { D2 & IA & B & IC & IG }
+   ID3 = { D3 & A & B & IC & IG }
+   ID4 = { D4 & IA & IB & C & IG }
+   ID5 = { D5 & A & IB & C & IG }
+   ID6 = { D6 & IA & B & C & IG }
+   ID7 = { D7 & A & B & C & IG }
+   W = { ~(ID0 | ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7) }
+   Y = { ~W }
*
U151ADLY PINDLY (2,0,12) DPWR DGND
+ W Y
+ GBAR A B C D0 D1 D2 D3 D4 D5 D6 D7
+ W_O Y_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   DATA = { CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) |
+     CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0) }
+   SELECT = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+   ENABLE = { CHANGED(GBAR,0) }
+ PINDLY:
+   Y_O = {
+     CASE(
+       SELECT, DELAY(-1,25NS,38NS),
+       ENABLE & TRN_LH, DELAY(-1,21NS,33NS),
+       ENABLE & TRN_HL, DELAY(-1,22NS,33NS),
+       DATA & TRN_LH, DELAY(-1,13NS,20NS),
+       DATA & TRN_HL, DELAY(-1,18NS,27NS),
+       DELAY(-1,26NS,39NS)
+       )
+     }
+   W_O = {
+     CASE(
+       SELECT & TRN_HL, DELAY(-1,19NS,30NS),
+       SELECT & TRN_LH, DELAY(-1,17NS,26NS),
+       ENABLE & TRN_HL, DELAY(-1,15NS,23NS),
+       ENABLE & TRN_LH, DELAY(-1,14NS,21NS),
+       DATA, DELAY(-1,8NS,14NS),
+       DELAY(-1,20NS,31NS)
+       )
+     }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 54152A  MULTIPLEXER/DATA SELECTOR 8-1 LINE
*
* THE TTL DATA BOOK, VOL 2, STANDARD, S, LS, TTL,1985, TI
* TC  08/24/92  REMODELED USING LOGICEXP, PINDLY, & CONSTRAINT DEVICES
*
.SUBCKT 54152A A_I B_I C_I D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I W_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U152ALOG LOGICEXP(11,12) DPWR DGND
+ A_I B_I C_I D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I
+ A B C D0 D1 D2 D3 D4 D5 D6 D7 W
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D0 = { D0_I }
+   D1 = { D1_I }
+   D2 = { D2_I }
+   D3 = { D3_I }
+   D4 = { D4_I }
+   D5 = { D5_I }
+   D6 = { D6_I }
+   D7 = { D7_I }
+   IA = { ~A }
+   IB = { ~B }
+   IC = { ~C }
+   ID0 = { D0 & IA & IB & IC }
+   ID1 = { D1 & A & IB & IC }
+   ID2 = { D2 & IA & B & IC }
+   ID3 = { D3 & A & B & IC }
+   ID4 = { D4 & IA & IB & C }
+   ID5 = { D5 & A & IB & C }
+   ID6 = { D6 & IA & B & C }
+   ID7 = { D7 & A & B & C }
+   W = { ~(ID0 | ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7) }
*
U152ADLY PINDLY (1,0,11) DPWR DGND
+ W
+ A B C D0 D1 D2 D3 D4 D5 D6 D7
+ W_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   DATA = { CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) |
+     CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0) }
+   SELECT = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+ PINDLY:
+   W_O = {
+     CASE(
+       SELECT & TRN_HL, DELAY(-1,19NS,30NS),
+       SELECT & TRN_LH, DELAY(-1,17NS,26NS),
+       DATA, DELAY(-1,8NS,14NS),
+       DELAY(-1,20NS,31NS)
+       )
+     }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74153  DUAL 4-LINE TO 1-LINE DATA SELECTORS/MULTIPLEXERS
*
* The TTL Data Book, 1988, TI
* JSW   8/12/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices
*
.SUBCKT 74153 G1BAR_I G2BAR_I A_I B_I 1C0_I 1C1_I 1C2_I 1C3_I
+ 2C0_I 2C1_I 2C2_I 2C3_I Y1_O Y2_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U153LOG LOGICEXP(12,14) DPWR DGND
+ G1BAR_I G2BAR_I A_I B_I 1C0_I 1C1_I 1C2_I 1C3_I 2C0_I 2C1_I 2C2_I 2C3_I
+ G1BAR G2BAR A B 1C0 1C1 1C2  1C3 2C0 2C1 2C2 2C3 Y1 Y2
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   G1BAR = { G1BAR_I }
+   G2BAR = { G2BAR_I }
+   A = { A_I }
+   B = { B_I }
+   1C0 = { 1C0_I }
+   1C1 = { 1C1_I }
+   1C2 = { 1C2_I }
+   1C3 = { 1C3_I }
+   2C0 = { 2C0_I }
+   2C1 = { 2C1_I }
+   2C2 = { 2C2_I }
+   2C3 = { 2C3_I }
+   G1 = { ~G1BAR }
+   G2 = { ~G2BAR }
+   ABAR = { ~A }
+   BBAR = { ~B }
+   I0 = { G1 & BBAR & ABAR & 1C0 }
+   I1 = { G1 & BBAR & A    & 1C1 }
+   I2 = { G1 & B    & ABAR & 1C2 }
+   I3 = { G1 & B    & A    & 1C3 }
+   I4 = { G2 & BBAR & ABAR & 2C0 }
+   I5 = { G2 & BBAR & A    & 2C1 }
+   I6 = { G2 & B    & ABAR & 2C2 }
+   I7 = { G2 & B    & A    & 2C3 }
+   Y1 = { I0 | I1 | I2 | I3 }
+   Y2 = { I4 | I5 | I6 | I7 }
*
U153DLY PINDLY (2,0,12) DPWR DGND
+ Y1 Y2
+ G1BAR G2BAR A B 1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3
+ Y1_O Y2_O
+ IO_STD
+ MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+ BOOLEAN:
+   DATA1 = { (CHANGED(1C0,0) | CHANGED(1C1,0) | CHANGED(1C2,0) |
+     CHANGED(1C3,0)) }
+   DATA2 = { (CHANGED(2C0,0) | CHANGED(2C1,0) | CHANGED(2C2,0) |
+     CHANGED(2C3,0)) }
+   SELECT = { CHANGED(A,0) | CHANGED(B,0) }
+ PINDLY:
+   Y1_O = {
+     CASE(
+       SELECT, DELAY(-1,22NS,34NS),
+       CHANGED(G1BAR,0) & TRN_LH, DELAY(-1,19NS,30NS),
+       CHANGED(G1BAR,0) & TRN_HL, DELAY(-1,15NS,23NS),
+       DATA1 & TRN_HL, DELAY(-1,15NS,23NS),
+       DATA1 & TRN_LH, DELAY(-1,12NS,18NS),
+       DELAY(-1,23NS,35NS)
+       )
+     }
+   Y2_O = {
+     CASE(
+       SELECT, DELAY(-1,22NS,34NS),
+       CHANGED(G2BAR,0) & TRN_LH, DELAY(-1,19NS,30NS),
+       CHANGED(G2BAR,0) & TRN_HL, DELAY(-1,15NS,23NS),
+       DATA2 & TRN_HL, DELAY(-1,15NS,23NS),
+       DATA2 & TRN_LH, DELAY(-1,12NS,18NS),
+       DELAY(-1,23NS,35NS)
+       )
+     }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74154  DECODER/DEMULTIPLEXER 4-16 LINE
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, 1988, TI
* JLS   8-6-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*    
.SUBCKT 74154   G1BAR_I G2BAR_I A_I B_I C_I D_I
+ Y0_O Y1_O  Y2_O  Y3_O  Y4_O  Y5_O  Y6_O  Y7_O
+ Y8_O Y9_O Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U154LOG LOGICEXP (6,21) DPWR DGND
+ G1BAR_I G2BAR_I A_I B_I C_I D_I
+ ENABLE          A   B   C   D
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   G1BAR  = { G1BAR_I }
+   G2BAR  = { G2BAR_I }
+   ENABLE = { ~(G1BAR | G2BAR) }
+   A      = { A_I }
+   B      = { B_I }
+   C      = { C_I }
+   D      = { D_I }
+   ABAR   = { ~A }
+   BBAR   = { ~B }
+   CBAR   = { ~C }
+   DBAR   = { ~D }
+   Y0     = { ~(ENABLE & DBAR & CBAR & BBAR & ABAR) }
+   Y1     = { ~(ENABLE & DBAR & CBAR & BBAR & A   ) }
+   Y2     = { ~(ENABLE & DBAR & CBAR & B    & ABAR) }
+   Y3     = { ~(ENABLE & DBAR & CBAR & B    & A   ) }
+   Y4     = { ~(ENABLE & DBAR & C    & BBAR & ABAR) }
+   Y5     = { ~(ENABLE & DBAR & C    & BBAR & A   ) }
+   Y6     = { ~(ENABLE & DBAR & C    & B    & ABAR) }
+   Y7     = { ~(ENABLE & DBAR & C    & B    & A   ) }
+   Y8     = { ~(ENABLE & D    & CBAR & BBAR & ABAR) }
+   Y9     = { ~(ENABLE & D    & CBAR & BBAR & A   ) }
+   Y10    = { ~(ENABLE & D    & CBAR & B    & ABAR) }
+   Y11    = { ~(ENABLE & D    & CBAR & B    & A   ) }
+   Y12    = { ~(ENABLE & D    & C    & BBAR & ABAR) }
+   Y13    = { ~(ENABLE & D    & C    & BBAR & A   ) }
+   Y14    = { ~(ENABLE & D    & C    & B    & ABAR) }
+   Y15    = { ~(ENABLE & D    & C    & B    & A   ) }
*
U154DLY PINDLY (16,0,5) DPWR DGND
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15
+ ENABLE A B C D
+ Y0_O Y1_O  Y2_O  Y3_O  Y4_O  Y5_O  Y6_O  Y7_O
+ Y8_O Y9_O Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ABLE = { CHANGED(ENABLE,0) }
+   ADDR = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+ PINDLY:
+   Y0_O Y1_O  Y2_O  Y3_O  Y4_O  Y5_O  Y6_O  Y7_O
+   Y8_O Y9_O Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O = {
+     CASE (
+       ABLE & TRN_HL, DELAY(-1,18NS,27NS),
+       ABLE & TRN_LH, DELAY(-1,20NS,30NS),
+       ADDR & TRN_HL, DELAY(-1,22NS,33NS),
+       ADDR & TRN_LH, DELAY(-1,24NS,36NS),
+       DELAY(-1,24NS,36NS)
+       )
+     }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74155  DECODER/DEMULTIPLEXER 2-4 LINE
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   7-29-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*    
.SUBCKT 74155   G1BAR_I G2BAR_I A_I B_I C1_I C2BAR_I
+ 1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U155LOG LOGICEXP (6,14) DPWR DGND
+ G1BAR_I G2BAR_I A_I B_I C1_I C2BAR_I
+ G1BAR           A   B   C1         ENABLE1 ENABLE2
+ 1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   G1BAR   = { G1BAR_I }
+   G2BAR   = { G2BAR_I }
+   A       = { A_I }
+   B       = { B_I }
+   C1      = { C1_I }
+   C2BAR   = { C2BAR_I }
+   ABAR    = { ~A }
+   BBAR    = { ~B }
+   ENABLE1 = { ~G1BAR &  C1 }
+   ENABLE2 = { ~G2BAR & ~C2BAR }
+
+   1Y0     = { ~(ENABLE1 & BBAR & ABAR) }
+   1Y1     = { ~(ENABLE1 & BBAR & A   ) }
+   1Y2     = { ~(ENABLE1 & B    & ABAR) }
+   1Y3     = { ~(ENABLE1 & B    & A   ) }
+
+   2Y0     = { ~(ENABLE2 & BBAR & ABAR) }
+   2Y1     = { ~(ENABLE2 & BBAR & A   ) }
+   2Y2     = { ~(ENABLE2 & B    & ABAR) }
+   2Y3     = { ~(ENABLE2 & B    & A   ) }
*
U155DLY PINDLY (8,0,6) DPWR DGND
+ 1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+ G1BAR A B C1 ENABLE1 ENABLE2
+ 1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ABLE   = { (CHANGED(G1BAR,0) & CHANGED(ENABLE1,0)) 
+             | CHANGED(ENABLE2,0) }
+   ADDR   = { CHANGED(A,0) | CHANGED(B,0) }
+   ADDRA  = { CHANGED(A,0) }
+   ADDRB  = { CHANGED(B,0) }
+   ADDRC1 = { CHANGED(C1,0) & CHANGED(ENABLE1,0) }
+
+ PINDLY:
+   1Y0_O 2Y0_O = {
+     CASE (
+       ABLE   & TRN_LH, DELAY(-1,13NS,20NS),
+       ABLE   & TRN_HL, DELAY(-1,18NS,27NS),
+       ADDR   & TRN_LH, DELAY(-1,13NS,20NS),
+       ADDR   & TRN_HL, DELAY(-1,18NS,27NS),
+       ADDRC1 & TRN_LH, DELAY(-1,16NS,24NS),
+       ADDRC1 & TRN_HL, DELAY(-1,20NS,30NS),
+       DELAY(-1,20NS,30NS)
+       )
+     }
+   1Y1_O 2Y1_O = {
+     CASE (
+       ABLE   & TRN_LH, DELAY(-1,13NS,20NS),
+       ABLE   & TRN_HL, DELAY(-1,18NS,27NS),
+       ADDRC1 & TRN_LH, DELAY(-1,16NS,24NS),
+       ADDRC1 & TRN_HL, DELAY(-1,20NS,30NS),
+       ADDRA          , DELAY(-1,21NS,32NS),
+       ADDRB  & TRN_LH, DELAY(-1,13NS,20NS),
+       ADDRB  & TRN_HL, DELAY(-1,18NS,27NS),
+       DELAY(-1,21NS,32NS)
+       )
+     }
+   1Y2_O 2Y2_O = {
+     CASE (
+       ABLE   & TRN_LH, DELAY(-1,13NS,20NS),
+       ABLE   & TRN_HL, DELAY(-1,18NS,27NS),
+       ADDRC1 & TRN_LH, DELAY(-1,16NS,24NS),
+       ADDRC1 & TRN_HL, DELAY(-1,20NS,30NS),
+       ADDRB          , DELAY(-1,21NS,32NS),
+       ADDRA  & TRN_LH, DELAY(-1,13NS,20NS),
+       ADDRA  & TRN_HL, DELAY(-1,18NS,27NS),
+       DELAY(-1,21NS,32NS)
+       )
+     }
+   1Y3_O 2Y3_O = {
+     CASE (
+       ABLE   & TRN_LH, DELAY(-1,13NS,20NS),
+       ABLE   & TRN_HL, DELAY(-1,18NS,27NS),
+       ADDRC1 & TRN_LH, DELAY(-1,16NS,24NS),
+       ADDRC1 & TRN_HL, DELAY(-1,20NS,30NS),
+       ADDR           , DELAY(-1,21NS,32NS),
+       DELAY(-1,21NS,32NS)
+       )
+     }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74156  DECODER/DEMULTIPLEXER 2-4 LINE WITH OPEN COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   7-30-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74156   G1BAR_I G2BAR_I A_I B_I C1_I C2BAR_I
+ 1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U156LOG LOGICEXP (6,14) DPWR DGND
+ G1BAR_I G2BAR_I A_I B_I C1_I C2BAR_I
+ G1BAR           A   B   C1           ENABLE1 ENABLE2
+ 1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   G1BAR   = { G1BAR_I }
+   G2BAR   = { G2BAR_I }
+   A       = { A_I }
+   B       = { B_I }
+   C1      = { C1_I }
+   C2BAR   = { C2BAR_I }
+   ABAR    = { ~A }
+   BBAR    = { ~B }
+   ENABLE1 = { ~G1BAR &  C1 }
+   ENABLE2 = { ~G2BAR & ~C2BAR }
+
+   1Y0     = { ~(ENABLE1 & BBAR & ABAR) }
+   1Y1     = { ~(ENABLE1 & BBAR & A   ) }
+   1Y2     = { ~(ENABLE1 & B    & ABAR) }
+   1Y3     = { ~(ENABLE1 & B    & A   ) }
+
+   2Y0     = { ~(ENABLE2 & BBAR & ABAR) }
+   2Y1     = { ~(ENABLE2 & BBAR & A   ) }
+   2Y2     = { ~(ENABLE2 & B    & ABAR) }
+   2Y3     = { ~(ENABLE2 & B    & A   ) }
*
U156DLY PINDLY (8,0,6) DPWR DGND
+ 1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+ G1BAR A B C1 ENABLE1 ENABLE2
+ 1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+ IO_STD_OC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ABLE   = { (CHANGED(G1BAR,0) & CHANGED(ENABLE1,0))
+             | CHANGED(ENABLE2,0) }
+   ADDR   = { CHANGED(A,0) | CHANGED(B,0) }
+   ADDRA  = { CHANGED(A,0) }
+   ADDRB  = { CHANGED(B,0) }
+   ADDRC1 = { CHANGED(C1,0) & CHANGED(ENABLE1,0) }
+
+ PINDLY:
+   1Y0_O 2Y0_O = {
+     CASE (
+       ABLE   & TRN_LH, DELAY(-1,15NS,23NS),
+       ABLE   & TRN_HL, DELAY(-1,20NS,30NS),
+       ADDR   & TRN_LH, DELAY(-1,15NS,23NS),
+       ADDR   & TRN_HL, DELAY(-1,20NS,30NS),
+       ADDRC1 & TRN_LH, DELAY(-1,18NS,27NS),
+       ADDRC1 & TRN_HL, DELAY(-1,22NS,33NS),
+       DELAY(-1,22NS,33NS)
+       )
+     }
+   1Y1_O 2Y1_O = {
+     CASE (
+       ABLE   & TRN_LH, DELAY(-1,15NS,23NS),
+       ABLE   & TRN_HL, DELAY(-1,20NS,30NS),
+       ADDRC1 & TRN_LH, DELAY(-1,18NS,27NS),
+       ADDRC1 & TRN_HL, DELAY(-1,22NS,33NS),
+       ADDRA          , DELAY(-1,23NS,34NS),
+       ADDRB  & TRN_LH, DELAY(-1,15NS,23NS),
+       ADDRB  & TRN_HL, DELAY(-1,20NS,30NS),
+       DELAY(-1,23NS,34NS)
+       )
+     }
+   1Y2_O 2Y2_O = {
+     CASE (
+       ABLE   & TRN_LH, DELAY(-1,15NS,23NS),
+       ABLE   & TRN_HL, DELAY(-1,20NS,30NS),
+       ADDRC1 & TRN_LH, DELAY(-1,18NS,27NS),
+       ADDRC1 & TRN_HL, DELAY(-1,22NS,33NS),
+       ADDRB          , DELAY(-1,23NS,34NS),
+       ADDRA  & TRN_LH, DELAY(-1,15NS,23NS),
+       ADDRA  & TRN_HL, DELAY(-1,20NS,30NS),
+       DELAY(-1,23NS,34NS)
+       )
+     }
+   1Y3_O 2Y3_O = {
+     CASE (
+       ABLE   & TRN_LH, DELAY(-1,15NS,23NS),
+       ABLE   & TRN_HL, DELAY(-1,20NS,30NS),
+       ADDRC1 & TRN_LH, DELAY(-1,18NS,27NS),
+       ADDRC1 & TRN_HL, DELAY(-1,22NS,33NS),
+       ADDR           , DELAY(-1,23NS,34NS),
+       DELAY(-1,23NS,34NS)
+       )
+     }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74157  QUADRUPLE 2-LINE TO 1-LINE DATA SELECTORS/MULTIPLEXERS
*
* The TTL Data Book, 1988, TI
* JSW   8/25/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices
*
.SUBCKT 74157 GBAR_I 1A_I 1B_I 2A_I 2B_I 3A_I 3B_I 4A_I 4B_I SEL_I
+ Y1_O Y2_O Y3_O Y4_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U157LOG LOGICEXP(10,14) DPWR DGND
+ GBAR_I 1A_I 1B_I 2A_I 2B_I 3A_I 3B_I 4A_I 4B_I SEL_I
+ GBAR 1A 1B 2A 2B 3A 3B 4A 4B SEL Y1 Y2 Y3 Y4
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   GBAR = { GBAR_I }
+   1A = { 1A_I }
+   1B = { 1B_I }
+   2A = { 2A_I }
+   2B = { 2B_I }
+   3A = { 3A_I }
+   3B = { 3B_I }
+   4A = { 4A_I }
+   4B = { 4B_I }
+   SEL = { SEL_I }
+   SELBAR = { ~SEL }
+   G = { ~GBAR }
+   Y1 = { (1A & SELBAR & G) | (1B & SEL & G) }
+   Y2 = { (2A & SELBAR & G) | (2B & SEL & G) }
+   Y3 = { (3A & SELBAR & G) | (3B & SEL & G) }
+   Y4 = { (4A & SELBAR & G) | (4B & SEL & G) }
*
U157DLY PINDLY (4,0,10) DPWR DGND
+ Y1 Y2 Y3 Y4
+ GBAR 1A 1B 2A 2B 3A 3B 4A 4B SEL
+ Y1_O Y2_O Y3_O Y4_O
+ IO_STD
+ MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+ BOOLEAN:
+   DATA = { CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(2A,0) | CHANGED(2B,0) |
+     CHANGED(3A,0) | CHANGED(3B,0) | CHANGED(4A,0) | CHANGED(4B,0) }
+   SELECT = { CHANGED(SEL,0) }
+   ENABLE = { CHANGED(GBAR,0) }
+ PINDLY:
+   Y1_O Y2_O Y3_O Y4_O = {
+     CASE(
+       SELECT & TRN_HL, DELAY(-1,18NS,27NS),
+       SELECT & TRN_LH, DELAY(-1,15NS,23NS),
+       ENABLE & TRN_HL, DELAY(-1,14NS,21NS),
+       ENABLE & TRN_LH, DELAY(-1,13NS,20NS),
+       DATA, DELAY(-1,9NS,14NS),
+       DELAY(-1,19NS,28NS)
+       )
+     }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74159  DECODER/DEMULTIPLEXER 4-16 LINE WITH OPEN COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-24-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74159   G1BAR_I G2BAR_I A_I B_I C_I D_I
+ Y0_O Y1_O  Y2_O  Y3_O  Y4_O  Y5_O  Y6_O  Y7_O
+ Y8_O Y9_O Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U159LOG LOGICEXP (6,21) DPWR DGND
+ G1BAR_I G2BAR_I A_I B_I C_I D_I
+ ENABLE          A   B   C   D
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   G1BAR  = { G1BAR_I }
+   G2BAR  = { G2BAR_I }
+   A      = { A_I }
+   B      = { B_I }
+   C      = { C_I }
+   D      = { D_I }
+
+   ENABLE = { ~(G1BAR | G2BAR) }
+   ABAR   = { ~A }
+   BBAR   = { ~B }
+   CBAR   = { ~C }
+   DBAR   = { ~D }
+   Y0     = { ~(ENABLE & DBAR & CBAR & BBAR & ABAR) }
+   Y1     = { ~(ENABLE & DBAR & CBAR & BBAR & A   ) }
+   Y2     = { ~(ENABLE & DBAR & CBAR & B    & ABAR) }
+   Y3     = { ~(ENABLE & DBAR & CBAR & B    & A   ) }
+   Y4     = { ~(ENABLE & DBAR & C    & BBAR & ABAR) }
+   Y5     = { ~(ENABLE & DBAR & C    & BBAR & A   ) }
+   Y6     = { ~(ENABLE & DBAR & C    & B    & ABAR) }
+   Y7     = { ~(ENABLE & DBAR & C    & B    & A   ) }
+   Y8     = { ~(ENABLE & D    & CBAR & BBAR & ABAR) }
+   Y9     = { ~(ENABLE & D    & CBAR & BBAR & A   ) }
+   Y10    = { ~(ENABLE & D    & CBAR & B    & ABAR) }
+   Y11    = { ~(ENABLE & D    & CBAR & B    & A   ) }
+   Y12    = { ~(ENABLE & D    & C    & BBAR & ABAR) }
+   Y13    = { ~(ENABLE & D    & C    & BBAR & A   ) }
+   Y14    = { ~(ENABLE & D    & C    & B    & ABAR) }
+   Y15    = { ~(ENABLE & D    & C    & B    & A   ) }
*
U159DLY PINDLY (16,0,5) DPWR DGND
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15
+ ENABLE A B C D
+ Y0_O Y1_O  Y2_O  Y3_O  Y4_O  Y5_O  Y6_O  Y7_O
+ Y8_O Y9_O Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O
+ IO_STD_OC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ABLE = { CHANGED(ENABLE,0) }
+   ADDR = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+ PINDLY:
+   Y0_O Y1_O  Y2_O  Y3_O  Y4_O  Y5_O  Y6_O  Y7_O
+   Y8_O Y9_O Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O = {
+     CASE (
+       ABLE & TRN_LH, DELAY(-1,15NS,25NS),
+       ABLE & TRN_HL, DELAY(-1,22NS,36NS),
+       ADDR & TRN_LH, DELAY(-1,23NS,36NS),
+       ADDR & TRN_HL, DELAY(-1,24NS,36NS),
+       DELAY(-1,24NS,36NS)
+       )
+     }
*
.ENDS
*$
*-------------------------------------------------------------------------
* 74160  Synchronous 4-bit Decade Counters with asynchronous clear 
*
* The TTL Data Book, 1986, TI
* JSW   7/1/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
*
.SUBCKT 74160 CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O RCO_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U160LOG LOGICEXP(14,20) DPWR DGND
+ CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I QDBAR QA QB QC QD
+ CLK ENP ENT CLRBAR LOADBAR A B C D 
+ CLKBAR RCO JA JB JC JD KA KB KC KD EN
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLK = { CLK_I }                     ;Buffering
+   ENP = { ENP_I }
+   ENT = { ENT_I }
+   CLRBAR = { CLRBAR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }         
+   CLKBAR = { ~CLK }                ;Logic expressions
+   LOAD = { ~LOADBAR }
+   EN = { ENP & ENT }
+   I1A = { LOAD | EN }
+   I2A = { ~(LOAD & A) }
+   JA = { I1A & ~(LOAD & I2A) }
+   KA = { I1A & I2A }
+   I1B = { (QA & EN & QDBAR) | LOAD }
+   I2B = { ~(LOAD & B) }
+   JB = { I1B & ~(LOAD & I2B) }
+   KB = { I1B & I2B }
+   I1C = { (QA & EN & QB) | LOAD }
+   I2C = { ~(LOAD & C) }
+   JC = { I1C & ~(LOAD & I2C) }
+   KC = { I1C & I2C }
+   I1D = { ((QC & QB & QA & EN) | (EN & QA & QD)) | LOAD }
+   I2D = { ~(LOAD & D) }
+   JD = { I1D & ~(LOAD & I2D) }
+   KD = { I1D & I2D }
+   RCO = { QD & QA & ENT }
*
UJKFF JKFF(4) DPWR DGND $D_HI CLRBAR CLKBAR JA JB JC JD KA KB KC KD
+ QA QB QC QD QABAR QBBAR QCBAR QDBAR D0_EFF IO_STD
*
U160DLY PINDLY (5,0,10) DPWR DGND
+ RCO QA QB QC QD
+ CLK LOADBAR ENT CLRBAR ENP A B C D EN
+ RCO_O QA_O QB_O QC_O QD_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = { CHANGED_LH(CLK,0) }
+   CNTENT = { CHANGED(ENT,0) }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CLOCK & LOADBAR=='1 & TRN_LH, DELAY(-1,13NS,20NS),
+       CLOCK & LOADBAR=='1 & TRN_HL, DELAY(-1,15NS,23NS),
+       CLOCK & LOADBAR=='0 & TRN_LH, DELAY(-1,17NS,25NS),
+       CLOCK & LOADBAR=='0 & TRN_HL, DELAY(-1,19NS,29NS),
+       CHANGED_HL(CLRBAR,0), DELAY(-1,26NS,38NS),
+       DELAY(-1,26NS,38NS)
+   	)
+     }
+   RCO_O = {
+     CASE(
+       CNTENT, DELAY(-1,11NS,16NS),
+       CLOCK, DELAY(-1,23NS,35NS),
+       DELAY(-1,23NS,35NS)
+       )
+     }
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 25NS
+   MIN_HI = 25NS
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { (LOADBAR!='1 ^ CHANGED(LOADBAR,0)) & CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(2) = ENP ENT
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { CLRBAR!='0 & (LOADBAR!='0 ^ CHANGED(LOADBAR,0)) 
+     & CHANGED(EN,20NS) }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = CLK
+   SETUPTIME = 25NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK LH = CLK
+   RELEASETIME_LH = 20NS
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74161  Synchronous 4-bit Binary Counter with Direct Clear
*
* THE TTL LOGIC DATA BOOK, 1988, TI
* tc  06/30/92  Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices
* jgt 10/15/93  Changed to use Pindly with integral Constraint clause;
*               Fixed bug in DATA setup/hold check "WHEN" test.
*
.SUBCKT 74161 CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O RCO_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(4) DPWR DGND $D_HI CLRBAR MCLK
+ JA JB JC JD KA KB KC KD
+ QA QB QC QD $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_STD
*
U161LOG LOGICEXP(13,20) DPWR DGND
+ CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I QA QB QC QD
+ MCLK RCO JA JB JC JD KA KB KC KD CLK ENP ENT CLRBAR LOADBAR A B C D IEN
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLK = { CLK_I }
+   ENP = { ENP_I }
+   ENT = { ENT_I }
+   CLRBAR = { CLRBAR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   ILD = { ~LOADBAR }
+   IEN = { ENP & ENT }
+   IA1 = { IEN | ILD }
+   IA2 = { ~(A & ILD) }
+   IB1 = { (QA & IEN) | ILD }
+   IB2 = { ~(B & ILD) }
+   IC1 = { (QB & QA & IEN) | ILD }
+   IC2 = { ~(C & ILD) }
+   ID1 = { (QC & QB & QA & IEN) | ILD }
+   ID2 = { ~(D & ILD) }
+   MCLK = { ~CLK }
+   RCO = { QD & QC & QB & QA & ENT }
+   JA = { ~(ILD & IA2) & IA1 }
+   KA = { IA1 & IA2 }
+   JB = { ~(ILD & IB2) & IB1 }
+   KB = { IB1 & IB2 }
+   JC = { ~(ILD & IC2) & IC1 }
+   KC = { IC1 & IC2 }
+   JD = { ~(ILD & ID2) & ID1 }
+   KD = { ID1 & ID2 }
*
U161DLY PINDLY (5,0,10) DPWR DGND
+ RCO QA QB QC QD
+ CLK LOADBAR ENT CLRBAR ENP A B C D IEN
+ RCO_O QA_O QB_O QC_O QD_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = { CHANGED_LH(CLK,0) }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CLOCK & LOADBAR!='0 & TRN_LH, DELAY(-1,13NS,20NS),
+       CLOCK & LOADBAR!='0 & TRN_HL, DELAY(-1,15NS,23NS),
+       CLOCK & LOADBAR!='1 & TRN_LH, DELAY(-1,17NS,25NS),
+       CLOCK & LOADBAR!='1 & TRN_HL, DELAY(-1,19NS,29NS),
+       CHANGED_HL(CLRBAR,0), DELAY(-1,26NS,38NS),
+       DELAY(-1,26NS,38NS)
+       )
+     }
+   RCO_O = {
+     CASE(
+       CHANGED(ENT,0), DELAY(-1,11NS,16NS),
+       CLOCK, DELAY(-1,23NS,35NS),
+       DELAY(-1,23NS,35NS)
+       )
+     }
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 25NS
+   MIN_HI = 25NS
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   AFFECTS (4) QA_O QB_O QC_O QD_O
+   WHEN = { (LOADBAR!='0 ^ CHANGED(LOADBAR,0)) & CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(2) = ENP ENT
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { (LOADBAR!='0 ^ CHANGED(LOADBAR,0)) & CLRBAR!='0 &
+     CHANGED(IEN,20NS) }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = CLK
+   SETUPTIME = 25NS
+   WHEN = { CLRBAR!='0 }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74162  Synchronous 4-bit Decade Counters with synchronous clear
*
* The TTL Data Book, 1986, TI
* JSW   7/1/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
*
.SUBCKT 74162  CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O RCO_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
* 
U162LOG LOGICEXP(14,20) DPWR DGND
+ CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I QDBAR QA QB QC QD
+ CLK ENP ENT CLRBAR LOADBAR A B C D 
+ CLKBAR RCO JA JB JC JD KA KB KC KD EN
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLK = { CLK_I }                     ;Buffering
+   ENP = { ENP_I }
+   ENT = { ENT_I }
+   CLRBAR = { CLRBAR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }      
+   CLKBAR = { ~CLK_I }                ;Logic expressions
+   LOAD = { ~LOADBAR | ~CLRBAR }
+   EN = { ENP & ENT }
+   I1A = { LOAD | EN }
+   I2A = { ~(LOAD & A & CLRBAR) }
+   JA = { I1A & ~(LOAD & I2A) }
+   KA = { I1A & I2A }
+   I1B = { (QA & EN & QDBAR) | LOAD }
+   I2B = { ~(LOAD & B & CLRBAR) }
+   JB = { I1B & ~(LOAD & I2B) }
+   KB = { I1B & I2B }
+   I1C = { (QA & EN & QB) | LOAD }
+   I2C = { ~(LOAD & C & CLRBAR) }
+   JC = { I1C & ~(LOAD & I2C) }
+   KC = { I1C & I2C }
+   I1D = { ((QC & QB & QA & EN) | (EN & QA & QD)) | LOAD }
+   I2D = { ~(LOAD & D & CLRBAR) }
+   JD = { I1D & ~(LOAD & I2D) }
+   KD = { I1D & I2D }
+   RCO = { QD & QA & ENT }
*
UJKFF JKFF(4) DPWR DGND $D_HI $D_HI CLKBAR JA JB JC JD KA KB KC KD
+ QA QB QC QD QABAR QBBAR QCBAR QDBAR D0_EFF IO_STD
*
U162DLY PINDLY (5,0,10) DPWR DGND
+ RCO QA QB QC QD
+ CLK LOADBAR ENT ENP EN CLRBAR A B C D
+ RCO_O QA_O QB_O QC_O QD_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = { CHANGED_LH(CLK,0) }
+   CNTENT = { CHANGED(ENT,0) }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CLOCK & LOADBAR=='1 & TRN_LH, DELAY(-1,13NS,20NS),
+       CLOCK & LOADBAR=='1 & TRN_HL, DELAY(-1,15NS,23NS),
+       CLOCK & LOADBAR=='0 & TRN_LH, DELAY(-1,17NS,25NS),
+       CLOCK & LOADBAR=='0 & TRN_HL, DELAY(-1,19NS,29NS),
+       DELAY(-1,19NS,29NS)
+   	)
+     }
+   RCO_O = {
+     CASE(
+       CNTENT, DELAY(-1,11NS,16NS),
+       CLOCK, DELAY(-1,23NS,35NS),
+       DELAY(-1,23NS,35NS)
+       )
+     }
+ BOOLEAN:
+   NOTCLEAR = { CLRBAR!='0 ^ CHANGED(CLRBAR,0) }
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 25NS
+   MIN_HI = 25NS
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { (LOADBAR!='1 ^ CHANGED(LOADBAR,0)) & NOTCLEAR }
+ SETUP_HOLD:
+   DATA(2) = ENP ENT
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { NOTCLEAR & (LOADBAR!='0 ^ CHANGED(LOADBAR,0)) & CHANGED(EN,20NS) }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR 
+   CLOCK LH = CLK
+   SETUPTIME = 25NS
+   WHEN = { NOTCLEAR }
+ SETUP_HOLD:
+   DATA(1) = CLRBAR 
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74163  Synchronous 4-bit Binary Counter
*
* THE TTL LOGIC DATA BOOK, 1988, TI
* tc  07/08/92  Remodeled using LOGICEXP, PINDLY, & CONSTRAINT Devices
*
.SUBCKT 74163 CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O RCO_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(4) DPWR DGND $D_HI $D_HI MCLK JA JB JC JD KA KB KC KD QA QB QC QD
+ $D_NC $D_NC $D_NC $D_NC D0_EFF IO_STD
*
U163LOG LOGICEXP(13,20) DPWR DGND
+ CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I QA QB QC QD
+ MCLK RCO JA JB JC JD KA KB KC KD CLK ENP ENT CLRBAR LOADBAR IEN
+  A B C D
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLK = { CLK_I }
+   ENP = { ENP_I }
+   ENT = { ENT_I }
+   CLRBAR = { CLRBAR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   ILD = { ~(LOADBAR & CLRBAR) }
+   IEN = { ENP & ENT }
+   IA1 = { IEN | ILD }
+   IA2 = { ~(A & CLRBAR & ILD) }
+   IB1 = { (QA & IEN) | ILD }
+   IB2 = { ~(B & CLRBAR & ILD) }
+   IC1 = { (QB & QA & IEN) | ILD }
+   IC2 = { ~(C & CLRBAR & ILD) }
+   ID1 = { (QC & QB & QA & IEN) | ILD }
+   ID2 = { ~(D & CLRBAR & ILD) }
+   MCLK = { ~CLK }
+   RCO = { QD & QC & QB & QA & ENT }
+   JA = { ~(ILD & IA2) & IA1 }
+   KA = { IA1 & IA2 }
+   JB = { ~(ILD & IB2) & IB1 }
+   KB = { IB1 & IB2 }
+   JC = { ~(ILD & IC2) & IC1 }
+   KC = { IC1 & IC2 }
+   JD = { ~(ILD & ID2) & ID1 }
+   KD = { ID1 & ID2 }
*
U163DLY PINDLY (5,0,10) DPWR DGND
+ RCO QA QB QC QD
+ CLK LOADBAR ENT ENP CLRBAR A B C D IEN
+ RCO_O QA_O QB_O QC_O QD_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = { CHANGED_LH(CLK,0) }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CLOCK & LOADBAR=='1 & TRN_LH, DELAY(-1,13NS,20NS),
+       CLOCK & LOADBAR=='1 & TRN_HL, DELAY(-1,15NS,23NS),
+       CLOCK & LOADBAR=='0 & TRN_LH, DELAY(-1,17NS,25NS),
+       CLOCK & LOADBAR=='0 & TRN_HL, DELAY(-1,19NS,29NS),
+       DELAY(-1,26NS,38NS)
+       )
+     }
+   RCO_O = {
+     CASE(
+       CHANGED(ENT,0), DELAY(-1,11NS,16NS),
+       CLOCK, DELAY(-1,23NS,35NS),
+       DELAY(-1,23NS,35NS)
+       )
+     }
+ BOOLEAN:
+   NOTCLEAR = { CLRBAR!='0 ^ CHANGED(CLRBAR,0) }
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 25NS
+   MIN_HI = 25NS
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { (LOADBAR!='1 ^ CHANGED(LOADBAR,0)) & NOTCLEAR }
+ SETUP_HOLD:
+   DATA(2) = ENP ENT
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { (LOADBAR!='0 ^ CHANGED(LOADBAR,0)) & NOTCLEAR & CHANGED(IEN,20NS) }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = CLK
+   SETUPTIME = 25NS
+   WHEN = { NOTCLEAR }
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74164  8-BIT PARALLEL-OUT SERIAL SHIFT REGISTERS
*
* THE TTL DATA BOOK, VOL 2, 1985, TI
* KN   6-30-92        REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
* JGT  10-15-93       Changed to use pindly with integral constraint check
*
*
.SUBCKT 74164  CLRBAR_I CLK_I A_I B_I QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 BUFA(4) DPWR DGND
+ CLRBAR_I CLK_I A_I B_I   CLRBAR CLK A B
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
*
U2 AND(2) DPWR DGND
+ A B   IN
+ D0_GATE IO_STD 
*
U3 DFF(8) DPWR DGND
+ $D_HI   CLRBAR  CLK
+ IN   QA  QB  QC  QD  QE  QF  QG
+ QA   QB  QC  QD  QE  QF  QG  QH
+ $D_NC   $D_NC   $D_NC   $D_NC   $D_NC   $D_NC   $D_NC   $D_NC
+ D0_EFF IO_STD 
*
U164DLY PINDLY (8,0,4) DPWR DGND
+ QA QB QC QD QE QF QG QH
+ CLRBAR CLK A B
+ QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+   QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O = {
+     CASE(
+       CHANGED_LH(CLK,0) & TRN_LH, DELAY(8NS,17NS,27NS),
+       CHANGED_LH(CLK,0) & TRN_HL, DELAY(10NS,21NS,32NS),
+       CHANGED_HL(CLRBAR,0) & TRN_HL, DELAY(-1,24NS,36NS),
+       DELAY(11NS,25NS,37NS)  ;DEFAULT
+       )
+     }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HIGH = 20NS
+   MIN_LOW = 20NS
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LOW = 20NS
+
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(2) A B
+   SETUPTIME = 15NS
+   HOLDTIME = 5NS
+   AFFECTS_ALL
+   WHEN = { CLRBAR != '0 }
+
+ SETUP_HOLD:
+   DATA(1) CLRBAR
+   CLOCK LH = CLK
+   RELEASETIME_LH = 20NS
+   AFFECTS_ALL
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74165  PARALLEL-LOAD 8-BIT SHIFT REGISTERS
*
* THE TTL LOGIC STANDARD TTL, SCHOTTKY, LOW-POWER SCHOTTKY DATA BOOK, 1988, TI
* NH 7/23/92            REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74165 SH/LDBAR_I CLK_INH_I CLK_I SER_I A_I B_I C_I D_I E_I F_I G_I H_I
+ QH_O QHBAR_O
+ OPTIONAL: DPWR=$G_DPWR   DGND=$G_DGND
+ PARAMS:   MNTYMXDLY=0    IO_LEVEL=0
*
U165LOG LOGICEXP(12,29) DPWR DGND
+ SH/LDBAR_I CLK_INH_I CLK_I SER_I A_I B_I C_I D_I E_I F_I G_I H_I
+ SH/LDBAR CLK_INH CLK SER A B C D E F G H SA SB SC SD SE SF SG SH
+ RA RB RC RD RE RF RG RH CK
+ D0_GATE  IO_STD  IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+
+   SH/LDBAR = { SH/LDBAR_I }
+   CLK_INH = { CLK_INH_I }
+   CLK = { CLK_I }
+   SER = { SER_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   E = { E_I }
+   F = { F_I }
+   G = { G_I }
+   H = { H_I }
+
* INTERMEDIATE TERM
+   LOAD = { ~SH/LDBAR }
+
+   SA = { ~(LOAD & A) }
+   SB = { ~(LOAD & B) }
+   SC = { ~(LOAD & C) }
+   SD = { ~(LOAD & D) }
+   SE = { ~(LOAD & E) }
+   SF = { ~(LOAD & F) }
+   SG = { ~(LOAD & G) }
+   SH = { ~(LOAD & H) }
+
+   RA = { ~(LOAD & SA) }
+   RB = { ~(LOAD & SB) }
+   RC = { ~(LOAD & SC) }
+   RD = { ~(LOAD & SD) }
+   RE = { ~(LOAD & SE) }
+   RF = { ~(LOAD & SF) }
+   RG = { ~(LOAD & SG) }
+   RH = { ~(LOAD & SH) }
+
+   CK = { CLK_INH | CLK }
*
U1 DFF(1) DPWR DGND SA RA CK SER QA $D_NC
+ D0_EFF  IO_STD
*
U2 DFF(1) DPWR DGND SB RB CK QA QB $D_NC
+ D0_EFF  IO_STD
*
U3 DFF(1) DPWR DGND SC RC CK QB QC $D_NC
+ D0_EFF  IO_STD
*
U4 DFF(1) DPWR DGND SD RD CK QC QD $D_NC
+ D0_EFF  IO_STD
*
U5 DFF(1) DPWR DGND SE RE CK QD QE $D_NC
+ D0_EFF  IO_STD
*
U6 DFF(1) DPWR DGND SF RF CK QE QF $D_NC
+ D0_EFF  IO_STD
*
U7 DFF(1) DPWR DGND SG RG CK QF QG $D_NC
+ D0_EFF  IO_STD
*
U8 DFF(1) DPWR DGND SH RH CK QG QH QHBAR
+ D0_EFF  IO_STD
*
U165DLY PINDLY (2,0,12) DPWR DGND
+ QH QHBAR
+ SH/LDBAR CLK H CLK_INH SER A B C D E F G
+ QH_O QHBAR_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY}   IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   LMODE = { SH/LDBAR=='0 }
+   SMODE = { SH/LDBAR=='1 }
+   CH_H = { CHANGED(H,0) }
+   CLOCK = { CHANGED_LH(CLK,0) }
+   LOAD = { CHANGED_HL(SH/LDBAR,0) }
+
+ PINDLY:
+   QH_O = {
+     CASE(
+       CH_H & LMODE & TRN_LH, DELAY(-1,11NS,17NS),
+       CLOCK & SMODE & TRN_LH, DELAY(-1,16NS,24NS),
+       CLOCK & SMODE & TRN_HL, DELAY(-1,21NS,31NS),
+       LOAD & TRN_LH, DELAY(-1,21NS,31NS),
+       CH_H & LMODE & TRN_HL, DELAY(-1,24NS,36NS),
+       LOAD & TRN_HL, DELAY(-1,27NS,40NS),
+       DELAY(-1,28NS,41NS)            ;DEFAULT
+       )
+     }
+
+   QHBAR_O = {
+     CASE(
+       CLOCK & SMODE & TRN_LH, DELAY(-1,16NS,24NS),
+       CH_H & LMODE, DELAY(-1,18NS,27NS),
+       CLOCK & SMODE & TRN_HL, DELAY(-1,21NS,31NS),
+       LOAD & TRN_LH, DELAY(-1,21NS,31NS),
+       LOAD & TRN_HL, DELAY(-1,27NS,40NS),
+       DELAY(-1,28NS,41NS)            ;DEFAULT
+       )
+     }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 20MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 25NS
+   MIN_HI = 25NS
+
+ WIDTH:
+   NODE = SH/LDBAR
+   MIN_LO = 15NS
+
+ SETUP_HOLD:
+   DATA(1) = SH/LDBAR
+   CLOCK LH = CLK
+   SETUPTIME_HI = 45NS
+
+ SETUP_HOLD:
+   DATA(1) = SER
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { (SH/LDBAR!='0 ^ CHANGED(SH/LDBAR,0)) }
+
+ SETUP_HOLD:
+   DATA(8) = A B C D E F G H
+   CLOCK LH = SH/LDBAR
+   SETUPTIME = 10NS
+
+ SETUP_HOLD:
+   DATA(1) = CLK_INH
+   CLOCK LH = CLK
+   SETUPTIME_LO = 30NS
+   MESSAGE = "CLOCK ENABLE SETUP TIME IS NOT MET"
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74166  PARALLEL LOAD 8-BIT SHIFT REGISTERS
*
* THE TTL DATABOOK, VOL 2, 1988, TI
* NH   7-21-92      REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74166 CLRBAR_I SH/LDBAR_I CLK_INH_I CLK_I SER_I A_I B_I C_I D_I E_I 
+ F_I G_I H_I QH_O
+ OPTIONAL: DPWR=$G_DPWR    DGND=$G_DGND
+ PARAMS:   MNTYMXDLY=0     IO_LEVEL=0
*
U166LOG LOGICEXP(20,22) DPWR DGND
+ CLRBAR_I SH/LDBAR_I CLK_INH_I CLK_I SER_I A_I B_I C_I D_I E_I F_I G_I H_I
+  QA QB QC QD QE QF QG
+ CLRBAR SH/LDBAR CLK_INH CLK SER A B C D E F G H DA DB DC DD DE DF DG DH CK
+ D0_GATE  IO_STD  IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   CLRBAR    = { CLRBAR_I }
+   SH/LDBAR  = { SH/LDBAR_I }
+   CLK_INH   = { CLK_INH_I }
+   CLK       = { CLK_I }
+   SER       = { SER_I }
+   A         = { A_I }
+   B         = { B_I }
+   C         = { C_I }
+   D         = { D_I }
+   E         = { E_I }
+   F         = { F_I }
+   G         = { G_I }
+   H         = { H_I }
+
* INTERMEDIATE TERM
+   LOAD = { ~SH/LDBAR }
+
+   DA = { (SH/LDBAR & SER) | (LOAD & A) }
+   DB = { (SH/LDBAR & QA)  | (LOAD & B) }
+   DC = { (SH/LDBAR & QB)  | (LOAD & C) }
+   DD = { (SH/LDBAR & QC)  | (LOAD & D) }
+   DE = { (SH/LDBAR & QD)  | (LOAD & E) }
+   DF = { (SH/LDBAR & QE)  | (LOAD & F) }
+   DG = { (SH/LDBAR & QF)  | (LOAD & G) }
+   DH = { (SH/LDBAR & QG)  | (LOAD & H) }
+   CK = { CLK | CLK_INH }
*
U1 DFF(8) DPWR DGND  $D_HI CLRBAR CK
+ DA DB DC DD DE DF DG DH QA QB QC QD QE QF QG QH
+ $D_NC $D_NC  $D_NC  $D_NC  $D_NC  $D_NC  $D_NC  $D_NC
+ D0_EFF  IO_STD
*
U166DLY PINDLY (1,0,13) DPWR DGND
+ QH
+ CLRBAR CLK SH/LDBAR CLK_INH SER A B C D E F G H
+ QH_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY}   IO_LEVEL={IO_LEVEL}
+
+   PINDLY:
+    QH_O = {
+     CASE(
+       CHANGED_LH(CLK,0) & TRN_LH,      DELAY(-1,17NS,26NS),
+       CHANGED_LH(CLK,0) & TRN_HL,      DELAY(-1,20NS,30NS),
+       CHANGED_HL(CLRBAR,0) & TRN_HL,   DELAY(-1,23NS,35NS),
+                                        DELAY(-1,24NS,36NS)  ;DEFAULT
+       )
+     }
+
+ BOOLEAN:
+   ACTIVE_MODE = { CLRBAR!='0 & CLK_INH!='1 }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 20NS
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+
+ SETUP_HOLD:
+   DATA(1) SH/LDBAR
+   CLOCK LH = CLK
+   SETUPTIME = 30NS
+   WHEN = { ACTIVE_MODE }
+
+ SETUP_HOLD:
+   DATA(8) A B C D E F G H
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { ACTIVE_MODE & (SH/LDBAR!='1 ^ CHANGED(SH/LDBAR,0)) }
+
+ SETUP_HOLD:
+   DATA(1) SER
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { ACTIVE_MODE & (SH/LDBAR!='0 ^ CHANGED(SH/LDBAR,0)) }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74167  RATE MULTIPLIER DECADE SYNCHRONOUS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   7-14-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
* NOTICE: THE PROPAGATION DELAY FROM SET9 TO Y,ZBAR WAS NOT GIVEN IN THE DATA
*      BOOK.  SO, THE PROP DELAY WAS ASSSUMED TO BE THE SAME AS CLR TO Y,ZBAR
*
.SUBCKT 74167   CLR_I STRBBAR_I CLK_I ENINBAR_I SET9_I
+ B0_I B1_I B2_I B3_I UNICASBAR_I
+ Y_O ZBAR_O ENOUTBAR_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(2) DPWR DGND
+ $D_HI   CLEARAB CLKBAR
+  TOGA  TOGB
+  TOGA  TOGB
+    QA    QB
+ $D_NC $D_NC
+ D0_EFF  IO_STD
U2 JKFF(2) DPWR DGND
+ SET9BAR CLRBAR  CLKBAR
+  TOGC  TOGD
+  TOGC  TOGD
+    QC    QD
+ $D_NC $D_NC
+ D0_EFF  IO_STD
U3 DFF(1) DPWR DGND
+ $D_HI $D_HI CLKBAR
+ ENIN   ENINFALL $D_NC
+ D0_EFF  IO_STD
*
U167LOG LOGICEXP (15,22) DPWR DGND
+ CLR_I  STRBBAR_I CLK_I  ENINBAR_I SET9_I  B0_I B1_I B2_I B3_I UNICASBAR_I
+ QA QB QC QD ENINFALL
+ CLRBAR STRBBAR CLKBAR ENIN CLR SET9BAR B0  B1  B2  B3  UNICASBAR  SET9
+ CLEARAB TOGA TOGB TOGC TOGD  Y ZBAR ENOUTBAR ENINBAR CLK
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+
+   CLR       = { CLR_I }
+   CLRBAR    = { ~CLR }
+   STRBBAR   = { STRBBAR_I }
+   CLK       = { CLK_I }
+   CLKBAR    = { ~CLK }
+   ENINBAR   = { ENINBAR_I }
+   ENIN      = { ~ENINBAR }
+   SET9      = { SET9_I }
+   SET9BAR   = { ~SET9 }
+   B0        = { B0_I }
+   B1        = { B1_I }
+   B2        = { B2_I }
+   B3        = { B3_I }
+   UNICASBAR = { UNICASBAR_I }
+   STRBCLK   = { CLKBAR & ~STRBBAR }
+   ENINRF    = { ENIN | ENINFALL }
+   CLEARAB   = { CLRBAR & SET9BAR }
+   TOGA      = { ENINRF & ~QC }
+   TOGB      = { ENINRF &  QA }
+   TOGD      = { ENINRF &  QC }
+   TOGC      = { (TOGB & QB) | TOGD }
+   ZBAR      = { ~( (B3 & STRBCLK & ~QC      ) |
+                    (B2 & STRBCLK &  QA      ) |
+                    (B1 & STRBCLK &  QB & ~QA) |
+                    (B0 & STRBCLK &  QC & ~QD)
+                  )
+               }
+   Y         = { ~(UNICASBAR & ZBAR) }
+   ENOUTBAR  = { ~(ENIN & QC & QD) }
*
U167DLY PINDLY (3,0,11) DPWR DGND
+ Y ZBAR ENOUTBAR
+ CLR STRBBAR CLK ENINBAR SET9 B0 B1 B2 B3 UNICASBAR ENINFALL
+ Y_O ZBAR_O ENOUTBAR_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLEARED  = { CHANGED_LH(CLR,0) }
+   STROBED  = { CHANGED(STRBBAR,0) }
+   CLOCKED  = { CHANGED_LH(CLK,0) }
+   ENABLED  = { CHANGED(ENINBAR,0) }
+   SETNINE  = { CHANGED_LH(SET9,0) }
+   RATECHG  = { CHANGED(B0,0) | CHANGED(B1,0) |
+                CHANGED(B2,0) | CHANGED(B3,0) }
+   CASCADED = { CHANGED(UNICASBAR,0) }
+
+ PINDLY:
+   Y_O = {
+     CASE (
+       CASCADED & TRN_HL, DELAY(-1, 6NS,10NS),
+       CASCADED & TRN_LH, DELAY(-1, 9NS,14NS),
+                 RATECHG, DELAY(-1,15NS,23NS),
+       STROBED  & TRN_LH, DELAY(-1,19NS,30NS),
+       CLOCKED  & TRN_HL, DELAY(-1,20NS,30NS),
+       STROBED  & TRN_HL, DELAY(-1,22NS,33NS),
+                 CLEARED, DELAY(-1,24NS,36NS),
+                 SETNINE, DELAY(-1,24NS,36NS),
+                  TRN_LH, DELAY(-1,26NS,39NS),
+       DELAY(-1,26NS,39NS)
+       )
+     }
+   ZBAR_O = {
+     CASE (
+       RATECHG & TRN_LH, DELAY(-1, 9NS,14NS),
+       RATECHG & TRN_HL, DELAY(-1, 6NS,10NS),
+       STROBED & TRN_LH, DELAY(-1,12NS,18NS),
+       STROBED & TRN_HL, DELAY(-1,15NS,23NS),
+                CLEARED, DELAY(-1,15NS,23NS),
+                SETNINE, DELAY(-1,15NS,23NS),
+                 TRN_LH, DELAY(-1,12NS,18NS),
+                 TRN_HL, DELAY(-1,17NS,26NS),
+       DELAY(-1,17NS,26NS)
+       )
+     }
+   ENOUTBAR_O = {
+     CASE (
+       ENABLED & TRN_LH, DELAY(-1,13NS,20NS),
+       ENABLED & TRN_HL, DELAY(-1,14NS,21NS),
+                SETNINE, DELAY(-1,18NS,27NS),
+                 TRN_LH, DELAY(-1,19NS,30NS),
+                 TRN_HL, DELAY(-1,22NS,33NS),
+       DELAY(-1,22NS,33NS)
+       )
+     }
+
+ FREQ:
+   NODE      = CLK
+   MAXFREQ   = 25MEGHZ
+ WIDTH:
+   NODE      = CLK
+   MIN_LO    = 20NS
+   MIN_HI    = 20NS
+ WIDTH:
+   NODE      = CLR
+   MIN_HI    = 15NS
+   WHEN      = { SET9!='1 }
+ WIDTH:
+   NODE      = SET9
+   MIN_HI    = 15NS
+ SETUP_HOLD:
+   DATA(1)   = ENINBAR
+   CLOCK LH  = CLK
+   SETUPTIME = 25NS
+   WHEN      = { CLR!='1 & SET9!='1 }
+ SETUP_HOLD:
+   DATA(1)   = ENINBAR
+   CLOCK HL  = CLK
+   HOLDTIME  = 20NS
+   WHEN      = { CLR!='1 & SET9!='1 }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74170  REGISTER FILES 4X4 WITH OPEN COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, 1988, TI
* JLS   7-23-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74170   GWBAR_I WA_I WB_I GRBAR_I RA_I RB_I D1_I D2_I D3_I D4_I
+ Q1_O Q2_O Q3_O Q4_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UA DLTCH(4) DPWR DGND
+ $D_HI $D_HI GATEA
+    D1    D2    D3    D4
+   AQ1   AQ2   AQ3   AQ4
+ $D_NC $D_NC $D_NC $D_NC
+ D0_GFF  IO_STD
UB DLTCH(4) DPWR DGND
+ $D_HI $D_HI GATEB
+    D1    D2    D3    D4
+   BQ1   BQ2   BQ3   BQ4
+ $D_NC $D_NC $D_NC $D_NC
+ D0_GFF  IO_STD
UC DLTCH(4) DPWR DGND
+ $D_HI $D_HI GATEC
+    D1    D2    D3    D4
+   CQ1   CQ2   CQ3   CQ4
+ $D_NC $D_NC $D_NC $D_NC
+ D0_GFF  IO_STD
UD DLTCH(4) DPWR DGND
+ $D_HI $D_HI GATED
+    D1    D2    D3    D4
+   DQ1   DQ2   DQ3   DQ4
+ $D_NC $D_NC $D_NC $D_NC
+ D0_GFF  IO_STD
*
U170LOG LOGICEXP (26,18) DPWR DGND
+ GWBAR_I WA_I WB_I GRBAR_I RA_I RB_I D1_I D2_I D3_I D4_I
+ AQ1 AQ2 AQ3 AQ4   BQ1 BQ2 BQ3 BQ4   CQ1 CQ2 CQ3 CQ4   DQ1 DQ2 DQ3 DQ4
+ GWBAR   WA   WB   GRBAR   RA   RB   D1   D2   D3   D4
+ GATEA GATEB GATEC GATED Q1 Q2 Q3 Q4
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   GWBAR   = { GWBAR_I }
+   WA      = { WA_I }
+   WB      = { WB_I }
+   GRBAR   = { GRBAR_I }
+   RA      = { RA_I }
+   RB      = { RB_I }
+   D1      = { D1_I }
+   D2      = { D2_I }
+   D3      = { D3_I }
+   D4      = { D4_I }
+   ENABLE2 = { ~(GWBAR | WB) }
+   ENABLE1 = { ~(GWBAR | ENABLE2) }
+   GATEA   = { ENABLE2 & ~WA }
+   GATEB   = { ENABLE2 &  WA }
+   GATEC   = { ENABLE1 & ~WA }
+   GATED   = { ENABLE1 &  WA }
+   Q1      = { (AQ1 & ~RA & ~RB) |
+               (BQ1 &  RA & ~RB) |
+               (CQ1 & ~RA &  RB) |
+               (DQ1 &  RA &  RB) |
+                GRBAR
+             }
+   Q2      = { (AQ2 & ~RA & ~RB) |
+               (BQ2 &  RA & ~RB) |
+               (CQ2 & ~RA &  RB) |
+               (DQ2 &  RA &  RB) |
+                GRBAR
+             }
+   Q3      = { (AQ3 & ~RA & ~RB) |
+               (BQ3 &  RA & ~RB) |
+               (CQ3 & ~RA &  RB) |
+               (DQ3 &  RA &  RB) |
+                GRBAR
+             }
+   Q4      = { (AQ4 & ~RA & ~RB) |
+               (BQ4 &  RA & ~RB) |
+               (CQ4 & ~RA &  RB) |
+               (DQ4 &  RA &  RB) |
+                GRBAR
+             }
*
U170DLY PINDLY (4,0,10) DPWR DGND
+ Q1 Q2 Q3 Q4
+ GWBAR GRBAR RA RB D1 D2 D3 D4 WA WB
+ Q1_O Q2_O Q3_O Q4_O
+ IO_STD_OC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   WRITEEN = { CHANGED(GWBAR,0) }
+   READEN  = { CHANGED(GRBAR,0) }
+   READ    = { CHANGED(RA,0) | CHANGED(RB,0) }
+   DATA    = { CHANGED(D1,0) | CHANGED(D2,0) |
+               CHANGED(D3,0) | CHANGED(D4,0) }
+
+ PINDLY:
+   Q1_O Q2_O Q3_O Q4_O = {
+     CASE (
+       READEN  & TRN_LH, DELAY(-1,10NS,15NS),
+       DATA    & TRN_LH, DELAY(-1,20NS,30NS),
+       READ    & TRN_LH, DELAY(-1,23NS,35NS),
+       WRITEEN & TRN_LH, DELAY(-1,25NS,40NS),
+       READEN  & TRN_HL, DELAY(-1,20NS,30NS),
+       READ    & TRN_HL, DELAY(-1,30NS,40NS),
+       DATA    & TRN_HL, DELAY(-1,30NS,45NS),
+       WRITEEN & TRN_HL, DELAY(-1,34NS,45NS),
+       DELAY(-1,34NS,45NS)
+       )
+     }
+
+ WIDTH:
+   NODE      = GWBAR
+   MIN_LO    = 25NS
+ WIDTH:
+   NODE      = GRBAR
+   MIN_LO    = 25NS
+ SETUP_HOLD:
+   DATA(4)   = D1 D2 D3 D4
+   CLOCK LH  = GWBAR
+   SETUPTIME = 10NS
+   HOLDTIME  = 15NS
+ SETUP_HOLD:
+   DATA(2)   = WA WB
+   CLOCK HL  = GWBAR
+   SETUPTIME = 15NS
+   HOLDTIME  =  .1NS		;WA,WB MUST BE STABLE WHILE GWBAR IS LOW
+ SETUP_HOLD:
+   DATA(2)   = WA WB
+   CLOCK LH  = GWBAR
+   SETUPTIME =  .1NS		;WA,WB MUST BE STABLE WHILE GWBAR IS LOW
+   HOLDTIME  = 5NS
+ GENERAL:
+   WHEN      = { GWBAR!='1 & (CHANGED(WA,0NS) | CHANGED(WB,0NS)) }
+   MESSAGE   = "WA AND WB MUST BE STABLE WHILE GWBAR IS LOW"
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74172  REGISTERS FILE 16-BIT WITH 3-STATE OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   7-24-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
* NOTICE: THE WRITE ADDRESS MUST BE SETUP 10NS BEFORE THE CLOCK'S FALLING
*         EDGE AND STABLE WHILE THE CLOCK IS LOW.  THIS MODEL CANNOT
*         NOTIFY YOU OF THAT ERROR.
*    
.SUBCKT 74172
+ CLK_I
+ 1GWBAR_I 1W0_I   1W1_I   1W2_I   1GRBAR_I 1R0_I 1R1_I 1R2_I 1DA_I 1DB_I
+ 2GWBAR_I 2W/R0_I 2W/R1_I 2W/R2_I 2GRBAR_I                   2DA_I 2DB_I
+ 1QA_O 1QB_O 2QA_O 2QB_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U0 JKFF(2) DPWR DGND
+ $D_HI $D_HI CLKBAR
+ J0_A J0_B K0_A K0_B   QFF0_A QFF0_B $D_NC $D_NC
+ D0_EFF  IO_STD
U1 JKFF(2) DPWR DGND
+ $D_HI $D_HI CLKBAR
+ J1_A J1_B K1_A K1_B   QFF1_A QFF1_B $D_NC $D_NC
+ D0_EFF  IO_STD
U2 JKFF(2) DPWR DGND
+ $D_HI $D_HI CLKBAR
+ J2_A J2_B K2_A K2_B   QFF2_A QFF2_B $D_NC $D_NC
+ D0_EFF  IO_STD
U3 JKFF(2) DPWR DGND
+ $D_HI $D_HI CLKBAR
+ J3_A J3_B K3_A K3_B   QFF3_A QFF3_B $D_NC $D_NC
+ D0_EFF  IO_STD
U4 JKFF(2) DPWR DGND
+ $D_HI $D_HI CLKBAR
+ J4_A J4_B K4_A K4_B   QFF4_A QFF4_B $D_NC $D_NC
+ D0_EFF  IO_STD
U5 JKFF(2) DPWR DGND
+ $D_HI $D_HI CLKBAR
+ J5_A J5_B K5_A K5_B   QFF5_A QFF5_B $D_NC $D_NC
+ D0_EFF  IO_STD
U6 JKFF(2) DPWR DGND
+ $D_HI $D_HI CLKBAR
+ J6_A J6_B K6_A K6_B   QFF6_A QFF6_B $D_NC $D_NC
+ D0_EFF  IO_STD
U7 JKFF(2) DPWR DGND
+ $D_HI $D_HI CLKBAR
+ J7_A J7_B K7_A K7_B   QFF7_A QFF7_B $D_NC $D_NC
+ D0_EFF  IO_STD
*
U172LOG LOGICEXP (34,71) DPWR DGND
+ CLK_I 1GWBAR_I 1W0_I   1W1_I   1W2_I   1GRBAR_I 1R0_I 1R1_I 1R2_I
+ 1DA_I 1DB_I 2GWBAR_I 2W/R0_I 2W/R1_I 2W/R2_I 2GRBAR_I 2DA_I 2DB_I
+
+ QFF0_A QFF1_A QFF2_A QFF3_A QFF4_A QFF5_A QFF6_A QFF7_A
+ QFF0_B QFF1_B QFF2_B QFF3_B QFF4_B QFF5_B QFF6_B QFF7_B
+ CLK 1GWBAR 1W0  1W1  1W2  1GRBAR 1R0 1R1 1R2 1DA 1DB
+     2GWBAR 2WR0 2WR1 2WR2 2GRBAR             2DA 2DB
+ CLKBAR J0_A J1_A J2_A J3_A J4_A J5_A J6_A J7_A
+        J0_B J1_B J2_B J3_B J4_B J5_B J6_B J7_B
+        K0_A K1_A K2_A K3_A K4_A K5_A K6_A K7_A
+        K0_B K1_B K2_B K3_B K4_B K5_B K6_B K7_B
+ DFF0_A DFF1_A DFF2_A DFF3_A DFF4_A DFF5_A DFF6_A DFF7_A
+ DFF0_B DFF1_B DFF2_B DFF3_B DFF4_B DFF5_B DFF6_B DFF7_B
+ 1QA 1QB 2QA 2QB
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   CLK     = { CLK_I }
+   1GWBAR  = { 1GWBAR_I }
+   1W0     = { 1W0_I }
+   1W1     = { 1W1_I }
+   1W2     = { 1W2_I }
+   1GRBAR  = { 1GRBAR_I }
+   1R0     = { 1R0_I }
+   1R1     = { 1R1_I }
+   1R2     = { 1R2_I }
+   1DA     = { 1DA_I }
+   1DB     = { 1DB_I }
+   2GWBAR  = { 2GWBAR_I }
+   2WR0    = { 2W/R0_I }
+   2WR1    = { 2W/R1_I }
+   2WR2    = { 2W/R2_I }
+   2GRBAR  = { 2GRBAR_I }
+   2DA     = { 2DA_I }
+   2DB     = { 2DB_I }
+
+   CLKBAR  = { ~CLK }
+   1GW     = { ~1GWBAR }
+   1GR     = { ~1GRBAR }
+   2GW     = { ~2GWBAR }
+   2GR     = { ~2GRBAR }
+   1WBAR0  = { ~1W0 }
+   1WBAR1  = { ~1W1 }
+   1WBAR2  = { ~1W2 }
+   1RBAR0  = { ~1R0 }
+   1RBAR1  = { ~1R1 }
+   1RBAR2  = { ~1R2 }
+   2WRBAR0 = { ~2WR0 }
+   2WRBAR1 = { ~2WR1 }
+   2WRBAR2 = { ~2WR2 }
+
+   1WEBAR0 = { ~(1WBAR2 & 1WBAR1 & 1WBAR0 & 1GW) }
+   1WEBAR1 = { ~(1WBAR2 & 1WBAR1 & 1W0    & 1GW) }
+   1WEBAR2 = { ~(1WBAR2 & 1W1    & 1WBAR0 & 1GW) }
+   1WEBAR3 = { ~(1WBAR2 & 1W1    & 1W0    & 1GW) }
+   1WEBAR4 = { ~(1W2    & 1WBAR1 & 1WBAR0 & 1GW) }
+   1WEBAR5 = { ~(1W2    & 1WBAR1 & 1W0    & 1GW) }
+   1WEBAR6 = { ~(1W2    & 1W1    & 1WBAR0 & 1GW) }
+   1WEBAR7 = { ~(1W2    & 1W1    & 1W0    & 1GW) }
+   2WRE0   = { 2WRBAR2 & 2WRBAR1 & 2WRBAR0 }
+   2WRE1   = { 2WRBAR2 & 2WRBAR1 & 2WR0 }
+   2WRE2   = { 2WRBAR2 & 2WR1    & 2WRBAR0 }
+   2WRE3   = { 2WRBAR2 & 2WR1    & 2WR0 }
+   2WRE4   = { 2WR2    & 2WRBAR1 & 2WRBAR0 }
+   2WRE5   = { 2WR2    & 2WRBAR1 & 2WR0 }
+   2WRE6   = { 2WR2    & 2WR1    & 2WRBAR0 }
+   2WRE7   = { 2WR2    & 2WR1    & 2WR0 }
+   2WEBAR0 = { ~(2WRE0 & 2GW) }
+   2WEBAR1 = { ~(2WRE1 & 2GW) }
+   2WEBAR2 = { ~(2WRE2 & 2GW) }
+   2WEBAR3 = { ~(2WRE3 & 2GW) }
+   2WEBAR4 = { ~(2WRE4 & 2GW) }
+   2WEBAR5 = { ~(2WRE5 & 2GW) }
+   2WEBAR6 = { ~(2WRE6 & 2GW) }
+   2WEBAR7 = { ~(2WRE7 & 2GW) }
+
+   WRITE0  = { ~(1WEBAR0 & 2WEBAR0) }
+   WRITE1  = { ~(1WEBAR1 & 2WEBAR1) }
+   WRITE2  = { ~(1WEBAR2 & 2WEBAR2) }
+   WRITE3  = { ~(1WEBAR3 & 2WEBAR3) }
+   WRITE4  = { ~(1WEBAR4 & 2WEBAR4) }
+   WRITE5  = { ~(1WEBAR5 & 2WEBAR5) }
+   WRITE6  = { ~(1WEBAR6 & 2WEBAR6) }
+   WRITE7  = { ~(1WEBAR7 & 2WEBAR7) }
+   DFF0_A  = { (1DA & 2DA) | (1WEBAR0 & 2DA) | (2WEBAR0 & 1DA) }
+   DFF1_A  = { (1DA & 2DA) | (1WEBAR1 & 2DA) | (2WEBAR1 & 1DA) }
+   DFF2_A  = { (1DA & 2DA) | (1WEBAR2 & 2DA) | (2WEBAR2 & 1DA) }
+   DFF3_A  = { (1DA & 2DA) | (1WEBAR3 & 2DA) | (2WEBAR3 & 1DA) }
+   DFF4_A  = { (1DA & 2DA) | (1WEBAR4 & 2DA) | (2WEBAR4 & 1DA) }
+   DFF5_A  = { (1DA & 2DA) | (1WEBAR5 & 2DA) | (2WEBAR5 & 1DA) }
+   DFF6_A  = { (1DA & 2DA) | (1WEBAR6 & 2DA) | (2WEBAR6 & 1DA) }
+   DFF7_A  = { (1DA & 2DA) | (1WEBAR7 & 2DA) | (2WEBAR7 & 1DA) }
+   DFF0_B  = { (1DB & 2DB) | (1WEBAR0 & 2DB) | (2WEBAR0 & 1DB) }
+   DFF1_B  = { (1DB & 2DB) | (1WEBAR1 & 2DB) | (2WEBAR1 & 1DB) }
+   DFF2_B  = { (1DB & 2DB) | (1WEBAR2 & 2DB) | (2WEBAR2 & 1DB) }
+   DFF3_B  = { (1DB & 2DB) | (1WEBAR3 & 2DB) | (2WEBAR3 & 1DB) }
+   DFF4_B  = { (1DB & 2DB) | (1WEBAR4 & 2DB) | (2WEBAR4 & 1DB) }
+   DFF5_B  = { (1DB & 2DB) | (1WEBAR5 & 2DB) | (2WEBAR5 & 1DB) }
+   DFF6_B  = { (1DB & 2DB) | (1WEBAR6 & 2DB) | (2WEBAR6 & 1DB) }
+   DFF7_B  = { (1DB & 2DB) | (1WEBAR7 & 2DB) | (2WEBAR7 & 1DB) }
+   J0_A    = {  DFF0_A & WRITE0 }
+   J1_A    = {  DFF1_A & WRITE1 }
+   J2_A    = {  DFF2_A & WRITE2 }
+   J3_A    = {  DFF3_A & WRITE3 }
+   J4_A    = {  DFF4_A & WRITE4 }
+   J5_A    = {  DFF5_A & WRITE5 }
+   J6_A    = {  DFF6_A & WRITE6 }
+   J7_A    = {  DFF7_A & WRITE7 }
+   J0_B    = {  DFF0_B & WRITE0 }
+   J1_B    = {  DFF1_B & WRITE1 }
+   J2_B    = {  DFF2_B & WRITE2 }
+   J3_B    = {  DFF3_B & WRITE3 }
+   J4_B    = {  DFF4_B & WRITE4 }
+   J5_B    = {  DFF5_B & WRITE5 }
+   J6_B    = {  DFF6_B & WRITE6 }
+   J7_B    = {  DFF7_B & WRITE7 }
+   K0_A    = { ~DFF0_A & WRITE0 }
+   K1_A    = { ~DFF1_A & WRITE1 }
+   K2_A    = { ~DFF2_A & WRITE2 }
+   K3_A    = { ~DFF3_A & WRITE3 }
+   K4_A    = { ~DFF4_A & WRITE4 }
+   K5_A    = { ~DFF5_A & WRITE5 }
+   K6_A    = { ~DFF6_A & WRITE6 }
+   K7_A    = { ~DFF7_A & WRITE7 }
+   K0_B    = { ~DFF0_B & WRITE0 }
+   K1_B    = { ~DFF1_B & WRITE1 }
+   K2_B    = { ~DFF2_B & WRITE2 }
+   K3_B    = { ~DFF3_B & WRITE3 }
+   K4_B    = { ~DFF4_B & WRITE4 }
+   K5_B    = { ~DFF5_B & WRITE5 }
+   K6_B    = { ~DFF6_B & WRITE6 }
+   K7_B    = { ~DFF7_B & WRITE7 }
+
+   1RE0    = { 1RBAR2 & 1RBAR1 & 1RBAR0 & 1GR }
+   1RE1    = { 1RBAR2 & 1RBAR1 & 1R0    & 1GR }
+   1RE2    = { 1RBAR2 & 1R1    & 1RBAR0 & 1GR }
+   1RE3    = { 1RBAR2 & 1R1    & 1R0    & 1GR }
+   1RE4    = { 1R2    & 1RBAR1 & 1RBAR0 & 1GR }
+   1RE5    = { 1R2    & 1RBAR1 & 1R0    & 1GR }
+   1RE6    = { 1R2    & 1R1    & 1RBAR0 & 1GR }
+   1RE7    = { 1R2    & 1R1    & 1R0    & 1GR }
+   2RE0    = {  2WRE0 & 2GR }
+   2RE1    = {  2WRE1 & 2GR }
+   2RE2    = {  2WRE2 & 2GR }
+   2RE3    = {  2WRE3 & 2GR }
+   2RE4    = {  2WRE4 & 2GR }
+   2RE5    = {  2WRE5 & 2GR }
+   2RE6    = {  2WRE6 & 2GR }
+   2RE7    = {  2WRE7 & 2GR }
+   1QA     = { (QFF0_A & 1RE0) |
+               (QFF1_A & 1RE1) |
+               (QFF2_A & 1RE2) |
+               (QFF3_A & 1RE3) |
+               (QFF4_A & 1RE4) |
+               (QFF5_A & 1RE5) |
+               (QFF6_A & 1RE6) |
+               (QFF7_A & 1RE7) }
+   1QB     = { (QFF0_B & 1RE0) |
+               (QFF1_B & 1RE1) |
+               (QFF2_B & 1RE2) |
+               (QFF3_B & 1RE3) |
+               (QFF4_B & 1RE4) |
+               (QFF5_B & 1RE5) |
+               (QFF6_B & 1RE6) |
+               (QFF7_B & 1RE7) }
+   2QA     = { (QFF0_A & 2RE0) |
+               (QFF1_A & 2RE1) |
+               (QFF2_A & 2RE2) |
+               (QFF3_A & 2RE3) |
+               (QFF4_A & 2RE4) |
+               (QFF5_A & 2RE5) |
+               (QFF6_A & 2RE6) |
+               (QFF7_A & 2RE7) }
+   2QB     = { (QFF0_B & 2RE0) |
+               (QFF1_B & 2RE1) |
+               (QFF2_B & 2RE2) |
+               (QFF3_B & 2RE3) |
+               (QFF4_B & 2RE4) |
+               (QFF5_B & 2RE5) |
+               (QFF6_B & 2RE6) |
+               (QFF7_B & 2RE7) }
*
U172DLY PINDLY (4,2,16) DPWR DGND
+ 1QA 1QB 2QA 2QB
+ 1GRBAR 2GRBAR
+ 1R0 1R1 1R2 2WR0 2WR1 2WR2 CLK 1GWBAR 1W0 1W1 1W2 1DA 1DB 2GWBAR 2DA 2DB
+ 1QA_O 1QB_O 2QA_O 2QB_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   1READ = { CHANGED(1R0,0)  | CHANGED(1R1,0)  | CHANGED(1R2,0) }
+   2READ = { CHANGED(2WR0,0) | CHANGED(2WR1,0) | CHANGED(2WR2,0) }
+
+ TRISTATE:
+   ENABLE LO 1GRBAR
+   1QA_O 1QB_O = {
+     CASE (
+               TRN_ZH, DELAY(-1,14NS,30NS),
+               TRN_ZL, DELAY(-1,16NS,30NS),
+               TRN_HZ, DELAY(-1, 6NS,20NS),
+               TRN_LZ, DELAY(-1,11NS,20NS),
+       1READ & TRN_LH, DELAY(-1,33NS,45NS),
+       1READ & TRN_HL, DELAY(-1,30NS,45NS),
+       DELAY(-1,35NS,50NS)
+       )
+     }
+
+ TRISTATE:
+   ENABLE LO 2GRBAR
+   2QA_O 2QB_O = {
+     CASE (
+               TRN_ZH, DELAY(-1,14NS,30NS),
+               TRN_ZL, DELAY(-1,16NS,30NS),
+               TRN_HZ, DELAY(-1, 6NS,20NS),
+               TRN_LZ, DELAY(-1,11NS,20NS),
+       2READ & TRN_LH, DELAY(-1,33NS,45NS),
+       2READ & TRN_HL, DELAY(-1,30NS,45NS),
+       DELAY(-1,35NS,50NS)
+       )
+     }
+
+ FREQ:
+   NODE         = CLK
+   MAXFREQ      = 20MEGHZ
+ WIDTH:
+   NODE         = CLK
+   MIN_LO       = 25NS
+   MIN_HI       = 25NS
+ SETUP_HOLD:
+   DATA(2)      = 1GWBAR 2GWBAR
+   CLOCK LH     = CLK
+   SETUPTIME    = 35NS
+ SETUP_HOLD:
+   DATA(2)      = 1DA 1DB
+   CLOCK LH     = CLK
+   SETUPTIME_HI = 30NS
+   SETUPTIME_LO = 45NS
+   WHEN         = { 1GWBAR!='1 ^ CHANGED(1GWBAR,0) }
+ SETUP_HOLD:
+   DATA(2)      = 2DA 2DB
+   CLOCK LH     = CLK
+   SETUPTIME_HI = 30NS
+   SETUPTIME_LO = 45NS
+   WHEN         = { 2GWBAR!='1 ^ CHANGED(2GWBAR,0) }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74173  REGISTERS D-TYPE 4-BIT WITH 3-STATE OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   7-9-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*	    
.SUBCKT 74173   CLR_I CLK_I G1BAR_I G2BAR_I M_I N_I 1D_I 2D_I 3D_I 4D_I
+ 1Q_O 2Q_O 3Q_O 4Q_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 DFF(4) DPWR DGND
+ $D_HI CLRBAR CLK
+ DFF1  DFF2  DFF3  DFF4
+ 1Q    2Q    3Q    4Q
+ $D_NC $D_NC $D_NC $D_NC
+ D0_EFF  IO_STD
*
U173LOG LOGICEXP (14,13) DPWR DGND
+ CLR_I CLK_I G1BAR_I G2BAR_I M_I N_I 1D_I 2D_I 3D_I 4D_I 1Q 2Q 3Q 4Q
+ CLR CLRBAR CLK DATEN OE 1D 2D 3D 4D
+ DFF1 DFF2 DFF3 DFF4
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   CLR      = { CLR_I }
+   CLRBAR   = { ~CLR }
+   CLK      = { CLK_I }
+   G1BAR    = { G1BAR_I }
+   G2BAR    = { G2BAR_I }
+   M        = { M_I }
+   N        = { N_I }
+   1D       = { 1D_I }
+   2D       = { 2D_I }
+   3D       = { 3D_I }
+   4D       = { 4D_I }
+
+   DATENBAR = { G1BAR | G2BAR }
+   DATEN    = { ~DATENBAR }
+   OE       = { ~(M | N) }
+   DFF1     = { (1D & DATEN) | (1Q & DATENBAR) }
+   DFF2     = { (2D & DATEN) | (2Q & DATENBAR) }
+   DFF3     = { (3D & DATEN) | (3Q & DATENBAR) }
+   DFF4     = { (4D & DATEN) | (4Q & DATENBAR) }
*
U173DLY PINDLY (4,1,8) DPWR DGND
+ 1Q 2Q 3Q 4Q
+ OE
+ CLR CLK CLK DATEN 1D 2D 3D 4D
+ 1Q_O 2Q_O 3Q_O 4Q_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLEARED = { CHANGED_LH(CLR,0) }
+
+ TRISTATE:
+   ENABLE HI OE
+   1Q_O 2Q_O 3Q_O 4Q_O = {
+     CASE (
+       TRN_ZH,  DELAY(7NS,16NS,30NS),
+       TRN_ZL,  DELAY(7NS,21NS,30NS),
+       TRN_HZ,  DELAY(3NS,05NS,14NS),
+       TRN_LZ,  DELAY(3NS,11NS,20NS),
+       CLEARED, DELAY( -1,18NS,27NS),
+       TRN_HL,  DELAY( -1,19NS,31NS),
+       DELAY(-1,28NS,43NS)
+       )
+     }
+
+ FREQ:
+   NODE           = CLK
+   MAXFREQ        = 25MEGHZ
+ WIDTH:
+   NODE           = CLK
+   MIN_LO         = 20NS
+   MIN_HI         = 20NS
+ WIDTH:
+   NODE           = CLR
+   MIN_HI         = 20NS
+ SETUP_HOLD:
+   DATA(1)        = CLR
+   CLOCK LH       = CLK
+   RELEASETIME_HL = 10NS
+ SETUP_HOLD:
+   DATA(1)        = DATEN
+   CLOCK LH       = CLK
+   SETUPTIME      = 17NS
+   HOLDTIME       =  2NS
+   WHEN           = { CLR!='1 }
+ SETUP_HOLD:
+   DATA(4)        = 1D 2D 3D 4D
+   CLOCK LH       = CLK
+   SETUPTIME      = 10NS
+   HOLDTIME       = 10NS
+   WHEN           = { CLR!='1 & (DATEN!='0 ^ CHANGED(DATEN,0)) }
*
.ENDS
*
*$
*--------------------------------------------------------------------------
* 74174  HEX D-TYPE FLIP-FLOPS WITH CLEAR
*
* The TTL Data Book, Vol 2, 1985, TI
* tvh	06/27/89	Update interface and model names
*
.subckt 74174  CLRBAR CLK D1 D2 D3 D4 D5 D6 Q1 Q2 Q3 Q4 Q5 Q6
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UD dff(6) DPWR DGND
+	$D_HI	CLRBAR	CLK
+	D1	D2	D3	D4	D5	D6
+	Q1	Q2	Q3	Q4	Q5	Q6
+	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC
+	D_174 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_174 ueff (
+	TWCLKLMN=20NS	TWCLKHMN=20NS
+	TWPCLMN=20NS	TSUDCLKMN=20NS
+	TSUPCCLKHMN=25NS	THDCLKMN=5NS
+	TPPCQHLTY=23NS	TPPCQHLMX=35NS
+	TPCLKQLHTY=20NS	TPCLKQLHMX=30NS
+	TPCLKQHLTY=24NS	TPCLKQHLMX=35NS
+	)
*$
*--------------------------------------------------------------------------
* 74175  QUADRUPLE D-TYPE FLIP-FLOPS WITH CLEAR
*
* The TTL Data Book, Vol 2, 1985, TI
* tvh	06/27/89	Update interface and model names
*
.subckt 74175  CLRBAR CLK D1 D2 D3 D4 Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UD dff(4) DPWR DGND
+	$D_HI	CLRBAR	CLK
+	D1	D2	D3	D4
+	Q1	Q2	Q3	Q4	Q1BAR	Q2BAR	Q3BAR	Q4BAR
+	D_175 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_175 ueff (
+	TWCLKLMN=20NS	TWCLKHMN=20NS
+	TWPCLMN=20NS	TSUDCLKMN=20NS
+	TSUPCCLKHMN=25NS	THDCLKMN=5NS
+	TPPCQLHTY=16NS	TPPCQLHMX=25NS
+	TPPCQHLTY=23NS	TPPCQHLMX=35NS
+	TPCLKQLHTY=20NS	TPCLKQLHMX=30NS
+	TPCLKQHLTY=24NS	TPCLKQHLMX=35NS
+	)
*$
*---------------------------------------------------------------------------
* 74176  35MHz Presettable Decade and Binary Counter/Latch 
*
* The TTL Data Book, 1988, TI
* JSW   7/31/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
*
.SUBCKT 74176 LOADBAR_I CLRBAR_I CLK1_I CLK2_I A_I B_I C_I D_I 
+ QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
* 
U176LOG LOGICEXP(10,17) DPWR DGND
+ LOADBAR_I CLRBAR_I CLK1_I CLK2_I A_I B_I C_I D_I QB QC
+ LOADBAR CLRBAR CLK1 CLK2 A B C D JD SA SB SC SD RA RB RC RD
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   LOADBAR = { LOADBAR_I }
+   CLRBAR = { CLRBAR_I }
+   CLK1 = { CLK1_I }
+   CLK2 = { CLK2_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   LOAD = { ~CLRBAR | ~LOADBAR }
+   SA = { ~(A & LOAD & CLRBAR) }
+   SB = { ~(B & LOAD & CLRBAR) }
+   SC = { ~(C & LOAD & CLRBAR) }
+   SD = { ~(D & LOAD & CLRBAR) }
+   RA = { ~(SA & LOAD) }
+   RB = { ~(SB & LOAD) }
+   RC = { ~(SC & LOAD) }
+   RD = { ~(SD & LOAD) }
+   JD = { QB & QC }
*
UJK1 JKFF(1) DPWR DGND SA RA CLK1 $D_HI $D_HI QA $D_NC D0_EFF IO_STD
UJK2 JKFF(1) DPWR DGND SB RB CLK2 QDBAR QDBAR QB $D_NC	D0_EFF IO_STD
UJK3 JKFF(1) DPWR DGND SC RC QB $D_HI $D_HI QC $D_NC D0_EFF IO_STD
UJK4 JKFF(1) DPWR DGND SD RD CLK2 JD QD QD QDBAR	D0_EFF IO_STD
*
U176DLY PINDLY (4,0,8) DPWR DGND
+ QA QB QC QD
+ CLK1 CLK2 A B C D LOADBAR CLRBAR
+ QA_O QB_O QC_O QD_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLEAR = { CHANGED(CLRBAR,0) }
+   LOAD = { CHANGED(LOADBAR,0) }
+   CLOCK1 = { CHANGED_HL(CLK1,0) }
+   CLOCK2 = { CHANGED_HL(CLK2,0) }
+ PINDLY:
+   QA_O = {
+     CASE(
+       CLOCK1 & TRN_LH, DELAY(-1,8NS,13NS),
+       CLOCK1 & TRN_HL, DELAY(-1,11NS,17NS),
+       CHANGED(A,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,19NS,29NS),
+       LOAD & TRN_LH, DELAY(-1,29NS,43NS),
+       CHANGED(A,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,31NS,46NS),
+       LOAD & TRN_HL, DELAY(-1,32NS,48NS),
+       CLEAR, DELAY(-1,32NS,48NS),
+       DELAY(-1,32NS,48NS)
+       )
+     }
+   QB_O = {
+     CASE(
+       CLOCK2 & TRN_LH, DELAY(-1,11NS,17NS),
+       CLOCK2 & TRN_HL, DELAY(-1,17NS,26NS),
+       CHANGED(B,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,19NS,29NS),
+       LOAD & TRN_LH, DELAY(-1,29NS,43NS),
+       CHANGED(B,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,31NS,46NS),
+       LOAD & TRN_HL, DELAY(-1,32NS,48NS),
+       CLEAR, DELAY(-1,32NS,48NS),
+       DELAY(-1,32NS,48NS)
+       )
+     }
+   QC_O = {
+     CASE(
+       CLOCK2 & TRN_LH, DELAY(-1,27NS,41NS),
+       CLOCK2 & TRN_HL, DELAY(-1,34NS,51NS),
+       CHANGED(C,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,19NS,29NS),
+       LOAD & TRN_LH, DELAY(-1,29NS,43NS),
+       CHANGED(C,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,31NS,46NS),
+       LOAD & TRN_HL, DELAY(-1,32NS,48NS),
+       CLEAR, DELAY(-1,32NS,48NS),
+       DELAY(-1,32NS,48NS)
+       )
+     }
+   QD_O = {
+     CASE(
+       CLOCK2 & TRN_LH, DELAY(-1,13NS,20NS),
+       CLOCK2 & TRN_HL, DELAY(-1,17NS,26NS),
+       CHANGED(D,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,19NS,29NS),
+       LOAD & TRN_LH, DELAY(-1,29NS,43NS),
+       CHANGED(D,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,31NS,46NS),
+       LOAD & TRN_HL, DELAY(-1,32NS,48NS),
+       CLEAR, DELAY(-1,32NS,48NS),
+       DELAY(-1,32NS,48NS)
+       )
+     }
+ FREQ:
+   NODE = CLK1
+   MAXFREQ = 35MEG
+ FREQ:
+   NODE = CLK2
+   MAXFREQ = 17.5MEG
+ WIDTH:
+   NODE = CLK1
+   MIN_HI = 14NS
+ WIDTH:
+   NODE = CLK2
+   MIN_HI = 28NS
+ WIDTH:
+   NODE = LOADBAR
+   MIN_LO = 25NS
+   WHEN = { CLRBAR!='0 }
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK HL = CLK1
+   RELEASETIME_LH = 25NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK HL = CLK2
+   RELEASETIME_LH = 25NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK HL = CLK1
+   RELEASETIME_LH = 25NS
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK HL = CLK2
+   RELEASETIME_LH = 25NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK HL = LOADBAR
+   SETUPTIME_HI = 15NS
+   SETUPTIME_LO = 20NS
+   HOLDTIME = 25NS
+ GENERAL:
+   WHEN = { LOADBAR=='0 & (CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0)
+     | CHANGED(D,0)) }
+   MESSAGE = "Invalid hold time of DATA with respect to LOADBAR."
*
.ENDS
*
*$
*---------
* 74177  35MHz Presettable Decade and inary Counter/Latch 
*
* The TTL Data Book, 1988, TI
* JSW   7/31/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
*
.SUBCKT 74177 LOADBAR_I CLRBAR_I CLK1_I CLK2_I A_I B_I C_I D_I 
+ QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
* 
U177LOG LOGICEXP(8,16) DPWR DGND
+ LOADBAR_I CLRBAR_I CLK1_I CLK2_I A_I B_I C_I D_I 
+ LOADBAR CLRBAR CLK1 CLK2 A B C D SA SB SC SD RA RB RC RD
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   LOADBAR = { LOADBAR_I }
+   CLRBAR = { CLRBAR_I }
+   CLK1 = { CLK1_I }
+   CLK2 = { CLK2_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   LOAD = { ~CLRBAR | ~LOADBAR }
+   SA = { ~(A & LOAD & CLRBAR) }
+   SB = { ~(B & LOAD & CLRBAR) }
+   SC = { ~(C & LOAD & CLRBAR) }
+   SD = { ~(D & LOAD & CLRBAR) }
+   RA = { ~(SA & LOAD) }
+   RB = { ~(SB & LOAD) }
+   RC = { ~(SC & LOAD) }
+   RD = { ~(SD & LOAD) }
*	  
UJK1 JKFF(1) DPWR DGND SA RA CLK1 $D_HI $D_HI QA $D_NC D0_EFF IO_STD
UJK2 JKFF(1) DPWR DGND SB RB CLK2 $D_HI $D_HI QB $D_NC	D0_EFF IO_STD
UJK3 JKFF(1) DPWR DGND SC RC QB $D_HI $D_HI QC $D_NC D0_EFF IO_STD
UJK4 JKFF(1) DPWR DGND SD RD QC $D_HI $D_HI QD $D_NC	D0_EFF IO_STD
*
U177DLY PINDLY (4,0,8) DPWR DGND
+ QA QB QC QD
+ CLK1 CLK2 A B C D LOADBAR CLRBAR
+ QA_O QB_O QC_O QD_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLEAR = { CHANGED(CLRBAR,0) }
+   LOAD = { CHANGED(LOADBAR,0) }
+   CLOCK1 = { CHANGED_HL(CLK1,0) }
+   CLOCK2 = { CHANGED_HL(CLK2,0) }
+ PINDLY:
+   QA_O = {
+     CASE(
+       CLOCK1 & TRN_LH, DELAY(-1,8NS,13NS),
+       CLOCK1 & TRN_HL, DELAY(-1,11NS,17NS),
+       CHANGED(A,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,19NS,29NS),
+       LOAD & TRN_LH, DELAY(-1,29NS,43NS),
+       CHANGED(A,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,31NS,46NS),
+       LOAD & TRN_HL, DELAY(-1,32NS,48NS),
+       CLEAR, DELAY(-1,32NS,48NS),
+       DELAY(-1,32NS,48NS)
+       )
+     }
+   QB_O = {
+     CASE(
+       CLOCK2 & TRN_LH, DELAY(-1,11NS,17NS),
+       CLOCK2 & TRN_HL, DELAY(-1,17NS,26NS),
+       CHANGED(B,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,19NS,29NS),
+       LOAD & TRN_LH, DELAY(-1,29NS,43NS),
+       CHANGED(B,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,31NS,46NS),
+       LOAD & TRN_HL, DELAY(-1,32NS,48NS),
+       CLEAR, DELAY(-1,32NS,48NS),
+       DELAY(-1,32NS,48NS)
+       )
+     }
+   QC_O = {
+     CASE(
+       CLOCK2 & TRN_LH, DELAY(-1,27NS,41NS),
+       CLOCK2 & TRN_HL, DELAY(-1,34NS,51NS),
+       CHANGED(C,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,19NS,29NS),
+       LOAD & TRN_LH, DELAY(-1,29NS,43NS),
+       CHANGED(C,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,31NS,46NS),
+       LOAD & TRN_HL, DELAY(-1,32NS,48NS),
+       CLEAR, DELAY(-1,32NS,48NS),
+       DELAY(-1,32NS,48NS)
+       )
+     }
+   QD_O = {
+     CASE(
+       CLOCK2 & TRN_LH, DELAY(-1,44NS,66NS),
+       CLOCK2 & TRN_HL, DELAY(-1,50NS,75NS),
+       CHANGED(D,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,19NS,29NS),
+       LOAD & TRN_LH, DELAY(-1,29NS,43NS),
+       CHANGED(D,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,31NS,46NS),
+       LOAD & TRN_HL, DELAY(-1,32NS,48NS),
+       CLEAR, DELAY(-1,32NS,48NS),
+       DELAY(-1,32NS,48NS)
+       )
+     }
+ FREQ:
+   NODE = CLK1
+   MAXFREQ = 35MEG
+ FREQ:
+   NODE = CLK2
+   MAXFREQ = 17.5MEG
+ WIDTH:
+   NODE = CLK1
+   MIN_HI = 14NS
+ WIDTH:
+   NODE = CLK2
+   MIN_HI = 28NS
+ WIDTH:
+   NODE = LOADBAR
+   MIN_LO = 25NS
+   WHEN = { CLRBAR!='0 }
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK HL = CLK1
+   RELEASETIME_LH = 25NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK HL = CLK2
+   RELEASETIME_LH = 25NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK HL = CLK1
+   RELEASETIME_LH = 25NS
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK HL = CLK2
+   RELEASETIME_LH = 25NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK HL = LOADBAR
+   SETUPTIME_HI = 15NS
+   SETUPTIME_LO = 20NS
+   HOLDTIME = 25NS
+ GENERAL:
+   WHEN = { LOADBAR=='0 & (CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0)
+     | CHANGED(D,0)) }
+   MESSAGE = "Invalid hold time of DATA with respect to LOADBAR."
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74178 4-BIT PARALLEL-ACCESS SHIFT REGISTER
*
* THE TTL DATA BOOK, VOL 2, 1988, TI
* NH 6/30/92         REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74178 SHIFT_I LOAD_I CLK_I SER_I A_I B_I C_I D_I QA_O QB_O QC_O QD_O
+       OPTIONAL: DPWR = $G_DPWR   DGND = $G_DGND
+       PARAMS:   MNTYMXDLY = 0    IO_LEVEL = 0
*
U178LOG LOGICEXP(12,16) DPWR DGND
+ SHIFT_I LOAD_I CLK_I SER_I A_I B_I C_I D_I QA QB QC QD
+ SHIFT LOAD CLK SER A B C D KA KB KC KD JA JB JC JD
+ D0_GATE IO_STD IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
*
* INTERMEDIATE TERMS:
*
+   LOAD_MODE = { ~SHIFT_I & LOAD_I }
+   HOLD_MODE = { ~SHIFT_I & ~LOAD_I }
*
* OUTPUT ASSIGNMENT
*
+   SHIFT = { SHIFT_I }
+   LOAD = { LOAD_I }
+   CLK = { CLK_I }
+   SER = { SER_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+
+   KA = { ~( (SER & SHIFT) | (LOAD_MODE & A) | (HOLD_MODE & QA) ) }
+   KB = { ~( (QA & SHIFT) | (LOAD_MODE & B) | (HOLD_MODE & QB) ) }
+   KC = { ~( (QB & SHIFT) | (LOAD_MODE & C) | (HOLD_MODE & QC) ) }
+   KD = { ~( (QC & SHIFT) | (LOAD_MODE & D) | (HOLD_MODE & QD) ) }
+   JA = { ~KA }
+   JB = { ~KB }
+   JC = { ~KC }
+   JD = { ~KD }
*
U1 JKFF(4) DPWR DGND $D_HI $D_HI CLK JA JB JC JD KA KB KC KD
+ QA QB QC QD $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_STD
*
U178DLY PINDLY (4,0,8) DPWR DGND
+ QA QB QC QD
+ CLK SHIFT LOAD SER A B C D
+ QA_O QB_O QC_O QD_O
+ IO_STD
+ MNTYMXDLY = {MNTYMXDLY}   IO_LEVEL = {IO_LEVEL}
+
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+      CASE(
+        CHANGED_HL(CLK,0) & TRN_LH, DELAY(-1,17NS,26NS),
+        CHANGED_HL(CLK,0) & TRN_HL, DELAY(-1,23NS,35NS),
+        DELAY(-1,24NS,36NS)         ;DEFAULT
+        )
+      }
+
+ BOOLEAN:
+   LOAD_MODE = { SHIFT!='1 ^ CHANGED(SHIFT,0) }
+   SHIFT_MODE = { (SHIFT!='0 ^ CHANGED(SHIFT,0)) }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 20NS
+
+ SETUP_HOLD:
+   DATA(1) SHIFT
+   CLOCK HL = CLK
+   SETUPTIME = 35NS
+   HOLDTIME = 5NS
+
+ SETUP_HOLD:
+   DATA(1) LOAD
+   CLOCK HL = CLK
+   SETUPTIME = 35NS
+   HOLDTIME = 5NS
+   WHEN = { LOAD_MODE }
+
+ SETUP_HOLD:                          ;IN LOAD MODE
+   DATA(4) A B C D
+   CLOCK HL = CLK
+   SETUPTIME = 30NS
+   HOLDTIME = 5NS
+   WHEN = { LOAD_MODE & (LOAD!='0 ^ CHANGED(LOAD,0)) }
+
+ SETUP_HOLD:                          ;IN SHIFT MODE
+   DATA(1) SER
+   CLOCK HL = CLK
+   SETUPTIME = 30NS
+   HOLDTIME = 5NS
+   WHEN = { SHIFT_MODE }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74179 4-BIT PARALLEL-ACCESS SHIFT REGISTER
*
* THE TTL DATA BOOK, VOL 2, 1985, TI
* NH 7/1/92         REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74179 CLRBAR_I SHIFT_I LOAD_I CLK_I SER_I A_I B_I C_I D_I
+  QA_O QB_O QC_O QD_O QDBAR_O
+  OPTIONAL: DPWR=$G_DPWR   DGND=$G_DGND
+  PARAMS:   MNTYMXDLY=0    IO_LEVEL=0
*
U179LOG LOGICEXP(13,17) DPWR DGND
+ CLRBAR_I SHIFT_I LOAD_I CLK_I SER_I A_I B_I C_I D_I QA QB QC QD
+ CLRBAR SHIFT LOAD CLK SER A B C D KA KB KC KD JA JB JC JD
+ D0_GATE  IO_STD  IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
*
* INTERMEDIATE TERMS
*
+   LOAD_MODE = { ~SHIFT_I & LOAD_I }
+   HOLD_MODE = { ~SHIFT_I & ~LOAD_I }
*
* OUTPUT ASSIGNMENT
*
+   CLRBAR = { CLRBAR_I }
+   SHIFT = { SHIFT_I }
+   LOAD = { LOAD_I }
+   CLK = { CLK_I }
+   SER = { SER_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+
+   KA = { ~((SER & SHIFT) | (LOAD_MODE & A) | (HOLD_MODE & QA)) }
+   KB = { ~((QA & SHIFT) | (LOAD_MODE & B) | (HOLD_MODE & QB)) }
+   KC = { ~((QB & SHIFT) | (LOAD_MODE & C) | (HOLD_MODE & QC)) }
+   KD = { ~((QC & SHIFT) | (LOAD_MODE & D) | (HOLD_MODE & QD)) }
+   JA = { ~KA }
+   JB = { ~KB }
+   JC = { ~KC }
+   JD = { ~KD }
*
U1 JKFF(4) DPWR DGND $D_HI CLRBAR CLK JA JB JC JD KA KB KC KD
+ QA QB QC QD $D_NC $D_NC $D_NC QDBAR
+ D0_EFF IO_STD
*
U179DLY PINDLY (5,0,9) DPWR DGND
+ QA QB QC QD QDBAR
+ CLK CLRBAR SHIFT LOAD SER A B C D
+ QA_O QB_O QC_O QD_O QDBAR_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY}   IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+      CASE(
+        CHANGED_HL(CLK,0) & TRN_LH, DELAY(-1,17NS,26NS),
+        CHANGED_HL(CLK,0) & TRN_HL, DELAY(-1,23NS,35NS),
+        CHANGED_HL(CLRBAR,0) & TRN_HL, DELAY(-1,24NS,36NS),
+        DELAY(-1,25NS,37NS)         ;DEFAULT
+        )
+      }
+
+   QDBAR_O = {
+      CASE(
+        CHANGED_HL(CLRBAR,0) & TRN_LH, DELAY(-1,15NS,23NS),
+        CHANGED_HL(CLK,0) & TRN_LH, DELAY(-1,17NS,26NS),
+        CHANGED_HL(CLK,0) & TRN_HL, DELAY(-1,23NS,35NS),
+        DELAY(-1,24NS,36NS)         ;DEFAULT
+        )
+      }
+
+ BOOLEAN:
+   NOT_CLEAR = {CLRBAR!='0}
+   LOAD_MODE = { (SHIFT!='1 ^ CHANGED(SHIFT,0)) }
+   SHIFT_MODE = { (SHIFT!='0 ^ CHANGED(SHIFT,0)) }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 20NS
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+
+ SETUP_HOLD:
+   DATA(1) CLRBAR
+   CLOCK HL = CLK
+   RELEASETIME_LH = 15NS
+
+ SETUP_HOLD:
+   DATA(1) SHIFT
+   CLOCK HL= CLK
+   SETUPTIME = 35NS
+   HOLDTIME = 5NS
+   WHEN = { NOT_CLEAR }
+
+ SETUP_HOLD:
+   DATA(1) LOAD
+   CLOCK HL = CLK
+   SETUPTIME = 35NS
+   HOLDTIME = 5NS
+   WHEN = { NOT_CLEAR & LOAD_MODE }
+
+ SETUP_HOLD:
+   DATA(4) A B C D
+   CLOCK HL = CLK
+   SETUPTIME = 30NS
+   HOLDTIME = 5NS
+   WHEN = { NOT_CLEAR & LOAD_MODE & (LOAD!='0  ^ CHANGED(LOAD,0)) }
+
+ SETUP_HOLD:
+    DATA(1) SER
+    CLOCK HL = CLK
+    SETUPTIME = 30NS
+    HOLDTIME = 5NS
+    WHEN = { NOT_CLEAR & SHIFT_MODE }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74180  PARITY GENERATOR/CHECKER ODD/EVEN 9-BIT
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-17-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74180   A_I B_I C_I D_I E_I F_I G_I H_I EIN_I OIN_I
+ EOUT_O OOUT_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U180LOG LOGICEXP (10,12) DPWR DGND
+ A_I B_I C_I D_I E_I F_I G_I H_I EIN_I OIN_I
+ A   B   C   D   E   F   G   H   EIN   OIN   EOUT OOUT
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   A      = { A_I }
+   B      = { B_I }
+   C      = { C_I }
+   D      = { D_I }
+   E      = { E_I }
+   F      = { F_I }
+   G      = { G_I }
+   H      = { H_I }
+   EIN    = { EIN_I }
+   OIN    = { OIN_I }
+
+   PARITY = { A ^ B ^ C ^ D ^ E ^ F ^ G ^ H }
+   EOUT   = { ~((~PARITY & OIN) | (PARITY & EIN)) }
+   OOUT   = { ~((~PARITY & EIN) | (PARITY & OIN)) }
*
U180DLY PINDLY (2,0,10) DPWR DGND
+ EOUT OOUT
+ A B C D E F G H EIN OIN
+ EOUT_O OOUT_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+
+   ADDR    = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) |
+               CHANGED(D,0) | CHANGED(E,0) | CHANGED(F,0) |
+               CHANGED(G,0) | CHANGED(H,0) }
+   ODDGND  = { ADDR & OIN=='0 }
+   EVENGND = { ADDR & EIN=='0 }
+   POLAR   = { CHANGED(EIN,0) | CHANGED(OIN,0) }
+
+ PINDLY:
+   EOUT_O = {
+     CASE (
+       POLAR   & TRN_LH, DELAY(-1,13NS,20NS),
+       POLAR   & TRN_HL, DELAY(-1, 7NS,10NS),
+       EVENGND & TRN_LH, DELAY(-1,32NS,48NS),
+       EVENGND & TRN_HL, DELAY(-1,25NS,38NS),
+       ODDGND  & TRN_LH, DELAY(-1,40NS,60NS),
+       ODDGND  & TRN_HL, DELAY(-1,45NS,68NS),
+       DELAY(-1,45NS,68NS)
+       )
+     }
+
+   OOUT_O = {
+     CASE (
+       POLAR   & TRN_LH, DELAY(-1,13NS,20NS),
+       POLAR   & TRN_HL, DELAY(-1, 7NS,10NS),
+       ODDGND  & TRN_LH, DELAY(-1,32NS,48NS),
+       ODDGND  & TRN_HL, DELAY(-1,25NS,38NS),
+       EVENGND & TRN_LH, DELAY(-1,40NS,60NS),
+       EVENGND & TRN_HL, DELAY(-1,45NS,68NS),
+       DELAY(-1,45NS,68NS)
+       )
+     }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74181  ALU / FUNCTION GENERATOR
*
* THE TTL DATA BOOK, VOLUME 2, STANDARD, S, LS, TTL; 1985, TI
* JLS   9-4-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74181   A0BAR_I A1BAR_I A2BAR_I A3BAR_I B0BAR_I B1BAR_I B2BAR_I
+ B3BAR_I S0_I S1_I S2_I S3_I M_I CN_I F0BAR_O F1BAR_O F2BAR_O F3BAR_O
+ AEQUALB_O PBAR_O GBAR_O CN+4_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U181LOG LOGICEXP (14,22) DPWR DGND
+ A0BAR_I A1BAR_I A2BAR_I A3BAR_I B0BAR_I B1BAR_I B2BAR_I B3BAR_I
+ S0_I S1_I S2_I S3_I M_I CN_I
+ A0BAR   A1BAR   A2BAR   A3BAR   B0BAR   B1BAR   B2BAR   B3BAR
+ S0   S1   S2   S3   M   CN
+ F0BAR   F1BAR   F2BAR   F3BAR   AEQUALB PBAR    GBAR    CN+4
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   A0BAR   = { A0BAR_I }
+   A1BAR   = { A1BAR_I }
+   A2BAR   = { A2BAR_I }
+   A3BAR   = { A3BAR_I }
+   B0BAR   = { B0BAR_I }
+   B1BAR   = { B1BAR_I }
+   B2BAR   = { B2BAR_I }
+   B3BAR   = { B3BAR_I }
+   S0      = { S0_I }
+   S1      = { S1_I }
+   S2      = { S2_I }
+   S3      = { S3_I }
+   M       = { M_I }
+   CN      = { CN_I }
+
+   TOP3    = { ~( (A3BAR & B3BAR & S3) | (A3BAR & ~B3BAR & S2) ) }
+   BOT3    = { ~(        (~B3BAR & S1) |  A3BAR | (B3BAR & S0) ) }
+   TOP2    = { ~( (A2BAR & B2BAR & S3) | (A2BAR & ~B2BAR & S2) ) }
+   BOT2    = { ~(        (~B2BAR & S1) |  A2BAR | (B2BAR & S0) ) }
+   TOP1    = { ~( (A1BAR & B1BAR & S3) | (A1BAR & ~B1BAR & S2) ) }
+   BOT1    = { ~(        (~B1BAR & S1) |  A1BAR | (B1BAR & S0) ) }
+   TOP0    = { ~( (A0BAR & B0BAR & S3) | (A0BAR & ~B0BAR & S2) ) }
+   BOT0    = { ~(        (~B0BAR & S1) |  A0BAR | (B0BAR & S0) ) }
+   MBAR    = { ~M }
+
+   F3BAR   = { (TOP3 ^ BOT3) ^ ~( (  CN & MBAR & TOP2 & TOP1 & TOP0) |
+                                  (BOT0 & MBAR & TOP2 & TOP1) |
+                                  (BOT1 & MBAR & TOP2) |
+                                  (BOT2 & MBAR) ) }
+   F2BAR   = { (TOP2 ^ BOT2) ^ ~( (  CN & MBAR & TOP1 & TOP0) |
+                                  (BOT0 & MBAR & TOP1) |
+                                  (BOT1 & MBAR) ) }
+   F1BAR   = { (TOP1 ^ BOT1) ^ ~( (  CN & MBAR & TOP0) |
+                                  (BOT0 & MBAR) ) }
+   F0BAR   = { (TOP0 ^ BOT0) ^ ~(    CN & MBAR) }
+   AEQUALB = { F3BAR & F2BAR & F1BAR & F0BAR }
+   PBAR    = { ~(         TOP3 & TOP2 & TOP1 & TOP0) }
+   GBAR    = { ~( (BOT0 & TOP3 & TOP2 & TOP1) |
+                  (BOT1 & TOP3 & TOP2) |
+                  (BOT2 & TOP3) | 
+                   BOT3 ) }
+   CN+4    = { ~GBAR | (~PBAR & CN) }

U181DLY PINDLY (7,0,14) DPWR DGND
+ F0BAR   F1BAR   F2BAR   F3BAR   PBAR   GBAR   CN+4
+ A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3 M CN
+ F0BAR_O F1BAR_O F2BAR_O F3BAR_O PBAR_O GBAR_O CN+4_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CARRY = { CHANGED(CN,0) }
+   OPER  = { CHANGED(A3BAR,0) | CHANGED(B3BAR,0) |
+             CHANGED(A2BAR,0) | CHANGED(B2BAR,0) |
+             CHANGED(A1BAR,0) | CHANGED(B1BAR,0) |
+             CHANGED(A0BAR,0) | CHANGED(B0BAR,0) }
+   NOTM  = { M=='0 }
+   SUM   = { OPER & NOTM & S0=='1 & S1=='0 & S2=='0 & S3=='1 }
+   DIF   = { OPER & NOTM & S0=='0 & S1=='1 & S2=='1 & S3=='0 }
+
+ PINDLY:
+   F0BAR_O F1BAR_O F2BAR_O F3BAR_O = {
+     CASE (
+       NOTM & CARRY & TRN_LH, DELAY(-1,13NS,19NS),
+       NOTM & CARRY & TRN_HL, DELAY(-1,12NS,18NS),
+       SUM          & TRN_LH, DELAY(-1,28NS,42NS),
+       SUM          & TRN_HL, DELAY(-1,21NS,32NS),
+                      TRN_LH, DELAY(-1,32NS,48NS),
+                      TRN_HL, DELAY(-1,23NS,34NS),
+       DELAY(-1,32NS,48NS)
+       )
+     }
+   PBAR_O = {
+     CASE (
+       SUM & TRN_LH, DELAY(-1,13NS,19NS),
+       DELAY(-1,17NS,25NS)
+       )
+     }
+   GBAR_O = {
+     CASE (
+       SUM , DELAY(-1,13NS,19NS),
+       DELAY(-1,17NS,25NS)
+       )
+     }
+   CN+4_O = {
+     CASE (
+       CARRY & TRN_LH, DELAY(-1,12NS,18NS),
+       CARRY & TRN_HL, DELAY(-1,13NS,19NS),
+       SUM   & TRN_LH, DELAY(-1,28NS,43NS),
+       SUM   & TRN_HL, DELAY(-1,27NS,41NS),
+       DIF   & TRN_LH, DELAY(-1,35NS,50NS),
+       DIF   & TRN_HL, DELAY(-1,33NS,50NS),
+       DELAY(-1,35NS,50NS)
+       )
+     }

U181DLY_OC PINDLY (1,0,13) DPWR DGND
+ AEQUALB
+ A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3 M
+ AEQUALB_O
+ IO_STD_OC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   OPER = { CHANGED(A3BAR,0) | CHANGED(B3BAR,0) |
+            CHANGED(A2BAR,0) | CHANGED(B2BAR,0) |
+            CHANGED(A1BAR,0) | CHANGED(B1BAR,0) |
+            CHANGED(A0BAR,0) | CHANGED(B0BAR,0) }
+   NOTM = { M=='0 }
+   DIF  = { OPER & NOTM & S0=='0 & S1=='1 & S2=='1 & S3=='0 }
+
+ PINDLY:
+   AEQUALB_O = {
+     CASE (
+       DIF  & TRN_HL, DELAY(-1,32NS,48NS),
+       DELAY(-1,35NS,50NS)
+       )
+     }

.ENDS

*$
*-------------------------------------------------------------------------
* 74182  LOOK-AHEAD CARRY GENERATOR
*
* THE TTL DATA BOOK, VOLUME 2, STANDARD, S, LS, TTL; 1985, TI
* JLS   9-17-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74182   G3BAR_I G2BAR_I G1BAR_I G0BAR_I
+ P3BAR_I P2BAR_I P1BAR_I P0BAR_I CN_I GBAR_O PBAR_O CN+X_O CN+Y_O CN+Z_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U182LOG LOGICEXP (9,5) DPWR DGND
+ G3BAR_I G2BAR_I G1BAR_I G0BAR_I P3BAR_I P2BAR_I P1BAR_I P0BAR_I CN_I
+ GBAR PBAR CN+X CN+Y CN+Z
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   G3BAR = { G3BAR_I }
+   G2BAR = { G2BAR_I }
+   G1BAR = { G1BAR_I }
+   G0BAR = { G0BAR_I }
+   P3BAR = { P3BAR_I }
+   P2BAR = { P2BAR_I }
+   P1BAR = { P1BAR_I }
+   P0BAR = { P0BAR_I }
+   CN    = { CN_I }
+   CNBAR = { ~CN }
+   PBAR  = { P0BAR | P1BAR | P2BAR | P3BAR }
+   GBAR  = {    (        G0BAR & G1BAR & G2BAR & G3BAR) |
+                (P1BAR         & G1BAR & G2BAR & G3BAR) |
+                (P2BAR                 & G2BAR & G3BAR) |
+                (P3BAR                         & G3BAR) }
+   CN+Z  = { ~( (CNBAR & G0BAR & G1BAR & G2BAR) |
+                (P0BAR & G0BAR & G1BAR & G2BAR) |
+                (P1BAR         & G1BAR & G2BAR) |
+                (P2BAR                 & G2BAR) ) }
+   CN+Y  = { ~( (CNBAR & G0BAR & G1BAR) |
+                (P0BAR & G0BAR & G1BAR) |
+                (P1BAR         & G1BAR) ) }
+   CN+X  = { ~( (CNBAR & G0BAR) |
+                (P0BAR & G0BAR) ) }
*
U182DLY PINDLY (5,0,0) DPWR DGND
+ GBAR PBAR CN+X CN+Y CN+Z
+
+ GBAR_O PBAR_O CN+X_O CN+Y_O CN+Z_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   GBAR_O PBAR_O CN+X_O CN+Y_O CN+Z_O = {
+     CASE (
+       TRN_LH, DELAY(-1,11NS,17NS),
+       TRN_HL, DELAY(-1,15NS,22NS),
+       DELAY(-1,15NS,22NS)
+       )
+     }
*
.ENDS
*
*$
*--------------------------------------------------------------------------
* 74184  BCD-TO-BINARY CONVERTERS
*
* The TTL Data Book, Vol 2, 1985, TI
* tvh	09/12/89  	Update interface and model names
*
.subckt 74184  GBAR A B C D E Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 bufa(5) DPWR DGND
+	A	B	C	D	E
+	AI	BI	CI	DI	EI
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U2 inva(5) DPWR DGND
+	AI	BI	CI	DI	EI
+	AN	BN	CN	DN	EN
+	D0_GATE IO_STD 
U3 ao(3,3) DPWR DGND
+	AI	CN	DN
+	AN	CN	DI
+	AN	BN	DI
+	X1
+	D_184_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U4 ao(5,6) DPWR DGND
+	AN	BN	EI	$D_HI	$D_HI
+	CN	BN	EI	DN	$D_HI
+	CN	BI	EN	DN	$D_HI
+	CN	BI	AN	EN	$D_HI
+	CN	BN	AI	EN	DI
+	CN	BI	AI	EI	DI
+	X2
+	D_184_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U5 ao(4,5) DPWR DGND
+	AN	BN	CI	DN
+	BI	CN	EI	DN
+	AN	BN	CN	DI
+	BN	CN	EN	DI
+	AN	CN	EN	DI
+	X3
+	D_184_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U6 ao(5,5) DPWR DGND
+	CN	EI	DN	$D_HI	$D_HI
+	AN	BN	CN	EI	$D_HI
+	AN	BN	EI	DN	$D_HI
+	AN	BN	CI	EN	DI
+	AI	BI	CN	EN	DI
+	X4
+	D_184_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U7 ao(5,3) DPWR DGND
+	BI	CN	EI	DI	$D_HI
+	AI	CN	EI	DI	$D_HI
+	AN	BN	CI	EI	DI
+	X5
+	D_184_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U8 ao(4,4) DPWR DGND
+	AN	BN	CN	DI
+	AN	EN	DN	$D_HI
+	AI	BI	EI	DN
+	AN	BN	CI	DN
+	X6
+	D_184_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U9 ao(4,4) DPWR DGND
+	CI	BN	DN	$D_HI
+	CN	BI	EN	DN
+	AN	CI	EI	DN
+	AI	BI	CN	DN
+	X7
+	D_184_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U10 ao(5,3) DPWR DGND
+	CN	BN	EN	DN	$D_HI
+	AI	BN	CN	DN	$D_HI
+	AN	BI	CN	EI	DN
+	X8
+	D_184_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U11 ora(2,8) DPWR DGND
+	GBAR	X1
+	GBAR	X2
+	GBAR	X3
+	GBAR	X4
+	GBAR	X5
+	GBAR	X6
+	GBAR	X7
+	GBAR	X8
+	Y1	Y2	Y3	Y4	Y5	Y6	Y7	Y8
+	D_184_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_184_1 ugate (
+	TPLHTY=8NS	TPHLTY=1NS
+	TPLHMX=10NS	TPHLMX=5NS
+	)
.model D_184_2 ugate (
+	TPLHTY=19NS	TPHLTY=22NS
+	TPLHMX=30NS	TPHLMX=35NS
+	)
*$
*--------------------------------------------------------------------------
* 74185A  BINARY-TO-BCD CONVERTERS
*
* The TTL Data Book, Vol 2, 1985, TI
* tvh	09/12/89  	Update interface and model names
*
.subckt 74185A  GBAR A B C D E Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 bufa(5) DPWR DGND
+	A	B	C	D	E
+	AI	BI	CI	DI	EI
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U2 inva(5) DPWR DGND
+	AI	BI	CI	DI	EI
+	AN	BN	CN	DN	EN
+	D0_GATE IO_STD 
U3 ao(5,10) DPWR DGND
+	AN	BI	CN	EI	$D_HI
+	AN	CN	DN	EI	$D_HI
+	AI	CN	DN	EN	$D_HI
+	AI	CI	DN	EI	$D_HI
+	AI	BI	CI	EI	$D_HI
+	AI	BI	CN	EN	$D_HI
+	AN	BI	CI	DN	EN
+	AI	BN	CI	DI	EN
+	AN	BN	CI	DI	EI
+	AN	BN	CN	DI	EN
+	X1
+	D_185A_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U4 ao(5,8) DPWR DGND
+	BI	CN	DN	EN	$D_HI
+	AI	BI	CI	DN	$D_HI
+	AN	BI	DN	EI	$D_HI
+	AN	BN	CI	DI	$D_HI
+	BN	CI	DI	EN	$D_HI
+	AN	BN	DI	EN	$D_HI
+	AI	BI	CN	DI	EI
+	AI	BN	CN	DN	EI
+	X2
+	D_185A_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U5 ao(5,6) DPWR DGND
+	AN	BN	CI	DN	EN
+	AI	BN	CN	DI	EN
+	AN	BI	CI	DI	EN
+	AN	BN	CN	DI	EI
+	AI	BN	CI	DI	EI
+	AI	BI	CN	DN	EI
+	X3
+	D_185A_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U6 ao(4,8) DPWR DGND
+	CN	DN	EI	$D_HI
+	BI	CN	EI	$D_HI
+	BN	CI	EI	DI
+	AI	CN	EI	$D_HI
+	BN	CN	DI	EN
+	AI	CI	EN	DN
+	BI	CI	EN	DN
+	AI	BI	CI	EN
+	X4
+	D_185A_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U7 ao(3,4) DPWR DGND
+	CN	DN	EI
+	CI	DI	EN
+	BI	DI	EN
+	BI	CI	DI
+	X5
+	D_185A_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U8 ao(2,2) DPWR DGND
+	CI EI EI DI   X6 
+	D_185A_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U9 bufa(2) DPWR DGND
+	$D_HI $D_HI   X7 X8 
+	D_185A_1 IO_STD MNTYMXDLY={MNTYMXDLY} 
U10 ora(2,8) DPWR DGND
+	GBAR	X1
+	GBAR	X2
+	GBAR	X3
+	GBAR	X4
+	GBAR	X5
+	GBAR	X6
+	GBAR	X7
+	GBAR	X8
+	Y1	Y2	Y3	Y4	Y5	Y6	Y7	Y8
+	D_185A_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_185A_1 ugate (
+	TPLHTY=8NS	TPHLTY=1NS
+	TPLHMX=10NS	TPHLMX=5NS
+	)
.model D_185A_2 ugate (
+	TPLHTY=19NS	TPHLTY=22NS
+	TPLHMX=30NS	TPHLMX=35NS
+	)
*
*$
*-------------------------------------------------------------------------
* 74190  Synchronous 4-bit Up/Down Decade Counters 
*
* The TTL Data Book, 1988, TI
* JSW   7/15/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
*
.SUBCKT 74190 CLK_I DUBAR_I CTENBAR_I LOADBAR_I A_I B_I C_I D_I 
+  RCOBAR_O MXMNOUT_O QA_O QB_O QC_O QD_O 
+  OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+  PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U190 LOGICEXP (16,23) DPWR DGND
+ CLK_I DUBAR_I CTENBAR_I LOADBAR_I A_I B_I C_I D_I QA QB QC QD QABAR QBBAR 
+ QCBAR QDBAR
+ CLK CLKBAR DUBAR CTENBAR LOADBAR A B C D MXMNOUT RCOBAR 
+ SA RA JKA SB RB JKB SC RC JKC SD RD JKD
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL} 
+
+ LOGIC:
+   CLK = { CLK_I }
+   CLKBAR = { ~CLK_I }
+   DUBAR = { DUBAR_I }
+   CTENBAR = { CTENBAR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   DU = { ~DUBAR }
+   LOAD = { ~LOADBAR }
+   CTEN = { ~CTENBAR }
+   CTD = { DUBAR & CTEN }
+   CTU = { DU & CTEN }
+   MXMNOUT = { (QA & QD & DU) | (QABAR & QBBAR & QCBAR &  
+     QDBAR & DUBAR) }
+   RCOBAR = { ~(MXMNOUT & CTEN & CLKBAR) }
+   SA = { ~(A & LOAD) }
+   RA = { ~(SA & LOAD) }
+   JKA = { CTEN }
+   SB = { ~(B & LOAD) }
+   RB = { ~(SB & LOAD) }
+   IB = { ~(QBBAR & QCBAR & QDBAR) }
+   JKB = { (CTD & QABAR & IB) | (QA & QDBAR & CTU) }
+   SC = { ~(C & LOAD) }
+   RC = { ~(SC & LOAD) }
+   JKC = { (CTD & QABAR & QBBAR & IB) | (CTU & QB & QA) }
+   SD = { ~(D & LOAD) }
+   RD = { ~(SD & LOAD) }
+   JKD = { (CTD & QABAR & QBBAR & QCBAR) | (CTU & QD & QA) |
+     (CTU & QC & QB & QA) }
*
UJKFFA JKFF(1) DPWR DGND SA RA CLKBAR JKA JKA QA QABAR D0_EFF IO_STD
UJKFFB JKFF(1) DPWR DGND SB RB CLKBAR JKB JKB QB QBBAR D0_EFF IO_STD
UJKFFC JKFF(1) DPWR DGND SC RC CLKBAR JKC JKC QC QCBAR D0_EFF IO_STD
UJKFFD JKFF(1) DPWR DGND SD RD CLKBAR JKD JKD QD QDBAR D0_EFF IO_STD
*
U190DLY PINDLY (6,0,8) DPWR DGND
+ QA QB QC QD RCOBAR MXMNOUT
+ A B C D CLK DUBAR LOADBAR CTENBAR
+ QA_O QB_O QC_O QD_O RCOBAR_O MXMNOUT_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   ABCD = { (CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0))
+     & LOADBAR!='1 }
+   CLOCK_LH = { CHANGED_LH(CLK,0) & TRN_LH }
+   CLOCK_HL = { CHANGED_LH(CLK,0) & TRN_HL }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       ABCD & TRN_LH, DELAY(-1,14NS,22NS),
+       CLOCK_LH, DELAY(-1,16NS,24NS),
+       CHANGED_HL(LOADBAR,0) & TRN_LH, DELAY(-1,22NS,33NS),
+       CLOCK_HL, DELAY(-1,24NS,36NS),
+       CHANGED_HL(LOADBAR,0) & TRN_HL, DELAY(-1,33NS,50NS),
+       ABCD & TRN_HL, DELAY(-1,35NS,50NS),
+       DELAY(-1,35NS,50NS)
+       )
+     }
+   RCOBAR_O = {
+     CASE(
+       CLOCK_LH, DELAY(-1,13NS,20NS),
+       CHANGED(CLK,0) & TRN_HL, DELAY(-1,16NS,24NS),
+       CHANGED(DUBAR,0), DELAY(-1,30NS,45NS),
+       DELAY(-1,30NS,45NS)
+       )
+     }
+   MXMNOUT_O = {
+     CASE(
+       CHANGED(DUBAR,0) & TRN_LH, DELAY(-1,21NS,33NS),
+       CHANGED(DUBAR,0) & TRN_HL, DELAY(-1,22NS,33NS),
+       CLOCK_LH, DELAY(-1,28NS,42NS),
+       CLOCK_HL, DELAY(-1,37NS,52NS),
+       DELAY(-1,37NS,52NS)
+       )
+     }
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 20MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 25NS
+   MIN_HI = 25NS
+ WIDTH:
+   NODE = LOADBAR
+   MIN_LO = 35NS
+ SETUP_HOLD:
+   DATA(1) CTENBAR
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { LOADBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) DUBAR
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { LOADBAR!='0 & (CTENBAR!='1 ^ CHANGED(CTENBAR,0)) }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = CLK
+   RELEASETIME_LH = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = LOADBAR
+   SETUPTIME = 20NS
*
.ENDS
*
*$
*-------------------------------------------------------------------------
*  74191  Synchronous 4-bit Up/Down Binary Counters 
*
*  THE TTL DATA BOOK, 1988, TI
*  tc   7/23/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
*
.SUBCKT 74191 CLK_I DUBAR_I CTENBAR_I LOADBAR_I A_I B_I C_I D_I
+ RCOBAR_O MXMNOUT_O QA_O QB_O QC_O QD_O 
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(1) DPWR DGND SA RA MCLK JKA JKA QA QABAR
+ D0_EFF IO_STD
U2 JKFF(1) DPWR DGND SB RB MCLK JKB JKB QB QBBAR
+ D0_EFF IO_STD
U3 JKFF(1) DPWR DGND SC RC MCLK JKC JKC QC QCBAR
+ D0_EFF IO_STD
U4 JKFF(1) DPWR DGND SD RD MCLK JKD JKD QD QDBAR
+ D0_EFF IO_STD
*
U191LOG LOGICEXP (16,23) DPWR DGND
+ CLK_I DUBAR_I CTENBAR_I LOADBAR_I A_I B_I C_I D_I QA QB QC QD
+ QABAR QBBAR QCBAR QDBAR
+ CLK DUBAR CTENBAR LOADBAR A B C D MXMNOUT RCOBAR MCLK
+ SA RA JKA SB RB JKB SC RC JKC SD RD JKD
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLK = { CLK_I }
+   DUBAR = { DUBAR_I }
+   CTENBAR = { CTENBAR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   IEN1 = { ~(DUBAR | CTENBAR) }
+   IEN2 = { ~(CTENBAR | ~DUBAR) }
+   ILD = { ~LOADBAR }
+   IM1 = { ~DUBAR & QA & QB & QC & QD }
+   IM2 = { DUBAR & QABAR & QBBAR & QCBAR & QDBAR }
+   IC1 = { IEN2 & QABAR & QBBAR }
+   IC2 = { IEN1 & QA & QB }
+   ID1 = { IEN2 & QABAR & QBBAR & QCBAR }
+   ID2 = { IEN1 & QA & QB & QC }
+   MCLK = { ~CLK }
+   SA = { ~(A & ILD) }
+   RA = { ~(SA & ILD) }
+   SB = { ~(B & ILD) }
+   RB = { ~(SB & ILD) }
+   SC = { ~(C & ILD) }
+   RC = { ~(SC & ILD) }
+   SD = { ~(D & ILD) }
+   RD = { ~(SD & ILD) }
+   JKA = { ~CTENBAR }
+   JKB = { (IEN2 & QABAR) | (QA & IEN1) }
+   JKC = { IC1 | IC2 }
+   JKD = { ID1 | ID2 }
+   MXMNOUT = { IM1 | IM2 }
+   RCOBAR = { ~(MCLK & JKA & MXMNOUT) }
*
U191DLY PINDLY (6,0,8) DPWR DGND
+ QA QB QC QD RCOBAR MXMNOUT
+ A B C D CLK DUBAR LOADBAR CTENBAR
+ QA_O QB_O QC_O QD_O RCOBAR_O MXMNOUT_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = { CHANGED_LH(CLK,0) }
+   DATA = { (CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0))
+     & LOADBAR!='1 }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       DATA & TRN_LH, DELAY(-1,14NS,22NS),
+       CLOCK & TRN_LH, DELAY(-1,16NS,24NS),
+       CHANGED_HL(LOADBAR,0) & TRN_LH, DELAY(-1,22NS,33NS),
+       CLOCK & TRN_HL, DELAY(-1,24NS,36NS),
+       CHANGED_HL(LOADBAR,0) & TRN_HL, DELAY(-1,33NS,50NS),
+       DATA & TRN_HL, DELAY(-1,35NS,50NS),
+       DELAY(-1,35NS,50NS)
+       )
+     }
+   RCOBAR_O = {
+     CASE(
+       CHANGED(CLK,0) & TRN_LH, DELAY(-1,13NS,20NS),
+       CHANGED(CLK,0) & TRN_HL, DELAY(-1,16NS,24NS),
+       CHANGED(DUBAR,0), DELAY(-1,30NS,45NS),
+       DELAY(-1,30NS,45NS)
+       )
+     }
+   MXMNOUT_O = {
+     CASE(
+       CHANGED(DUBAR,0) & TRN_LH, DELAY(-1,21NS,33NS),
+       CHANGED(DUBAR,0) & TRN_HL, DELAY(-1,22NS,33NS),
+       CLOCK & TRN_LH, DELAY(-1,28NS,42NS),
+       CLOCK & TRN_HL, DELAY(-1,37NS,52NS),
+       DELAY(-1,37NS,52NS)
+       )
+     }
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 20MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 25NS
+   MIN_HI = 25NS
+ WIDTH:
+   NODE = LOADBAR
+   MIN_LO = 35NS
+ SETUP_HOLD:
+   DATA(1) = CTENBAR
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { LOADBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = DUBAR
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { LOADBAR!='0 & (CTENBAR!='1 ^ CHANGED(CTENBAR,0)) }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = CLK
+   RELEASETIME_LH = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = LOADBAR
+   SETUPTIME = 20NS
*
.ENDS
*
*$
*---------------------------------------------------------------------------
*  74192  Synchronous 4-bit Up/Down Decade Counters (Dual clock w/ clear) 
*
*  THE TTL DATA BOOK, 1988, TI
*  JSW   7/30/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
*
.SUBCKT 74192 UP_I DOWN_I CLR_I LOADBAR_I A_I B_I C_I D_I 
+ QA_O QB_O QC_O QD_O BOBAR_O COBAR_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(1) DPWR DGND SA RA TA $D_HI $D_HI QA QABAR
+ D0_EFF IO_STD
U2 JKFF(1) DPWR DGND SB RB TB $D_HI $D_HI QB QBBAR
+ D0_EFF IO_STD
U3 JKFF(1) DPWR DGND SC RC TC $D_HI $D_HI QC QCBAR
+ D0_EFF IO_STD
U4 JKFF(1) DPWR DGND SD RD TD $D_HI $D_HI QD QDBAR
+ D0_EFF IO_STD
*
U192LOG LOGICEXP (16,23) DPWR DGND
+ UP_I DOWN_I CLR_I LOADBAR_I A_I B_I C_I D_I QA QB QC QD QABAR QBBAR QCBAR 
+ QDBAR
+ UP DOWN CLR LOADBAR A B C D TA TB TC TD BOBAR COBAR MCLR
+ SA RA SB RB SC RC SD RD
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   UP = { UP_I }
+   DOWN = { DOWN_I }
+   CLR = { CLR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   ID = { ~DOWN }
+   IU = { ~UP }
+   ILD = { ~LOADBAR }
+   MCLR = { ~CLR }
+   IN1 = { ~(QBBAR & QCBAR & QDBAR) }
+   TA = { ID | IU }
+   TB = { (ID & QABAR & IN1) | (IU & QA & QDBAR) }
+   TC = { (ID & QABAR & QBBAR & IN1) | (IU & QA & QB) }
+   TD = { (ID & QABAR & QBBAR & QCBAR) | (IU & QD & QA ) | 
+     (IU & QA & QB & QC) }
+   SA = { ~(A & ILD & MCLR) }
+   RA = { MCLR & ~(SA & ILD) }
+   SB = { ~(B & ILD & MCLR) }
+   RB = { MCLR & ~(SB & ILD) }
+   SC = { ~(C & ILD & MCLR) }
+   RC = { MCLR & ~(SC & ILD) }
+   SD = { ~(D & ILD & MCLR) }
+   RD = { MCLR & ~(SD & ILD) }
+   BOBAR = { ~(ID & QABAR & QBBAR & QCBAR & QDBAR) }
+   COBAR = { ~(IU & QA & QD) }
*
U192DLY PINDLY (6,0,8) DPWR DGND
+ QA QB QC QD BOBAR COBAR
+ UP DOWN LOADBAR CLR A B C D
+ QA_O QB_O QC_O QD_O BOBAR_O COBAR_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   UPDN = { (CHANGED_LH(UP,0) | CHANGED_LH(DOWN,0)) & LOADBAR!='0
+     & CLR!='1 }
+   CLEAR = { CHANGED_LH(CLR,0) }
+   LOAD = { CHANGED_HL(LOADBAR,0) }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CLEAR, DELAY(-1,22NS,35NS),
+       UPDN & TRN_LH, DELAY(-1,25NS,38NS),
+       LOAD & TRN_LH, DELAY(-1,27NS,40NS),
+       LOAD & TRN_HL, DELAY(-1,29NS,40NS),
+       UPDN & TRN_HL, DELAY(-1,31NS,47NS),
+       DELAY(-1,31NS,47NS)
+       )
+     }
+   BOBAR_O = {
+     CASE(
+       CHANGED(DOWN,0), DELAY(-1,16NS,24NS),
+       CLEAR, DELAY(-1,22NS,35NS),
+       LOAD & TRN_LH, DELAY(27NS,-1,40NS),
+       LOAD & TRN_HL, DELAY(29NS,-1,40NS),
+       DELAY(29NS,-1,40NS)
+       )
+     }
+   COBAR_O = {
+     CASE(
+       CHANGED(UP,0) & TRN_HL, DELAY(-1,16NS,24NS),
+       CHANGED(UP,0) & TRN_LH, DELAY(-1,17NS,26NS),
+       CLEAR, DELAY(-1,22NS,35NS),
+       LOAD & TRN_LH, DELAY(27NS,-1,40NS),
+       LOAD & TRN_HL, DELAY(29NS,-1,40NS),
+       DELAY(29NS,-1,40NS)
+       )
+     }
+ FREQ:
+   NODE = UP
+   MAXFREQ = 25MEG
+ FREQ:
+   NODE = DOWN
+   MAXFREQ = 25MEG
+ WIDTH:
+   NODE = UP
+   MIN_LO = 20NS
+   MIN_HI = 20NS
+ WIDTH:
+   NODE = DOWN
+   MIN_LO = 20NS
+   MIN_HI = 20NS
+ WIDTH:
+   NODE = LOADBAR
+   MIN_LO = 20NS
+   WHEN = { CLR!='1 }
+ WIDTH:
+   NODE = CLR
+   MIN_HI = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = LOADBAR
+   SETUPTIME = 20NS
+   WHEN = { CLR!='1 }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
*  74193  Synchronous 4-bit Up/Down Binary Counters (Dual clock w/ clear) 
*
*  THE TTL DATA BOOK, 1988, TI
*  tc   7/27/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
*
* NOTE: The hold time for LOADBAR given in the data sheet is not relevant
*       to modeling this device and therefore is left out.
*       The propagation delay from LOADBAR and CLR to COBAR and BOBAR was
*       assumed to be the same as the LOADBAR and CLR to Q delay.
*
.SUBCKT 74193 UP_I DOWN_I CLR_I LOADBAR_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O BOBAR_O COBAR_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(1) DPWR DGND SA RA TA $D_HI $D_HI QA QABAR
+ D0_EFF IO_STD
U2 JKFF(1) DPWR DGND SB RB TB $D_HI $D_HI QB QBBAR
+ D0_EFF IO_STD
U3 JKFF(1) DPWR DGND SC RC TC $D_HI $D_HI QC QCBAR
+ D0_EFF IO_STD
U4 JKFF(1) DPWR DGND SD RD TD $D_HI $D_HI QD QDBAR
+ D0_EFF IO_STD
*
U193LOG LOGICEXP (16,23) DPWR DGND
+ UP_I DOWN_I CLR_I LOADBAR_I A_I B_I C_I D_I QA QB QC QD
+ QABAR QBBAR QCBAR QDBAR
+ UP DOWN CLR LOADBAR A B C D TA TB TC TD BOBAR COBAR MCLR
+ SA RA SB RB SC RC SD RD
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   UP = { UP_I }
+   DOWN = { DOWN_I }
+   CLR = { CLR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   ID = { ~DOWN }
+   IU = { ~UP }
+   ILD = { ~LOADBAR }
+   MCLR = { ~CLR }
+   TA = { ID | IU }
+   TB = { (ID & QABAR) | (IU & QA) }
+   TC = { (ID & QABAR & QBBAR) | (IU & QA & QB) }
+   TD = { (ID & QABAR & QBBAR & QCBAR) | (IU & QA & QB & QC) }
+   SA = { ~(A & ILD & MCLR) }
+   RA = { MCLR & ~(SA & ILD) }
+   SB = { ~(B & ILD & MCLR) }
+   RB = { MCLR & ~(SB & ILD) }
+   SC = { ~(C & ILD & MCLR) }
+   RC = { MCLR & ~(SC & ILD) }
+   SD = { ~(D & ILD & MCLR) }
+   RD = { MCLR & ~(SD & ILD) }
+   BOBAR = { ~(ID & QABAR & QBBAR & QCBAR & QDBAR) }
+   COBAR = { ~(IU & QA & QB & QC & QD) }
*
U193DLY PINDLY (6,0,8) DPWR DGND
+ QA QB QC QD BOBAR COBAR
+ UP DOWN LOADBAR CLR A B C D
+ QA_O QB_O QC_O QD_O BOBAR_O COBAR_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   UPDN = { (CHANGED_LH(UP,0) | CHANGED_LH(DOWN,0)) & LOADBAR!='0
+     & CLR!='1 }
+   CLEAR = { CHANGED_LH(CLR,0) }
+   LOAD = { CHANGED_HL(LOADBAR,0) }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CLEAR        , DELAY(-1,22NS,35NS),
+       UPDN & TRN_LH, DELAY(-1,25NS,38NS),
+       LOAD & TRN_LH, DELAY(-1,27NS,40NS),
+       LOAD & TRN_HL, DELAY(-1,29NS,40NS),
+       UPDN & TRN_HL, DELAY(-1,31NS,47NS),
+       DELAY(-1,31NS,47NS)
+       )
+     }
+   BOBAR_O = {
+     CASE(
+       CHANGED(DOWN,0),   DELAY(-1,16NS,24NS),
+       CLEAR, DELAY(-1,22NS,35NS),
+       LOAD & TRN_LH, DELAY(-1,27NS,40NS),
+       LOAD & TRN_HL, DELAY(-1,29NS,40NS),
+       DELAY(-1,29NS,40NS)
+       )
+     }
+   COBAR_O = {
+     CASE(
+       CHANGED(UP,0) & TRN_HL, DELAY(-1,16NS,24NS),
+       CHANGED(UP,0) & TRN_LH, DELAY(-1,17NS,26NS),
+       CLEAR, DELAY(-1,22NS,35NS),
+       LOAD & TRN_LH, DELAY(-1,27NS,40NS),
+       LOAD & TRN_HL, DELAY(-1,29NS,40NS),
+       DELAY(-1,29NS,40NS)
+       )
+     }
+ FREQ:
+   NODE = UP
+   MAXFREQ = 25MEG
+ FREQ:
+   NODE = DOWN
+   MAXFREQ = 25MEG
+ WIDTH:
+   NODE = UP
+   MIN_LO = 20NS
+   MIN_HI = 20NS
+ WIDTH:
+   NODE = DOWN
+   MIN_LO = 20NS
+   MIN_HI = 20NS
+ WIDTH:
+   NODE = LOADBAR
+   MIN_LO = 20NS
+   WHEN = { CLR!='1 }
+ WIDTH:
+   NODE = CLR
+   MIN_HI = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = LOADBAR
+   SETUPTIME = 20NS
+   WHEN = { CLR!='1 }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74194  4-BIT BIDIRECTIONAL UNIVERSAL SHIFT REGISTERS
*
* THE TTL DATA BOOK, VOL 2, 1988, TI
* NH 7/7/92          REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74194 CLK_I CLRBAR_I S1_I S0_I SL_I SR_I A_I B_I C_I D_I
+             QA_O QB_O QC_O QD_O
+       OPTIONAL: DPWR = $G_DPWR   DGND = $G_DGND
+       PARAMS:   MNTYMXDLY = 0    IO_LEVEL = 0
*
U194LOG LOGICEXP(14,19) DPWR DGND
+ CLK_I CLRBAR_I S1_I S0_I SL_I SR_I A_I B_I C_I D_I QA QB QC QD
+ CLK CLRBAR S1 S0 SL SR A B C D KA KB KC KD JA JB JC JD CLOCK
+ D0_GATE  IO_STD  IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
*
* INTERMEDIATE TERM
+   S0BAR = { ~S0_I }
+   S1BAR = { ~S1_I }
+   MODE = { ~( S0BAR | S1BAR ) }
*
* OUTPUT ASSIGNMENT
*
+   CLK = { CLK_I }
+   CLRBAR = { CLRBAR_I }
+   S1 = { S1_I }
+   S0 = { S0_I }
+   SL = { SL_I }
+   SR = { SR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+
+   KA = { ~( (SR & S1BAR) | (MODE & A) | (S0BAR & QB) ) }
+   KB = { ~( (QA & S1BAR) | (MODE & B) | (S0BAR & QC) ) }
+   KC = { ~( (QB & S1BAR) | (MODE & C) | (S0BAR & QD) ) }
+   KD = { ~( (QC & S1BAR) | (MODE & D) | (S0BAR & SL) ) }
+   JA = { ~KA }
+   JB = { ~KB }
+   JC = { ~KC }
+   JD = { ~KD }
+   CLOCK = { ~( (S0BAR & S1BAR) | CLK ) }
*
U1 JKFF(4) DPWR DGND $D_HI CLRBAR CLOCK JA JB JC JD KA KB KC KD
+ QA QB QC QD $D_NC $D_NC $D-NC $D_NC
+ D0_EFF  IO_STD
*
U194DLY PINDLY (4,0,10) DPWR DGND
+ QA QB QC QD
+ CLK CLRBAR S0 S1 SL SR A B C D
+ QA_O QB_O QC_O QD_O
+ IO_STD
+ MNTYMXDLY = {MNTYMXDLY}   IO_LEVEL = {IO_LEVEL}
+
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CHANGED_LH(CLK,0) & TRN_LH, DELAY(-1,14NS,22NS),
+       CHANGED_LH(CLK,0) & TRN_HL, DELAY(-1,17NS,26NS),
+       CHANGED_HL(CLRBAR,0), DELAY(-1,19NS,30NS),
+       DELAY(8NS,20NS,31NS)          ;DEFAULT
+       )
+     }
+
+ BOOLEAN:
+   NOT_CLEAR = { CLRBAR!='0 }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 20NS
+   MIN_LO = 20NS
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+
+ SETUP_HOLD:
+   DATA(2) S0 S1
+   CLOCK LH = CLK
+   SETUPTIME = 30NS
+   WHEN = { NOT_CLEAR }
+
+ SETUP_HOLD:
+   DATA(1) SL
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { NOT_CLEAR & (S1!='0 ^ CHANGED(S1,0)) & (S0!='1 ^ CHANGED(S0,0)) }
+
+ SETUP_HOLD:
+   DATA(1) SR
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { NOT_CLEAR & (S1!='1 ^ CHANGED(S1,0)) & (S0!='0 ^ CHANGED(S0,0)) }
+
+ SETUP_HOLD:
+   DATA(4) A B C D
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { NOT_CLEAR & (S1!='0 ^ CHANGED(S1,0)) & (S0!='0 ^ CHANGED(S0,0)) }
+
+ SETUP_HOLD:
+   DATA(1) CLRBAR
+   CLOCK LH = CLK
+   RELEASETIME_LH = 25NS
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74195  4-BIT PARALLEL-ACCESS SHIFT REGISTERS
*
* THE TTL DATA BOOK, VOL 2, 1988, STANDARD, LS, S, TI
* NH 7/2/92          REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74195 CLK_I SH/LDBAR_I CLRBAR_I J_I KBAR_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O QDBAR_O
+ OPTIONAL: DPWR = $G_DPWR   DGND = $G_DGND
+ PARAMS:   MNTYMXDLY = 0   IO_LEVEL = 0
*
U195LOG LOGICEXP(13,18) DPWR DGND
+ CLK_I SH/LDBAR_I CLRBAR_I J_I KBAR_I A_I B_I C_I D_I QA QB QC QABAR
+ CLK SH/LDBAR CLRBAR J KBAR A B C D KA KB KC KD JA JB JC JD CLOCK
+ D0_GATE  IO_STD  IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
+   CLK = { CLK_I }
+   SH/LDBAR = { SH/LDBAR_I }
+   CLRBAR = { CLRBAR_I }
+   J = { J_I }
+   KBAR = { KBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+
* INTERMEDIATE TERM
+   LOAD = { ~SH/LDBAR }
+
+   KA = { ~((QABAR & J & SH/LDBAR) | (SH/LDBAR & KBAR & QA) | (LOAD & A)) }
+   KB = { ~( (QA & SH/LDBAR) | (LOAD & B) ) }
+   KC = { ~( (QB & SH/LDBAR) | (LOAD & C) ) }
+   KD = { ~( (QC & SH/LDBAR) | (LOAD & D) ) }
+   JA = { ~KA }
+   JB = { ~KB }
+   JC = { ~KC }
+   JD = { ~KD }
+   CLOCK = { ~(CLK & CLRBAR) }
*
U1 JKFF(4) DPWR DGND $D_HI CLRBAR CLOCK JA JB JC JD KA KB KC KD
+ QA QB QC QD QABAR $D_NC $D_NC QDBAR
+ D0_EFF   IO_STD
*
U195DLY PINDLY (5,0,9) DPWR DGND
+ QA QB QC QD QDBAR
+ CLK CLRBAR SH/LDBAR J KBAR A B C D
+ QA_O QB_O QC_O QD_O QDBAR_O
+ IO_STD
+ MNTYMXDLY = {MNTYMXDLY}   IO_LEVEL = {IO_LEVEL}
+
+ PINDLY:
+   QA_O QB_O QC_O QD_O QDBAR_O = {
+     CASE(
+       CHANGED_LH(CLK,0) & TRN_LH, DELAY(-1,14NS,22NS),
+       CHANGED_LH(CLK,0) & TRN_HL, DELAY(-1,17NS,26NS),
+       CHANGED_HL(CLRBAR,0) & TRN_HL, DELAY(-1,19NS,30NS),
+       DELAY(-1,20NS,31NS)            ;DEFAULT
+       )
+     }
+
+ BOOLEAN:
+   NOT_CLEAR = { CLRBAR!='0 }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 30MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 16NS
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 12NS
+
+ SETUP_HOLD:
+   DATA(1) SH/LDBAR
+   CLOCK LH = CLK
+   SETUPTIME_LO = 25NS
+   SETUPTIME_HI = 10NS
+   WHEN = { NOT_CLEAR }
+
+ SETUP_HOLD:
+   DATA(1) CLRBAR
+   CLOCK LH = CLK
+   RELEASETIME_LH = 25NS
+
+ SETUP_HOLD:                          ;SHIFT MODE
+   DATA(2) J KBAR                     ;CHECK WHEN SH/LDBAR = 1 OR
+   CLOCK LH = CLK                     ;AT THE TRANSITION FROM H TO L
+   SETUPTIME = 20NS
+   WHEN = { NOT_CLEAR & (SH/LDBAR!='0 ^ CHANGED(SH/LDBAR,0)) }
+
+ SETUP_HOLD:                          ;LOAD MODE
+   DATA(4) A B C D                    ;CHECK WHEN SH/LDBAR = 0 OR
+   CLOCK LH = CLK                     ;AT THE TRANSITION FROM L TO H
+   SETUPTIME = 20NS
+   WHEN = { NOT_CLEAR & (SH/LDBAR!='1 ^ CHANGED(SH/LDBAR,0)) }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74196  4-Bit Presettable Decade Counter/Latch 
*
* The TTL Data Book, 1988, TI
* JSW   8/3/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
*
.SUBCKT 74196 LOADBAR_I CLRBAR_I CLK1_I CLK2_I A_I B_I C_I D_I 
+ QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
* 
U196LOG LOGICEXP(10,17) DPWR DGND
+ LOADBAR_I CLRBAR_I CLK1_I CLK2_I A_I B_I C_I D_I QB QC
+ LOADBAR CLRBAR CLK1 CLK2 A B C D JD SA SB SC SD RA RB RC RD
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   LOADBAR = { LOADBAR_I }
+   CLRBAR = { CLRBAR_I }
+   CLK1 = { CLK1_I }
+   CLK2 = { CLK2_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   LOAD = { ~CLRBAR | ~LOADBAR }
+   SA = { ~(A & LOAD & CLRBAR) }
+   SB = { ~(B & LOAD & CLRBAR) }
+   SC = { ~(C & LOAD & CLRBAR) }
+   SD = { ~(D & LOAD & CLRBAR) }
+   RA = { ~(SA & LOAD) }
+   RB = { ~(SB & LOAD) }
+   RC = { ~(SC & LOAD) }
+   RD = { ~(SD & LOAD) }
+   JD = { QB & QC }
*
UJK1 JKFF(1) DPWR DGND SA RA CLK1 $D_HI $D_HI QA $D_NC D0_EFF IO_STD
UJK2 JKFF(1) DPWR DGND SB RB CLK2 QDBAR QDBAR QB $D_NC D0_EFF IO_STD
UJK3 JKFF(1) DPWR DGND SC RC QB $D_HI $D_HI QC $D_NC D0_EFF IO_STD
UJK4 JKFF(1) DPWR DGND SD RD CLK2 JD QD QD QDBAR D0_EFF IO_STD
*
U196DLY PINDLY (4,0,8) DPWR DGND
+ QA QB QC QD
+ CLK1 CLK2 A B C D LOADBAR CLRBAR
+ QA_O QB_O QC_O QD_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLEAR = { CHANGED(CLRBAR,0) }
+   LOAD = { CHANGED(LOADBAR,0) }
+   CLOCK1 = { CHANGED_HL(CLK1,0) }
+   CLOCK2 = { CHANGED_HL(CLK2,0) }
+ PINDLY:
+   QA_O = {
+     CASE(
+       CLOCK1 & TRN_LH, DELAY(-1,7NS,12NS),
+       CLOCK1 & TRN_HL, DELAY(-1,10NS,15NS),
+       CHANGED(A,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,16NS,24NS),
+       LOAD & TRN_LH, DELAY(-1,22NS,33NS),
+       LOAD & TRN_HL, DELAY(-1,24NS,36NS),
+       CLEAR, DELAY(-1,25NS,37NS),
+       CHANGED(A,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,25NS,38NS),
+       DELAY(-1,25NS,38NS)
+       )
+     }
+   QB_O = {
+     CASE(
+       CLOCK2 & TRN_LH, DELAY(-1,12NS,18NS),
+       CLOCK2 & TRN_HL, DELAY(-1,14NS,21NS),
+       CHANGED(B,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,16NS,24NS),
+       LOAD & TRN_LH, DELAY(-1,22NS,33NS),
+       LOAD & TRN_HL, DELAY(-1,24NS,36NS),
+       CLEAR, DELAY(-1,25NS,37NS),
+       CHANGED(B,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,25NS,38NS),
+       DELAY(-1,25NS,38NS)
+       )
+     }
+   QC_O = {
+     CASE(
+       CHANGED(C,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,16NS,24NS),
+       LOAD & TRN_LH, DELAY(-1,22NS,33NS),
+       LOAD & TRN_HL, DELAY(-1,24NS,36NS),
+       CLOCK2 & TRN_LH, DELAY(-1,24NS,36NS),
+       CLEAR, DELAY(-1,25NS,37NS),
+       CHANGED(C,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,25NS,38NS),
+       CLOCK2 & TRN_HL, DELAY(-1,28NS,42NS),
+       DELAY(-1,28NS,42NS)
+       )
+     }
+   QD_O = {
+     CASE(
+       CLOCK2 & TRN_HL, DELAY(-1,12NS,18NS),
+       CLOCK2 & TRN_LH, DELAY(-1,14NS,21NS),
+       CHANGED(D,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,16NS,24NS),
+       LOAD & TRN_LH, DELAY(-1,22NS,33NS),
+       LOAD & TRN_HL, DELAY(-1,24NS,36NS),
+       CLEAR, DELAY(-1,25NS,37NS),
+       CHANGED(D,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,25NS,38NS),
+       DELAY(-1,25NS,38NS)
+       )
+     }
+ FREQ:
+   NODE = CLK1
+   MAXFREQ = 50MEG
+ FREQ:
+   NODE = CLK2
+   MAXFREQ = 25MEG
+ WIDTH:
+   NODE = CLK1
+   MIN_LO = 10NS
+   MIN_HI = 10NS
+ WIDTH:
+   NODE = CLK2
+   MIN_LO = 20NS
+   MIN_HI = 20NS
+ WIDTH:
+   NODE = LOADBAR
+   MIN_LO = 20NS
+   WHEN = { CLRBAR!='0 }
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 15NS
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK HL = CLK1
+   RELEASETIME_LH = 20NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK HL = CLK2
+   RELEASETIME_LH = 20NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK HL = CLK1
+   RELEASETIME_LH = 20NS
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK HL = CLK2
+   RELEASETIME_LH = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK HL = LOADBAR
+   SETUPTIME_HI = 10NS
+   SETUPTIME_LO = 15NS
+   HOLDTIME = 20NS
+ GENERAL:
+   WHEN = { LOADBAR=='0 & (CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0)
+     | CHANGED(D,0)) }
+   MESSAGE = "Invalid hold time of DATA with respect to LOADBAR."
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74197  4-Bit Presettable Binary Counter/Latch
*
* The TTL Data Book, 1988, TI
* JSW   7/31/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices
*
.SUBCKT 74197 LOADBAR_I CLRBAR_I CLK1_I CLK2_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U197LOG LOGICEXP(8,16) DPWR DGND
+ LOADBAR_I CLRBAR_I CLK1_I CLK2_I A_I B_I C_I D_I
+ LOADBAR CLRBAR CLK1 CLK2 A B C D SA SB SC SD RA RB RC RD
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   LOADBAR = { LOADBAR_I }
+   CLRBAR = { CLRBAR_I }
+   CLK1 = { CLK1_I }
+   CLK2 = { CLK2_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   LOAD = { ~CLRBAR | ~LOADBAR }
+   SA = { ~(A & LOAD & CLRBAR) }
+   SB = { ~(B & LOAD & CLRBAR) }
+   SC = { ~(C & LOAD & CLRBAR) }
+   SD = { ~(D & LOAD & CLRBAR) }
+   RA = { ~(SA & LOAD) }
+   RB = { ~(SB & LOAD) }
+   RC = { ~(SC & LOAD) }
+   RD = { ~(SD & LOAD) }
*
UJK1 JKFF(1) DPWR DGND SA RA CLK1 $D_HI $D_HI QA $D_NC D0_EFF IO_STD
UJK2 JKFF(1) DPWR DGND SB RB CLK2 $D_HI $D_HI QB $D_NC D0_EFF IO_STD
UJK3 JKFF(1) DPWR DGND SC RC QB $D_HI $D_HI QC $D_NC D0_EFF IO_STD
UJK4 JKFF(1) DPWR DGND SD RD QC $D_HI $D_HI QD $D_NC    D0_EFF IO_STD
*
U197DLY PINDLY (4,0,8) DPWR DGND
+ QA QB QC QD
+ CLK1 CLK2 A B C D LOADBAR CLRBAR
+ QA_O QB_O QC_O QD_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLEAR = { CHANGED(CLRBAR,0) }
+   LOAD = { CHANGED(LOADBAR,0) }
+   CLOCK1 = { CHANGED_HL(CLK1,0) }
+   CLOCK2 = { CHANGED_HL(CLK2,0) }
+ PINDLY:
+   QA_O = {
+     CASE(
+       CLOCK1 & TRN_LH, DELAY(-1,7NS,12NS),
+       CLOCK1 & TRN_HL, DELAY(-1,10NS,15NS),
+       CHANGED(A,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,16NS,24NS),
+       LOAD & TRN_LH, DELAY(-1,22NS,33NS),
+       LOAD & TRN_HL, DELAY(-1,24NS,36NS),
+       CLEAR, DELAY(-1,25NS,37NS),
+       CHANGED(A,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,25NS,38NS),
+       DELAY(-1,25NS,38NS)
+       )
+     }
+   QB_O = {
+     CASE(
+       CLOCK2 & TRN_LH, DELAY(-1,12NS,18NS),
+       CLOCK2 & TRN_HL, DELAY(-1,14NS,21NS),
+       CHANGED(B,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,16NS,24NS),
+       LOAD & TRN_LH, DELAY(-1,22NS,33NS),
+       LOAD & TRN_HL, DELAY(-1,24NS,36NS),
+       CLEAR, DELAY(-1,25NS,37NS),
+       CHANGED(B,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,25NS,38NS),
+       DELAY(-1,25NS,38NS)
+       )
+     }
+   QC_O = {
+     CASE(
+       CHANGED(C,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,16NS,24NS),
+       LOAD & TRN_LH, DELAY(-1,22NS,33NS),
+       LOAD & TRN_HL, DELAY(-1,24NS,36NS),
+       CLOCK2 & TRN_LH, DELAY(-1,24NS,36NS),
+       CLEAR, DELAY(-1,25NS,37NS),
+       CHANGED(C,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,25NS,38NS),
+       CLOCK2 & TRN_HL, DELAY(-1,28NS,42NS),
+       DELAY(-1,28NS,42NS)
+       )
+     }
+   QD_O = {
+     CASE(
+       CHANGED(D,0) & LOADBAR!='1 & TRN_LH, DELAY(-1,16NS,24NS),
+       LOAD & TRN_LH, DELAY(-1,22NS,33NS),
+       LOAD & TRN_HL, DELAY(-1,24NS,36NS),
+       CLEAR, DELAY(-1,25NS,37NS),
+       CHANGED(D,0) & LOADBAR!='1 & TRN_HL, DELAY(-1,25NS,38NS),
+       CLOCK2 & TRN_LH, DELAY(-1,36NS,54NS),
+       CLOCK2 & TRN_HL, DELAY(-1,42NS,63NS),
+       DELAY(-1,42NS,63NS)
+       )
+     }
+ FREQ:
+   NODE = CLK1
+   MAXFREQ = 50MEG
+ FREQ:
+   NODE = CLK2
+   MAXFREQ = 25MEG
+ WIDTH:
+   NODE = CLK1
+   MIN_LO = 10NS
+   MIN_HI = 10NS
+ WIDTH:
+   NODE = CLK2
+   MIN_LO = 20NS
+   MIN_HI = 20NS
+ WIDTH:
+   NODE = LOADBAR
+   MIN_LO = 20NS
+   WHEN = { CLRBAR!='0 }
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 15NS
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK HL = CLK1
+   RELEASETIME_LH = 20NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK HL = CLK2
+   RELEASETIME_LH = 20NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK HL = CLK1
+   RELEASETIME_LH = 20NS
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK HL = CLK2
+   RELEASETIME_LH = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK HL = LOADBAR
+   SETUPTIME_HI = 10NS
+   SETUPTIME_LO = 15NS
+   HOLDTIME = 20NS
+   WHEN = { CLRBAR!='0 }
+ GENERAL:
+   WHEN = { LOADBAR=='0 & (CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0)
+     | CHANGED(D,0)) }
+   MESSAGE = "Invalid hold time of DATA with respect to LOADBAR."
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74198 8-BIT SHIFT REGISTER
*
* THE TTL LOGIC STANDARD TTL, SCHOTTKY, LOW-POWER SCHOTTKY DATA BOOK, 1988, TI
* NH 7/13/92          REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74198 CLK_I CLRBAR_I S0_I S1_I SR_I SL_I A_I B_I C_I D_I E_I F_I G_I H_I
+ QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O
+ OPTIONAL: DPWR=$G_DPWR   DGND=$G_DGND
+ PARAMS:   MNTYMXDLY=0    IO_LEVEL=0
*
U198LOG LOGICEXP(22,31) DPWR DGND
+ CLK_I CLRBAR_I S0_I S1_I SR_I SL_I A_I B_I C_I D_I E_I F_I G_I H_I
+  QA QB QC QD QE QF QG QH
+ CLK CLRBAR S0 S1 SR SL A B C D E F G H CLOCK KA KB KC KD KE KF KG KH
+  JA JB JC JD JE JF JG JH
+ D0_GATE  IO_STD   IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+
* INTERMEDIATE TERM
+   S1BAR = { ~S1_I }
+   S0BAR = { ~S0_I }
+   LOAD = { ~(S1BAR | S0BAR) }
*
* OUTPUT ASSIGNMENT
*
+   CLK = { CLK_I }
+   CLRBAR = { CLRBAR_I }
+   S0 = { S0_I }
+   S1 = { S1_I }
+   SR = { SR_I }
+   SL = { SL_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   E = { E_I }
+   F = { F_I }
+   G = { G_I }
+   H = { H_I }
+
+   KA = { ~( (SR & S1BAR) | (LOAD & A) | (S0BAR & QB) ) }
+   KB = { ~( (QA & S1BAR) | (LOAD & B) | (S0BAR & QC) ) }
+   KC = { ~( (QB & S1BAR) | (LOAD & C) | (S0BAR & QD) ) }
+   KD = { ~( (QC & S1BAR) | (LOAD & D) | (S0BAR & QE) ) }
+   KE = { ~( (QD & S1BAR) | (LOAD & E) | (S0BAR & QF) ) }
+   KF = { ~( (QE & S1BAR) | (LOAD & F) | (S0BAR & QG) ) }
+   KG = { ~( (QF & S1BAR) | (LOAD & G) | (S0BAR & QH) ) }
+   KH = { ~( (QG & S1BAR) | (LOAD & H) | (S0BAR & SL) ) }
+
+   JA = { ~KA }
+   JB = { ~KB }
+   JC = { ~KC }
+   JD = { ~KD }
+   JE = { ~KE }
+   JF = { ~KF }
+   JG = { ~KG }
+   JH = { ~KH }
+   CLOCK = { ~(CLK | (S1BAR & S0BAR)) }
*
U1 JKFF(8) DPWR DGND
+ $D_HI CLRBAR CLOCK JA JB JC JD JE JF JG JH KA KB KC KD KE KF KG KH
+ QA QB QC QD QE QF QG QH $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_STD
*
U198DLY PINDLY (8,0,14) DPWR DGND
+ QA QB QC QD QE QF QG QH
+ CLK CLRBAR S1 S0 SR SL A B C D E F G H
+ QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY}   IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O = {
+     CASE(
+         CHANGED_LH(CLK,0) & TRN_LH, DELAY(-1,17NS,26NS),
+         CHANGED_LH(CLK,0) & TRN_HL, DELAY(-1,20NS,30NS),
+         CHANGED_HL(CLRBAR,0) & TRN_HL, DELAY(-1,23NS,35NS),
+         DELAY(-1,24NS,36NS)          ;DEFAULT
+       )
+     }
+
+ BOOLEAN:
+   NOT_CLEAR = { CLRBAR!='0 }
+   SHIFT_RIGHT = { (S1!='1 ^ CHANGED(S1,0)) & (S0!='0 ^ CHANGED(S0,0)) }
+   SHIFT_LEFT = { (S1!='0 ^ CHANGED(S1,0)) & (S0!='1 ^ CHANGED(S0,0)) }
+   LOAD = { (S1!='0 ^ CHANGED(S1,0)) & (S0!='0 ^ CHANGED(S0,0)) }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 20NS
+   MIN_LO = 20NS
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+
+ SETUP_HOLD:
+   DATA(2) S1 S0
+   CLOCK LH = CLK
+   SETUPTIME = 30NS
+   WHEN = { NOT_CLEAR }
+
+ SETUP_HOLD:
+   DATA(1) SR
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { NOT_CLEAR & SHIFT_RIGHT }
+
+ SETUP_HOLD:
+   DATA(1) SL
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { NOT_CLEAR & SHIFT_LEFT }
+
+ SETUP_HOLD:
+   DATA(8) A B C D E F G H
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { NOT_CLEAR & LOAD }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74199 8-BIT SHIFT REGISTER
*
* THE TTL LOGIC STANDARD TTL, SCHOTTKY, LOW-POWER SCHOTTKY DATA BOOK, 1988, TI
* NH 7/16/92          REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74199 CLK_I CLK_INH_I SH/LDBAR_I CLRBAR_I J_I KBAR_I A_I B_I C_I D_I
+ E_I F_I G_I H_I QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O
+ OPTIONAL: DPWR=$G_DPWR   DGND=$G_DGND
+ PARAMS:   MNTYMXDLY=0    IO_LEVEL=0
*
U199LOG LOGICEXP(22,31) DPWR DGND
+ CLK_I CLK_INH_I SH/LDBAR_I CLRBAR_I J_I KBAR_I A_I B_I C_I D_I E_I F_I G_I H_I
+  QA QABAR QB QC QD QE QF QG
+ CLK CLK_INH SH/LDBAR CLRBAR J KBAR A B C D E F G H
+  CLOCK KA KB KC KD KE KF KG KH JA JB JC JD JE JF JG JH
+ D0_GATE  IO_STD  IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
+
* INTERMEDIATE TERM
+   LOAD = { ~SH/LDBAR_I }
+   SHIFT = { SH/LDBAR_I }
*
* OUTPUT ASSIGNMENT
*
+   CLK = { CLK_I }
+   CLK_INH = { CLK_INH_I }
+   SH/LDBAR = { SH/LDBAR_I }
+   CLRBAR = { CLRBAR_I }
+   J = { J_I }
+   KBAR = { KBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   E = { E_I }
+   F = { F_I }
+   G = { G_I }
+   H = { H_I }
+
+   KA = { ~( (J & SHIFT & QABAR) | (LOAD & A) | (KBAR & SHIFT & QA) ) }
+   KB = { ~( (QA & SHIFT) | (LOAD & B) ) }
+   KC = { ~( (QB & SHIFT) | (LOAD & C) ) }
+   KD = { ~( (QC & SHIFT) | (LOAD & D) ) }
+   KE = { ~( (QD & SHIFT) | (LOAD & E) ) }
+   KF = { ~( (QE & SHIFT) | (LOAD & F) ) }
+   KG = { ~( (QF & SHIFT) | (LOAD & G) ) }
+   KH = { ~( (QG & SHIFT) | (LOAD & H) ) }
+
+   JA = { ~KA }
+   JB = { ~KB }
+   JC = { ~KC }
+   JD = { ~KD }
+   JE = { ~KE }
+   JF = { ~KF }
+   JG = { ~KG }
+   JH = { ~KH }
+   CLOCK = { ~(CLK | CLK_INH) }
*
U1 JKFF(8) DPWR DGND
+ $D_HI CLRBAR CLOCK JA JB JC JD JE JF JG JH KA KB KC KD KE KF KG KH
+ QA QB QC QD QE QF QG QH QABAR $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF  IO_STD
*
U199DLY PINDLY (8,0,14) DPWR DGND
+ QA QB QC QD QE QF QG QH
+ CLK CLRBAR CLK_INH SH/LDBAR J KBAR A B C D E F G H
+ QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY}   IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O = {
+     CASE(
+         CHANGED_LH(CLK,0) & TRN_LH, DELAY(-1,17NS,26NS),
+         CHANGED_LH(CLK,0) & TRN_HL, DELAY(-1,20NS,30NS),
+         CHANGED_HL(CLRBAR,0) & TRN_HL, DELAY(-1,23NS,35NS),
+         DELAY(-1,24NS,36NS)          ;DEFAULT
+         )
+       }
+
+ BOOLEAN:
+   ACTIVE_MODE = { CLRBAR!='0 & CLK_INH!='1 }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 20NS
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+
+ SETUP_HOLD:
+   DATA(1) SH/LDBAR
+   CLOCK LH = CLK
+   SETUPTIME = 30NS
+   WHEN = { ACTIVE_MODE }
+
+ SETUP_HOLD:                          ;SHIFT MODE
+   DATA(2) J KBAR
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { ACTIVE_MODE & (SH/LDBAR!='0 ^ CHANGED(SH/LDBAR,0)) }
+
+ SETUP_HOLD:
+   DATA(8) A B C D E F G H            ;LOAD MODE
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { ACTIVE_MODE & (SH/LDBAR!='1 ^ CHANGED(SH/LDBAR,0)) }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74246  DECODER/DRIVER BCD-7 SEGMENT WITH OPEN COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*    
.SUBCKT 74246   INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
X1   INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O   DPWR DGND   74247
+ PARAMS: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74247  DECODER/DRIVER BCD-7 SEGMENT WITH OPEN COLLECTOR OUTPUTS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*    
.SUBCKT 74247   INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 OR(6) DPWR DGND
+ LT RBIBAR INA INB INC IND
+ BIBAR/RBOBAR_B
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
*
U247LOG LOGICEXP (7,13) DPWR DGND
+ INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ INA   INB   INC   IND   RBIBAR   LT
+ OUTA OUTB OUTC OUTD OUTE OUTF OUTG
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   INA    = { INA_I }
+   INB    = { INB_I }
+   INC    = { INC_I }
+   IND    = { IND_I }
+   RBIBAR = { RBIBAR_I }
+   LTBAR  = { LTBAR_I }
+   BIBAR/RBOBAR  = { BIBAR/RBOBAR_B }
+
+   LT     = { ~LTBAR }
+   ALT    = { ~(INA & LTBAR) }
+   BLT    = { ~(INB & LTBAR) }
+   CLT    = { ~(INC & LTBAR) }
+   DLT    = { ~IND }
+   ABI    = { ~(ALT & BIBAR/RBOBAR) }
+   BBI    = { ~(BLT & BIBAR/RBOBAR) }
+   CBI    = { ~(CLT & BIBAR/RBOBAR) }
+   DBI    = { ~(DLT & BIBAR/RBOBAR) }
+
+   OUTA   = { (BBI & DBI) | (ALT & BLT & CBI) | (ABI & BLT & CLT & DLT) }
+   OUTB   = { (BBI & DBI) | (ABI & BLT & CBI) | (ALT & BBI & CBI) }
+   OUTC   = { (CBI & DBI) | (ALT & BBI & CLT) }
+   OUTD   = { (ABI & BLT & CLT & DLT) | (ALT & BLT & CBI) |
+              (ABI & BBI & CBI) }
+   OUTE   = {  ABI | (BLT & CBI) }
+   OUTF   = { (ABI & BBI) | (BBI & CLT) | (ABI & CLT & DLT) }
+   OUTG   = { (ABI & BBI & CBI) | (BLT & CLT & DLT & LTBAR) }
*
U247DLY_OC PINDLY (7,0,0) DPWR DGND
+ OUTA OUTB OUTC OUTD OUTE OUTF OUTG
+
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ IO_STD_OC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O =
+     { DELAY(-1,-1,100NS) }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74248  DECODER/DRIVER BCD-7 SEGMENT WITH INTERNAL PULLUPS
*
* THE TTL DATA BOOK, VOLUME 2, STANDARD, S, LS, TTL; 1985, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*    
.SUBCKT 74248   INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 OR(6) DPWR DGND
+ LT RBIBAR INA INB INC IND
+ BIBAR/RBOBAR_B
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
*
U248LOG LOGICEXP (7,13) DPWR DGND
+ INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ INA   INB   INC   IND   RBIBAR   LT
+ OUTA OUTB OUTC OUTD OUTE OUTF OUTG
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   INA    = { INA_I }
+   INB    = { INB_I }
+   INC    = { INC_I }
+   IND    = { IND_I }
+   RBIBAR = { RBIBAR_I }
+   LTBAR  = { LTBAR_I }
+   BIBAR/RBOBAR  = { BIBAR/RBOBAR_B }
+
+   LT     = { ~LTBAR }
+   ALT    = { ~(INA & LTBAR) }
+   BLT    = { ~(INB & LTBAR) }
+   CLT    = { ~(INC & LTBAR) }
+   DLT    = { ~IND }
+   ABI    = { ~(ALT & BIBAR/RBOBAR) }
+   BBI    = { ~(BLT & BIBAR/RBOBAR) }
+   CBI    = { ~(CLT & BIBAR/RBOBAR) }
+   DBI    = { ~(DLT & BIBAR/RBOBAR) }
+
+   OUTA   = { ~((BBI & DBI) | (ALT & BLT & CBI) | (ABI & BLT & CLT & DLT)) }
+   OUTB   = { ~((BBI & DBI) | (ABI & BLT & CBI) | (ALT & BBI & CBI)) }
+   OUTC   = { ~((CBI & DBI) | (ALT & BBI & CLT)) }
+   OUTD   = { ~((ABI & BLT & CLT & DLT) | (ALT & BLT & CBI) |
+                (ABI & BBI & CBI)) }
+   OUTE   = { ~( ABI | (BLT & CBI)) }
+   OUTF   = { ~((ABI & BBI) | (BBI & CLT) | (ABI & CLT & DLT)) }
+   OUTG   = { ~((ABI & BBI & CBI) | (BLT & CLT & DLT & LTBAR)) }
*
U248DLY PINDLY (7,0,0) DPWR DGND
+ OUTA OUTB OUTC OUTD OUTE OUTF OUTG
+
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O =
+     { DELAY(-1,-1,100NS) }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74249  DECODER/DRIVER BCD-7 SEGMENT WITH OPEN COLLECTOR OUTPUTS
*
* THE TTL DATA BOOK, VOLUME 2, STANDARD, S, LS, TTL; 1985, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*    
.SUBCKT 74249   INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 OR(6) DPWR DGND
+ LT RBIBAR INA INB INC IND
+ BIBAR/RBOBAR_B
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
*
U249LOG LOGICEXP (7,13) DPWR DGND
+ INA_I INB_I INC_I IND_I RBIBAR_I LTBAR_I BIBAR/RBOBAR_B
+ INA   INB   INC   IND   RBIBAR   LT
+ OUTA OUTB OUTC OUTD OUTE OUTF OUTG
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   INA    = { INA_I }
+   INB    = { INB_I }
+   INC    = { INC_I }
+   IND    = { IND_I }
+   RBIBAR = { RBIBAR_I }
+   LTBAR  = { LTBAR_I }
+   BIBAR/RBOBAR  = { BIBAR/RBOBAR_B }
+
+   LT     = { ~LTBAR }
+   ALT    = { ~(INA & LTBAR) }
+   BLT    = { ~(INB & LTBAR) }
+   CLT    = { ~(INC & LTBAR) }
+   DLT    = { ~IND }
+   ABI    = { ~(ALT & BIBAR/RBOBAR) }
+   BBI    = { ~(BLT & BIBAR/RBOBAR) }
+   CBI    = { ~(CLT & BIBAR/RBOBAR) }
+   DBI    = { ~(DLT & BIBAR/RBOBAR) }
+
+   OUTA   = { ~((BBI & DBI) | (ALT & BLT & CBI) | (ABI & BLT & CLT & DLT)) }
+   OUTB   = { ~((BBI & DBI) | (ABI & BLT & CBI) | (ALT & BBI & CBI)) }
+   OUTC   = { ~((CBI & DBI) | (ALT & BBI & CLT)) }
+   OUTD   = { ~((ABI & BLT & CLT & DLT) | (ALT & BLT & CBI) |
+                (ABI & BBI & CBI)) }
+   OUTE   = { ~( ABI | (BLT & CBI)) }
+   OUTF   = { ~((ABI & BBI) | (BBI & CLT) | (ABI & CLT & DLT)) }
+   OUTG   = { ~((ABI & BBI & CBI) | (BLT & CLT & DLT & LTBAR)) }
*
U249DLY_OC PINDLY (7,0,0) DPWR DGND
+ OUTA OUTB OUTC OUTD OUTE OUTF OUTG
+
+ OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O
+ IO_STD_OC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   OUTA_O OUTB_O OUTC_O OUTD_O OUTE_O OUTF_O OUTG_O =
+     { DELAY(-1,-1,100NS) }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74251  MULTIPLEXER/DATA SELECTOR 8-1 LINE WITH 3-STATE OUTPUTS
*
* THE TTL DATA BOOK, 1988, TI
* TC  08/24/92  REMODELED USING LOGICEXP, PINDLY, & CONSTRAINT DEVICES
*
.SUBCKT 74251 GBAR_I A_I B_I C_I D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I
+ Y_O W_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U251LOG LOGICEXP(12,14) DPWR DGND
+ GBAR_I A_I B_I C_I D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I
+ GBAR A B C D0 D1 D2 D3 D4 D5 D6 D7 W Y
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   GBAR = { GBAR_I }
+   A = { A_I }  
+   B = { B_I }  
+   C = { C_I }  
+   D0 = { D0_I }
+   D1 = { D1_I }
+   D2 = { D2_I }
+   D3 = { D3_I }
+   D4 = { D4_I }
+   D5 = { D5_I }
+   D6 = { D6_I }
+   D7 = { D7_I }
+   IA = { ~A }
+   IB = { ~B }
+   IC = { ~C }
+   IG = { ~GBAR }
+   ID0 = { D0 & IA & IB & IC & IG }
+   ID1 = { D1 & A & IB & IC & IG }
+   ID2 = { D2 & IA & B & IC & IG }
+   ID3 = { D3 & A & B & IC & IG }
+   ID4 = { D4 & IA & IB & C & IG }
+   ID5 = { D5 & A & IB & C & IG }
+   ID6 = { D6 & IA & B & C & IG }
+   ID7 = { D7 & A & B & C & IG }
+   W = { ~(ID0 | ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7) }
+   Y = { ~W }
*
U251DLY PINDLY (2,1,11) DPWR DGND
+ W Y
+ GBAR
+ A B C D0 D1 D2 D3 D4 D5 D6 D7
+ W_O Y_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   DATA = { CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) |
+     CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0) }
+   SELECT = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+ TRISTATE:
+   ENABLE LO GBAR
+   Y_O = { 
+     CASE(
+       SELECT & TRN_LH, DELAY(-1,29NS,45NS),
+       SELECT & TRN_HL, DELAY(-1,28NS,45NS),
+       TRN_ZL, DELAY(-1,26NS,40NS),
+       DATA & TRN_HL, DELAY(-1,18NS,28NS),
+       DATA & TRN_LH, DELAY(-1,17NS,28NS),
+       TRN_ZH, DELAY(-1,17NS,27NS),
+       TRN_LZ, DELAY(-1,15NS,23NS),
+       TRN_HZ, DELAY(-1,5NS,8NS),
+       DELAY(-1,30NS,46NS)
+       )
+     }
+   W_O = {
+     CASE(
+       TRN_ZL, DELAY(-1,24NS,40NS),
+       SELECT & TRN_HL, DELAY(-1,21NS,33NS),
+       SELECT & TRN_LH, DELAY(-1,20NS,33NS),
+       TRN_ZH, DELAY(-1,17NS,27NS),
+       TRN_LZ, DELAY(-1,15NS,23NS),
+       DATA & TRN_LH, DELAY(-1,10NS,15NS),
+       DATA & TRN_HL, DELAY(-1,9NS,15NS),
+       TRN_HZ, DELAY(-1,5NS,8NS),
+       DELAY(-1,25NS,41NS)
+       )
+     }
*
.ENDS
*
*$
*--------------------------------------------------------------------------
* 74259  8-BIT ADDRESSABLE LATCHES
*
* The TTL Data Book, Vol 2, 1985, TI
* tvh	09/11/89	Update interface and model names
*
.subckt 74259  CLRBAR GBAR D S0 S1 S2 Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 bufa(3) DPWR DGND
+	CLRBAR GBAR D   RB GB DATA 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U2 bufa(3) DPWR DGND
+	S0 S1 S2   SA SB SC 
+	D_259_1 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U3 inva(3) DPWR DGND
+	SA SB SC   AB BB CB 
+	D0_GATE IO_STD 
U4 nanda(3,8) DPWR DGND
+	AB	BB	CB
+	SA	BB	CB
+	AB	SB	CB
+	SA	SB	CB
+	AB	BB	SC
+	SA	BB	SC
+	AB	SB	SC
+	SA	SB	SC
+	T0	T1	T2	T3	T4	T5	T6	T7
+	D0_GATE IO_STD 
U5 nora(2,8) DPWR DGND
+	GB	T0
+	GB	T1
+	GB	T2
+	GB	T3
+	GB	T4
+	GB	T5
+	GB	T6
+	GB	T7
+	G0	G1	G2	G3	G4	G5	G6	G7
+	D0_GATE IO_STD 
U6 ora(2,8) DPWR DGND
+	G0	RB
+	G1	RB
+	G2	RB
+	G3	RB
+	G4	RB
+	G5	RB
+	G6	RB
+	G7	RB
+	R0	R1	R2	R3	R4	R5	R6	R7
+	D0_GATE IO_STD 
U7 dltch(1) DPWR DGND
+	$D_HI R0 G0   DATA   Q0 $D_NC 
+	D_259_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U8 dltch(1) DPWR DGND
+	$D_HI R1 G1   DATA   Q1 $D_NC 
+	D_259_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U9 dltch(1) DPWR DGND
+	$D_HI R2 G2   DATA   Q2 $D_NC 
+	D_259_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U10 dltch(1) DPWR DGND
+	$D_HI R3 G3   DATA   Q3 $D_NC 
+	D_259_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U11 dltch(1) DPWR DGND
+	$D_HI R4 G4   DATA   Q4 $D_NC 
+	D_259_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U12 dltch(1) DPWR DGND
+	$D_HI R5 G5   DATA   Q5 $D_NC 
+	D_259_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U13 dltch(1) DPWR DGND
+	$D_HI R6 G6   DATA   Q6 $D_NC 
+	D_259_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U14 dltch(1) DPWR DGND
+	$D_HI R7 G7   DATA   Q7 $D_NC 
+	D_259_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_259_1 ugate (
+	TPLHTY=6NS	TPLHMX=8NS
+	TPHLTY=6NS	TPHLMX=8NS
+	)
.model D_259_2 ugff (
+	TWGHMN=15NS	TWPCLMN=15NS
+	TSUDGMN=15NS	TPPCQHLTY=16NS
+	TPPCQHLMX=25NS	TPDQLHTY=14NS
+	TPDQLHMX=24NS	TPDQHLTY=11NS
+	TPDQHLMX=20NS	TPGQLHTY=12NS
+	TPGQLHMX=20NS	TPGQHLTY=11NS
+	TPGQHLMX=20NS
+	)
*$
*--------------------------------------------------------------------------
* 74265  QUAD. COMPLEMENTARY-OUTPUT ELEMENTS
*
* The TTL Data Book, Vol 2, 1985, TI
* tvh	07/5/89  	Update interface and model names
*
.subckt 74265  1A 1W 1Y 2A 2B 2W 2Y 3A 3B 3W 3Y 4A 4W 4Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(6) DPWR DGND
+	1A	2A	2B	3A	3B	4A
+	1A_BUF	2A_BUF	2B_BUF	3A_BUF	3B_BUF	4A_BUF
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U1 bufa(2) DPWR DGND
+	1A_BUF 4A_BUF   1W 4W 
+	D_265_1 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 inva(2) DPWR DGND
+	1A_BUF 4A_BUF   1Y 4Y 
+	D_265_2 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U3 anda(2,2) DPWR DGND
+	2A_BUF 2B_BUF 3A_BUF 3B_BUF   2W 3W 
+	D_265_3 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U4 nanda(2,2) DPWR DGND
+	2A_BUF 2B_BUF 3A_BUF 3B_BUF   2Y 3Y 
+	D_265_4 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_265_1 ugate (
+	TPLHTY=11.6NS	TPLHMX=18NS
+	TPHLTY=9.8NS	TPHLMX=18NS
+	)
.model D_265_2 ugate (
+	TPLHTY=10.2NS	TPLHMX=18NS
+	TPHLTY=11.3NS	TPHLMX=18NS
+	)
.model D_265_3 ugate (
+	TPLHTY=11.6NS	TPLHMX=18NS
+	TPHLTY=9.8NS	TPHLMX=18NS
+	)
.model D_265_4 ugate (
+	TPLHTY=10.2NS	TPLHMX=18NS
+	TPHLTY=11.3NS	TPHLMX=18NS
+	)
*$
*--------------------------------------------------------------------------
* 74273  OCTAL D-TYPE EDGE-TRIGGERED FLIP-FLOPS WITH CLEAR
*
* The TTL Data Book, Vol 2, 1985, TI
* tvh	07/5/89  	Update interface and model names
*
.subckt 74273  CLRBAR CLK D1 D2 D3 D4 D5 D6 D7 D8 Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UD dff(8) DPWR DGND
+	$D_HI	CLRBAR	CLK
+	D1	D2	D3	D4	D5	D6	D7	D8
+	Q1	Q2	Q3	Q4	Q5	Q6	Q7	Q8
+	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC
+	D_273 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_273 ueff (
+	TWCLKLMN=16.5NS	TWCLKHMN=16.5NS
+	TWPCLMN=16.5NS	TSUDCLKMN=20NS
+	TSUPCCLKHMN=25NS	THDCLKMN=5NS
+	TPPCQHLTY=18NS	TPPCQHLMX=27NS
+	TPCLKQLHTY=17NS	TPCLKQLHMX=27NS
+	TPCLKQHLTY=18NS	TPCLKQHLMX=27NS
+	)
*$
*---------------------------------------------------------------------------
* 74276  QUADRUPLE J-K FLIP-FLOPS
*
* The TTL Data Book, Vol 2, 1985, TI
* tvh	07/5/89  	Update interface and model names
*
.subckt 74276  PREBAR CLRBAR CLK1 CLK2 CLK3 CLK4 J1 J2 J3 J4 KBAR1 KBAR2 KBAR3
+	KBAR4 Q1 Q2 Q3 Q4
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(2) DPWR DGND
+	PREBAR CLRBAR   PREB CLRB 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
UK inva(4) DPWR DGND
+	KBAR1 KBAR2 KBAR3 KBAR4   K1 K2 K3 K4 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U1 jkff(1) DPWR DGND
+	PREB CLRB CLK1   J1 K1   Q1 Q1BAR 
+	D_276 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 jkff(1) DPWR DGND
+	PREB CLRB CLK2   J2 K2   Q2 Q2BAR 
+	D_276 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U3 jkff(1) DPWR DGND
+	PREB CLRB CLK3   J3 K3   Q3 Q3BAR 
+	D_276 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U4 jkff(1) DPWR DGND
+	PREB CLRB CLK4   J4 K4   Q4 Q4BAR 
+	D_276 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_276 ueff (
+	TWCLKLMN=15NS	TWCLKHMN=13.5NS
+	TWPCLMN=12NS	TSUPCCLKHMN=10NS
+	TSUDCLKMN=3NS	THDCLKMN=10NS
+	TPPCQLHTY=15NS	TPPCQLHMX=25NS
+	TPPCQHLTY=18NS	TPPCQHLMX=30NS
+	TPCLKQLHTY=17NS	TPCLKQLHMX=30NS
+	TPCLKQHLTY=20NS	TPCLKQHLMX=30NS
+	)
*
*$
*-------------------------------------------------------------------------
* 74278   PRIORITY REGISTERS 4-BIT CASCADABLE
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   8-31-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74278   P0_I STRB_I D1_I D2_I D3_I D4_I
+ Y1_O Y2_O Y3_O Y4_O P1_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 DLTCH(4) DPWR DGND
+ $D_HI $D_HI STRB
+ D1    D2    D3    D4
+ Q1    Q2    Q3    Q4
+ Q1BAR Q2BAR Q3BAR Q4BAR
+ D0_GFF  IO_STD
*
U278LOG LOGICEXP (14,11) DPWR DGND
+ P0_I STRB_I D1_I D2_I D3_I D4_I   Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+ P0   STRB   D1   D2   D3   D4     Y1 Y2 Y3 Y4 P1
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   P0     = { P0_I }
+   STRB   = { STRB_I }
+   D1     = { D1_I }
+   D2     = { D2_I }
+   D3     = { D3_I }
+   D4     = { D4_I }
+   Y1     = { ~(P0 | Q1BAR ) }
+   Y2     = { ~(P0 | Q2BAR | Q1 ) }
+   Y3     = { ~(P0 | Q3BAR | Q2 | Q1 ) }
+   Y4     = { ~(P0 | Q4BAR | Q3 | Q2 | Q1 ) }
+   P1     = { P0 | Q4 | Q3 | Q2 | Q1 }
*
U278DLY PINDLY (5,0,6) DPWR DGND
+ Y1 Y2 Y3 Y4 P1
+ P0 STRB D1 D2 D3 D4
+ Y1_O Y2_O Y3_O Y4_O P1_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   STROBE = { CHANGED(STRB,0) }
+   BUSY   = { CHANGED(P0,0) }
+   PRIOR1 = { CHANGED_HL(D1,0) | BUSY }
+   PRIOR2 = { CHANGED_HL(D2,0) | PRIOR1 }
+   PRIOR3 = { CHANGED_HL(D3,0) | PRIOR2 | PRIOR1 }
+
+ PINDLY:
+   Y1_O = {
+     CASE (
+       STROBE & TRN_LH, DELAY(-1,-1,30NS),
+       STROBE & TRN_HL, DELAY(-1,-1,31NS),
+                TRN_LH, DELAY(-1,-1,30NS),
+                TRN_HL, DELAY(-1,-1,39NS),
+       DELAY(-1,-1,39NS)
+       )
+     }
+   Y2_O = {
+     CASE (
+       STROBE & TRN_LH, DELAY(-1,-1,30NS),
+       STROBE & TRN_HL, DELAY(-1,-1,31NS),
+       PRIOR1 & TRN_LH, DELAY(-1,-1,38NS),
+       PRIOR1 & TRN_HL, DELAY(-1,-1,31NS),
+                TRN_LH, DELAY(-1,-1,30NS),
+                TRN_HL, DELAY(-1,-1,39NS),
+       DELAY(-1,-1,39NS)
+       )
+     }
+   Y3_O = {
+     CASE (
+       STROBE & TRN_LH, DELAY(-1,-1,30NS),
+       STROBE & TRN_HL, DELAY(-1,-1,31NS),
+       PRIOR2 & TRN_LH, DELAY(-1,-1,38NS),
+       PRIOR2 & TRN_HL, DELAY(-1,-1,31NS),
+                TRN_LH, DELAY(-1,-1,30NS),
+                TRN_HL, DELAY(-1,-1,39NS),
+       DELAY(-1,-1,39NS)
+       )
+     }
+   Y4_O = {
+     CASE (
+       STROBE & TRN_LH, DELAY(-1,-1,30NS),
+       STROBE & TRN_HL, DELAY(-1,-1,31NS),
+       PRIOR3 & TRN_LH, DELAY(-1,-1,38NS),
+       PRIOR3 & TRN_HL, DELAY(-1,-1,31NS),
+                TRN_LH, DELAY(-1,-1,30NS),
+                TRN_HL, DELAY(-1,-1,39NS),
+       DELAY(-1,-1,39NS)
+       )
+     }
+   P1_O = {
+     CASE (
+       BUSY   & TRN_LH, DELAY(-1,-1,23NS),
+       BUSY   & TRN_HL, DELAY(-1,-1,30NS),
+       STROBE & TRN_LH, DELAY(-1,-1,38NS),
+       STROBE & TRN_HL, DELAY(-1,-1,42NS),
+                TRN_LH, DELAY(-1,-1,46NS),
+                TRN_HL, DELAY(-1,-1,39NS),
+       DELAY(-1,-1,46NS)
+       )
+     }
+
+ WIDTH:
+   NODE      = STRB
+   MIN_HI    = 20NS
+ SETUP_HOLD:
+   DATA(4)   = D1 D2 D3 D4
+   CLOCK HL  = STRB		
+   SETUPTIME = 20NS
+   HOLDTIME  =  5NS
*
.ENDS
*
*$
*---------------------------------------------------------------------------
* 74279  QUADRUPLE SBAR-RBAR LATCHES
*
* The TTL Data Book, Vol 2, 1985, TI
* tvh	09/07/89  	Update interface and model names
*
.subckt 74279  1RBAR 1S1BAR 1S2BAR 2RBAR 2SBAR 1Q 2Q
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 bufa(2) DPWR DGND
+	1RBAR 2RBAR   1RB 2RB 
+	D_279_1 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 nanda(3,2) DPWR DGND
+	1RB Q1 $D_HI 1S1BAR 1S2BAR Q1B   Q1B Q1 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U3 nanda(2,2) DPWR DGND
+	2RB Q2 2SBAR Q2B   Q2B Q2 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U4 wdthck(5) DPWR DGND
+	1RBAR	1S1BAR	1S2BAR	2RBAR	2SBAR
+	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC
+	1RLO	1S1LO	1S2LO	2RLO	2SLO
+	D_279_2 IO_STD MNTYMXDLY={MNTYMXDLY} 
U5 ora(3,2) DPWR DGND
+	1RLO 1S1LO 1S2LO 2RLO 2SLO $D_LO   X1 X2 
+	D0_GATE IO_STD 
U6 inva(2) DPWR DGND
+	X1 X2   T1 T2 
+	D0_GATE IO_STD 
U7 buf3 DPWR DGND
+	$D_X   X1   1Q 
+	D_279_3 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U8 buf3 DPWR DGND
+	$D_X   X2   2Q 
+	D_279_3 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U9 buf3 DPWR DGND
+	Q1   T1   1Q 
+	D_279_3 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U10 buf3 DPWR DGND
+	Q2   T2   2Q 
+	D_279_3 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_279_1 ugate (
+	TPHLTY=6NS	TPHLMX=12NS
+	)
.model D_279_2 uwdth (
+	TWLMN=20NS
+	)
.model D_279_3 utgate (
+	TPLHTY=12NS	TPHLTY=9NS
+	TPLHMX=22NS	TPHLMX=15NS
+	TPZHTY=12NS	TPZLTY=9NS
+	TPZHMX=22NS	TPZLMX=15NS
+	TPLZTY=12NS	TPHZTY=9NS
+	TPLZMX=22NS	TPHZMX=15NS
+	)
*$
*-------------------------------------------------------------------------
* 74283 4-BIT BINARY FULL ADDERS WITH FAST CARRY
*
* TTL LOGIC STANDARD TTL, SCHOTTKY, LOW-POWER SCHOTTKY DATA BOOK, 1988, TI
* NH 8/26/92         REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74283 C0_I A1_I A2_I A3_I A4_I B1_I B2_I B3_I B4_I C4_O
+             SUM1_O SUM2_O SUM3_O SUM4_O
+ OPTIONAL: DPWR = $G_DPWR DGND = $G_DGND
+ PARAMS:   MNTYMXDLY = 0  IO_LEVEL = 0
*
U283LOG LOGICEXP(9,14) DPWR DGND
+ C0_I A1_I A2_I A3_I A4_I B1_I B2_I B3_I B4_I
+ C0 A1 A2 A3 A4 B1 B2 B3 B4 C4 SUM1 SUM2 SUM3 SUM4
+ D0_GATE IO_STD IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
+   C0 = { C0_I }
+   A1 = { A1_I }
+   A2 = { A2_I }
+   A3 = { A3_I }
+   A4 = { A4_I }
+   B1 = { B1_I }
+   B2 = { B2_I }
+   B3 = { B3_I }
+   B4 = { B4_I }
+
+   NAND4 = { ~(A4 & B4) }
+   NAND3 = { ~(A3 & B3) }
+   NAND2 = { ~(A2 & B2) }
+   NAND1 = { ~(A1 & B1) }
+   NOR4 = { ~(A4 | B4) }
+   NOR3 = { ~(A3 | B3) }
+   NOR2 = { ~(A2 | B2) }
+   NOR1 = { ~(A1 | B1) }
+   C0BAR = { ~C0 }
+
+   SUM1 = { (NAND1 & ~NOR1) ^ C0 }
+   SUM2 = { (NAND2 & ~NOR2) ^ (~(NOR1 | (NAND1 & C0BAR))) }
+   SUM3 = { (NAND3 & ~NOR3) ^ (~(NOR2 | (NOR1 & NAND2) |
+            (NAND2 & NAND1 & C0BAR))) }
+   SUM4 = { (NAND4 & ~NOR4) ^ (~(NOR3 | (NOR2 & NAND3) |
+            (NOR1 & NAND3 & NAND2) | (NAND3 & NAND2 & NAND1 & C0BAR))) }
+   C4 = { ~( NOR4 | (NOR3 & NAND4) | (NOR2 & NAND4 & NAND3) |
+             (NOR1 & NAND4 & NAND3 & NAND2) |
+             (NAND4 & NAND3 & NAND2 & NAND1 & C0BAR) ) }
*
U283DLY PINDLY (5,0,9) DPWR DGND
+ SUM1 SUM2 SUM3 SUM4 C4
+ C0 A1 A2 A3 A4 B1 B2 B3 B4
+ SUM1_O SUM2_O SUM3_O SUM4_O C4_O
+ IO_STD MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+
+ BOOLEAN:
+   ANY_CH_AB = { CHANGED(A1,0) | CHANGED(B1,0) | CHANGED(A2,0) |
+                 CHANGED(B2,0) | CHANGED(A3,0) | CHANGED(B3,0) |
+                 CHANGED(A4,0) | CHANGED(B4,0) }
+
+ PINDLY:
+   SUM1_O SUM2_O SUM3_O SUM4_O = {
+     CASE(
+       ANY_CH_AB, DELAY(-1,16NS,24NS),
+       CHANGED(C0,0) & TRN_LH, DELAY(-1,14NS,21NS),
+       CHANGED(C0,0) & TRN_HL, DELAY(-1,12NS,21NS),
+       DELAY(-1,17NS,25NS)                       ;DEFAULT
+       )
+     }
+   C4_O = {
+     CASE(
+       (ANY_CH_AB | CHANGED(C0,0)) & TRN_HL, DELAY(-1,11NS,16NS),
+       (ANY_CH_AB | CHANGED(C0,0)) & TRN_LH, DELAY(-1,9NS,14NS),
+       DELAY(-1,12NS,17NS)                     ;DEFAULT
+       )
+     }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74290  COUNTER DECADE 4-BIT, ASYNCHRONOUS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   7-3-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
* NOTICE -- EXCEPT FOR THE PIN ARRANGEMENT, THE '290 IS ELECTRICALLY AND
*           FUNCTIONALLY IDENTICAL TO THE '90A
* NOTICE -- THE CKA TO QD PIN DELAY IS NOT INCLUDED IN THIS MODEL SINCE
*           THE DIV2 AND DIV5 SECTIONS OF THE COUNTER ACT INDEPENDENTLY. 
*
.SUBCKT 74290  R91 R92 CKA CKB R01 R02  QA QB QC QD
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
X1   R91 R92 CKA CKB R01 R02   QA QB QC QD   DPWR DGND   7490A
+ PARAMS: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74293  COUNTER BINARY 4-BIT, ASYNCHRONOUS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   6-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
* NOTICE -- EXCEPT FOR THE PIN ARRANGEMENT, THE '293 IS ELECTRICALLY AND
*           FUNCTIONALLY IDENTICAL TO THE '93A
* NOTICE -- THE CKA TO QD PIN DELAY IS NOT INCLUDED IN THIS MODEL SINCE
*           THE DIV2 AND DIV8 SECTIONS OF THE COUNTER ACT INDEPENDENTLY. 
*
.SUBCKT 74293  CKA CKB R01 R02  QA QB QC QD
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
X1   CKA CKB R01 R02   QA QB QC QD   DPWR DGND   7493A
+ PARAMS: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74298  MULTIPLEXERS QUAD 2-INPUT WITH STORAGE
*
* THE TTL DATA BOOK, 1988, TI
* TC  08/25/92  REMODELED USING LOGICEXP, PINDLY, & CONSTRAINT DEVICES
*
.SUBCKT 74298 WS_I CLK_I A1_I A2_I B1_I B2_I C1_I C2_I D1_I D2_I
+ QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(4) DPWR DGND $D_HI $D_HI CLK
+ JA JB JC JD KA KB KC KD QA QB QC QD $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_STD
*
U298LOG LOGICEXP(10,18) DPWR DGND
+ WS_I CLK_I A1_I A2_I B1_I B2_I C1_I C2_I D1_I D2_I
+ WS CLK A1 A2 B1 B2 C1 C2 D1 D2 JA JB JC JD KA KB KC KD
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   WS = { WS_I }
+   CLK = { CLK_I }
+   A1 = { A1_I }
+   A2 = { A2_I }
+   B1 = { B1_I }
+   B2 = { B2_I }
+   C1 = { C1_I }
+   C2 = { C2_I }
+   D1 = { D1_I }
+   D2 = { D2_I }
+   IWS = { ~WS }
+   KA = { ~((A1 & IWS) | (WS & A2)) }
+   KB = { ~((B1 & IWS) | (WS & B2)) }
+   KC = { ~((C1 & IWS) | (WS & C2)) }
+   KD = { ~((D1 & IWS) | (WS & D2)) }
+   JA = { ~KA }
+   JB = { ~KB }
+   JC = { ~KC }
+   JD = { ~KD }
*
U298DLY PINDLY (4,0,10) DPWR DGND
+ QA QB QC QD
+ A1 A2 B1 B2 C1 C2 D1 D2 WS CLK
+ QA_O QB_O QC_O QD_O
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       TRN_LH, DELAY(-1,18NS,27NS),
+       DELAY(-1,21NS,32NS)
+       )
+     }
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 20NS
+   MIN_HI = 20NS
+ SETUP_HOLD:
+   DATA(4) = A1 B1 C1 D1
+   CLOCK HL = CLK
+   SETUPTIME = 15NS
+   HOLDTIME = 5NS
+   WHEN = { WS!='1 ^ CHANGED(WS,0) }
+ SETUP_HOLD:
+   DATA(4) = A2 B2 C2 D2
+   CLOCK HL = CLK
+   SETUPTIME = 15NS
+   HOLDTIME = 5NS
+   WHEN = { WS!='0 ^ CHANGED(WS,0) }
+ SETUP_HOLD:
+   DATA(1) = WS
+   CLOCK HL = CLK
+   SETUPTIME = 25NS
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74351 DUAL DATA SELECTOR/MULTIPLEXER WITH 3-STATE OUTPUTS
*
* THE TTL DATA BOOK, VOL 2, STANDARD, S, LS, TTL, 1985, TI
* NH 8/25/92        REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74351 GBAR_I A_I B_I C_I 1D0_I 1D1_I 1D2_I 1D3_I D4_I D5_I D6_I D7_I
+             2D0_I 2D1_I 2D2_I 2D3_I 1Y_O 2Y_O
+ OPTIONAL: DPWR = $G_DPWR DGND = $G_DGND
+ PARAMS:   MNTYMXDLY = 0 IO_LEVEL = 0
*
U351LOG LOGICEXP(16,18) DPWR DGND
+ GBAR_I A_I B_I C_I 1D0_I 1D1_I 1D2_I 1D3_I D4_I D5_I D6_I D7_I 2D0_I 2D1_I
+   2D2_I 2D3_I
+ GBAR A B C 1D0 1D1 1D2 1D3 D4 D5 D6 D7 2D0 2D1 2D2 2D3 1Y 2Y
+ D0_GATE IO_STD IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
+   GBAR = { GBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   1D0 = { 1D0_I }
+   1D1 = { 1D1_I }
+   1D2 = { 1D2_I }
+   1D3 = { 1D3_I }
+   D4 = { D4_I }
+   D5 = { D5_I }
+   D6 = { D6_I }
+   D7 = { D7_I }
+   2D0 = { 2D0_I }
+   2D1 = { 2D1_I }
+   2D2 = { 2D2_I }
+   2D3 = { 2D3_I }
+
+   EN = { ~GBAR }
+   ABAR = { ~A }
+   BBAR = { ~B }
+   CBAR = { ~C }
+
+   ZERO  = { CBAR & BBAR & ABAR & EN }
+   ONE   = { CBAR & BBAR & A & EN }
+   TWO   = { CBAR & B & ABAR & EN }
+   THREE = { CBAR & B & A & EN }
+   FOUR  = { C & BBAR & ABAR & EN }
+   FIVE  = { C & BBAR & A & EN }
+   SIX   = { C & B & ABAR & EN }
+   SEVEN = { C & B & A & EN }
+
+   1OUT0 = { 1D0 & ZERO }
+   1OUT1 = { 1D1 & ONE }
+   1OUT2 = { 1D2 & TWO }
+   1OUT3 = { 1D3 & THREE }
+   OUT4 = { D4 & FOUR }
+   OUT5 = { D5 & FIVE }
+   OUT6 = { D6 & SIX }
+   OUT7 = { D7 & SEVEN }
+   2OUT0 = { 2D0 & ZERO }
+   2OUT1 = { 2D1 & ONE }
+   2OUT2 = { 2D2 & TWO }
+   2OUT3 = { 2D3 & THREE }
+
+   1Y = { ~(1OUT0 | 1OUT1 | 1OUT2 | 1OUT3 | OUT4 | OUT5 | OUT6 | OUT7) }
+   2Y = { ~(2OUT0 | 2OUT1 | 2OUT2 | 2OUT3 | OUT4 | OUT5 | OUT6 | OUT7) }
*
U351DLY PINDLY (2,1,16) DPWR DGND
+ 1Y 2Y
+ GBAR
+ GBAR A B C 1D0 1D1 1D2 1D3 D4 D5 D6 D7 2D0 2D1 2D2 2D3
+ 1Y_O 2Y_O
+ IO_STD MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+
+ BOOLEAN:
+   ANY_CH_1D = { CHANGED(1D0,0) | CHANGED(1D1,0) | CHANGED(1D2,0) |
+                 CHANGED(1D3,0) | CHANGED(D4,0)  | CHANGED(D5,0)  |
+                 CHANGED(D6,0)  | CHANGED(D7,0)  | CHANGED(2D0,0) }
+   ANY_CH_2D = { CHANGED(2D0,0) | CHANGED(2D1,0) | CHANGED(2D2,0) |
+                 CHANGED(1D3,0) | CHANGED(D4,0)  | CHANGED(D5,0)  |
+                 CHANGED(D6,0)  | CHANGED(D7,0)  | CHANGED(2D0,0) }
+   CH_SELECT = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+
+ TRISTATE:
+   ENABLE LO GBAR
+   1Y_O = {
+     CASE(
+       TRN_HZ, DELAY(-1,6NS,20NS),
+       TRN_LZ, DELAY(-1,10NS,20NS),
+       TRN_ZH, DELAY(-1,18NS,33NS),
+       TRN_ZL, DELAY(-1,20NS,33NS),
+       CH_SELECT, DELAY(-1,20NS,30NS),
+       ANY_CH_1D, DELAY(-1,10NS,22NS),
+       DELAY(-1,21NS,34NS)                    ;DEFAULT
+       )
+     }
+
+ TRISTATE:
+   ENABLE LO GBAR
+   2Y_O = {
+     CASE(
+       TRN_HZ, DELAY(-1,6NS,20NS),
+       TRN_LZ, DELAY(-1,10NS,20NS),
+       TRN_ZH, DELAY(-1,18NS,33NS),
+       TRN_ZL, DELAY(-1,20NS,33NS),
+       CH_SELECT, DELAY(-1,20NS,30NS),
+       ANY_CH_2D, DELAY(-1,10NS,22NS),
+       DELAY(-1,21NS,34NS)                    ;DEFAULT
+       )
+     }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74365A  Hex Bus Drivers with 3-STATE Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* atl 	7/18/89 	Update interface and model names
*
.subckt 74365A  A1 A2 A3 A4 A5 A6 G1BAR G2BAR Y1 Y2 Y3 Y4 Y5 Y6
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UA nor(2) DPWR DGND
+	G1BAR G2BAR   E 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U1 buf3a(6) DPWR DGND
+	A1	A2	A3	A4	A5	A6
+	E
+	Y1	Y2	Y3	Y4	Y5	Y6
+	D_365A IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_365A utgate (
+	tplhmx=16ns	tphlmx=22ns
+	tpzhmx=35ns	tpzlmx=37ns
+	tphzmx=11ns	tplzmx=27ns
+	)
*$
*-------------------------------------------------------------------------
* 74366A  Hex Bus Drivers with 3-STATE Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* atl 	06/27/89	Update interface and model names
*
.subckt 74366A  A1 A2 A3 A4 A5 A6 G1BAR G2BAR Y1 Y2 Y3 Y4 Y5 Y6
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UA nor(2) DPWR DGND
+	G1BAR G2BAR   E 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U1 inv3a(6) DPWR DGND
+	A1	A2	A3	A4	A5	A6
+	E
+	Y1	Y2	Y3	Y4	Y5	Y6
+	D_366A IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_366A utgate (
+	tplhmx=17ns	tphlmx=16ns
+	tpzhmx=35ns	tpzlmx=37ns
+	tphzmx=11ns	tplzmx=27ns
+	)
*$
*-------------------------------------------------------------------------
* 74367A  Hex Bus Drivers with 3-STATE Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* atl 	7/18/89		Update interface and model names
*
.subckt 74367A  1A1 1A2 1A3 1A4 2A1 2A2 G1BAR G2BAR 1Y1 1Y2 1Y3 1Y4 2Y1 2Y2
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UINV inva(2) DPWR DGND
+	G1BAR G2BAR   G1 G2 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U1 buf3a(4) DPWR DGND
+	1A1 1A2 1A3 1A4   G1   1Y1 1Y2 1Y3 1Y4 
+	D_367A IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 buf3a(2) DPWR DGND
+	2A1 2A2   G2   2Y1 2Y2 
+	D_367A IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_367A utgate (
+	tplhmx=16ns	tphlmx=22ns
+	tpzhmx=35ns	tpzlmx=37ns
+	tphzmx=11ns	tplzmx=27ns
+	)
*$
*-------------------------------------------------------------------------
* 74368A  Hex Bus Drivers with 3-STATE Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* atl 	7/18/89 	Update interface and model names
*
.subckt 74368A  1A1 1A2 1A3 1A4 2A1 2A2 G1BAR G2BAR 1Y1 1Y2 1Y3 1Y4 2Y1 2Y2
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UINV inva(2) DPWR DGND
+	G1BAR G2BAR   G1 G2 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U1 inv3a(4) DPWR DGND
+	1A1 1A2 1A3 1A4   G1   1Y1 1Y2 1Y3 1Y4 
+	D_368A IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 inv3a(2) DPWR DGND
+	2A1 2A2   G2   2Y1 2Y2 
+	D_368A IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL=0 
.ends
*
.model D_368A utgate (
+	tplhmx=17ns	tphlmx=16ns
+	tpzhmx=35ns	tpzlmx=37ns
+	tphzmx=11ns	tplzmx=27ns
+	)
*$
*-------------------------------------------------------------------------
* 74376  Quadruple J-K Flip-Flops
*
* The TTL Data Book, Vol 2, 1985, TI
* atl 	7/18/89		Update interface and model names
*
.subckt 74376  CLRBAR CLK J1 J2 J3 J4 KBAR1 KBAR2 KBAR3 KBAR4 Q1 Q2 Q3 Q4
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UK inva(5) DPWR DGND
+	CLK	KBAR1	KBAR2	KBAR3	KBAR4
+	CLKBAR	K1	K2	K3	K4
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
UJK1 jkff(4) DPWR DGND
+	$D_HI	CLRBAR	CLKBAR
+	J1	J2	J3	J4	K1	K2	K3	K4
+	Q1	Q2	Q3	Q4	$D_NC	$D_NC	$D_NC	$D_NC
+	D_376 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_376 ueff (
+	twclklmn=12ns	twclkhmn=22ns
+	twpclmn=12ns	tsupcclkhmn=10ns
+	thdclkmn=20ns	tppcqhlty=17ns
+	tppcqhlmx=30ns	tpclkqlhty=22ns
+	tpclkqlhmx=35ns	tpclkqhlty=24ns
+	tpclkqhlmx=35ns
+	)
*$
*-------------------------------------------------------------------------
* 74390  COUNTER DECADE 4-BIT, ASYNCHRONOUS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   7-1-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*	    
.SUBCKT 74390   CKA_I CKB_I CLR_I   QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CKA      $D_HI $D_HI     QA $D_NC
+ D0_EFF IO_STD
U2 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CLOCK2   $D_HI $D_HI     QB QBBAR 
+ D0_EFF IO_STD
U3 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QB       $D_HI $D_HI     QC QCBAR 
+ D0_EFF IO_STD
U4 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CLOCK4   $D_HI $D_HI     QD QDBAR 
+ D0_EFF IO_STD
U390LOG LOGICEXP (6,6) DPWR DGND
+ CKA_I CKB_I CLR_I    QBBAR QCBAR QDBAR
+ CKA   CKB   CLR      CLRBAR CLOCK2 CLOCK4
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   CKA    = { CKA_I }
+   CKB    = { CKB_I }
+   CLR    = { CLR_I }
+   CLRBAR = { ~CLR }
+   CLOCK2 = { CKB & QDBAR }
+   CLOCK4 = { ~((QBBAR & QDBAR) | (QCBAR & QDBAR)) & CKB }
*
U390DLY PINDLY (4,0,3) DPWR DGND
+ QA QB QC QD
+ CKA CKB CLR
+ QA_O QB_O QC_O QD_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLOCKEDA = { CHANGED_HL(CKA,0) }
+   CLOCKEDB = { CHANGED_HL(CKB,0) }
+   CLEARED  = { CHANGED_LH(CLR,0) }
+
+ PINDLY:
+   QA_O = {
+     CASE (
+       CLOCKEDA & TRN_LH, DELAY(-1,12NS,20NS),
+       CLOCKEDA & TRN_HL, DELAY(-1,13NS,20NS),
+       DELAY(-1,24NS,39NS)
+       )
+     }
+   QB_O QD_O = {
+     CASE (
+       CLOCKEDB & TRN_LH, DELAY(-1,13NS,21NS),
+       CLOCKEDB & TRN_HL, DELAY(-1,14NS,21NS),
+       DELAY(-1,24NS,39NS)
+       )
+     }
+   QC_O = {
+     CASE (
+       CLEARED, DELAY(-1,24NS,39NS),
+       TRN_LH,  DELAY(-1,24NS,39NS),
+       DELAY(-1,26NS,39NS)
+       )
+     }
+
+ FREQ:
+   NODE           = CKA
+   MAXFREQ        = 25MEGHZ
+ FREQ:
+   NODE           = CKB
+   MAXFREQ        = 20MEGHZ
+ WIDTH:
+   NODE           = CKA
+   MIN_LO         = 20NS
+   MIN_HI         = 20NS
+ WIDTH:
+   NODE           = CKB
+   MIN_LO         = 25NS
+   MIN_HI         = 25NS
+ WIDTH:
+   NODE           = CLR
+   MIN_HI         = 20NS
+ SETUP_HOLD:
+   DATA(1)        = CLR
+   CLOCK HL       = CKA
+   RELEASETIME_HL = 25NS
+ SETUP_HOLD:
+   DATA(1)        = CLR
+   CLOCK HL       = CKB
+   RELEASETIME_HL = 25NS
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74393  COUNTER BINARY 4-BIT, ASYNCHRONOUS
*
* TTL LOGIC STANDARD TTL, S, LS DATA BOOK, APR 1988, TI
* JLS   6-30-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
* NOTICE: PROPAGATION DELAYS FOR A-TO-QB AND A-TO-QC WERE NOT SPECIFIED
*         IN THE DATA BOOK, SO THEY WERE INTERPOLATED FROM THE A-TO-QA AND
*         A-TO-QD PROPAGATION DELAYS
*	    
.SUBCKT 74393   A_I CLR_I   QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(1) DPWR DGND
+ $D_HI CLRBAR A    $D_HI $D_HI     QA $D_NC
+ D0_EFF  IO_STD
U2 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QA   $D_HI $D_HI     QB $D_NC 
+ D0_EFF  IO_STD
U3 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QB   $D_HI $D_HI     QC $D_NC 
+ D0_EFF  IO_STD
U4 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QC   $D_HI $D_HI     QD $D_NC 
+ D0_EFF  IO_STD
U5 BUFA(2) DPWR DGND
+ A_I   CLR_I
+ A     CLR
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
U6 INV DPWR DGND
+ CLR   CLRBAR 
+ D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
*
U393DLY PINDLY (4,0,2) DPWR DGND
+ QA QB QC QD
+ CLR A
+ QA_O QB_O QC_O QD_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLOCKED = { CHANGED_HL(A,0) }
+   CLEARED = { CHANGED_LH(CLR,0) }
+
+ PINDLY:
+ QA_O = {
+   CASE (
+     CLOCKED & TRN_LH, DELAY(-1,12NS,20NS),
+     CLOCKED & TRN_HL, DELAY(-1,13NS,20NS),
+     DELAY(-1,24NS,39NS)
+     )
+   }
+ QB_O = {
+   CASE (
+     CLOCKED, DELAY(-1,23NS,35NS), 	;GUESSED PROP DELAY--NOT IN DATA BOOK
+     DELAY(-1,24NS,39NS)
+     )
+   }
+ QC_O = {
+   CASE (
+     CLEARED, DELAY(-1,24NS,39NS),
+     DELAY(-1,33NS,50NS)     		;GUESSED PROP DELAY--NOT IN DATA BOOK
+     )
+   }
+ QD_O = {
+   CASE (
+     CLEARED, DELAY(-1,24NS,39NS),
+     DELAY(-1,40NS,60NS)
+     )
+   }
+
+ FREQ:
+   NODE           = A
+   MAXFREQ        = 25MEGHZ
+ WIDTH:
+   NODE           = A
+   MIN_LO         = 20NS
+   MIN_HI         = 20NS
+ WIDTH:
+   NODE           = CLR
+   MIN_HI         = 20NS
+ SETUP_HOLD:
+   DATA(1)        = CLR
+   CLOCK HL       = A
+   RELEASETIME_HL = 25NS
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74425  Quadruple Bus Buffers with 3-STATE Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* atl 	 9/26/89	Update interface and model names
*
.subckt 74425  GBAR A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UINV inv DPWR DGND
+	GBAR   G 
+	D0_GATE IO_STD IO_LEVEL={IO_LEVEL} 
UY buf3 DPWR DGND
+	A   G   Y 
+	D_425 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_425 utgate (
+	tplhty=8ns	tplhmx=13ns
+	tphlty=12ns	tphlmx=18ns
+	tpzhty=11ns	tpzhmx=17ns
+	tpzlty=16ns	tpzlmx=25ns
+	tphzty=5ns	tphzmx=8ns
+	tplzty=7ns	tplzmx=12ns
+	)
*$
*-------------------------------------------------------------------------
* 74426  Quadruple Bus Buffers with 3-STATE Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* atl 	 9/26/89	Update interface and model names
*
.subckt 74426  G A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UY buf3 DPWR DGND
+	A   G   Y 
+	D_426 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_426 utgate (
+	tplhty=8ns	tplhmx=13ns
+	tphlty=12ns	tphlmx=18ns
+	tpzhty=11ns	tpzhmx=18ns
+	tpzlty=16ns	tpzlmx=25ns
+	tphzty=10ns	tphzmx=16ns
+	tplzty=12ns	tplzmx=18ns
+	)
*
*$
*-------------------------------------------------------------------------
* 74490  COUNTER DECADE 4-BIT, ASYNCHRONOUS
*
* THE TTL DATA BOOK, VOLUME 2, STANDARD, S, LS, TTL; 1985, TI
* JLS   7-2-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*	    
.SUBCKT 74490   CLR_I SET9_I CLK_I   QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(1) DPWR DGND
+ SET9BAR CLRBAR   CLK      $D_HI $D_HI    QA $D_NC
+ D0_EFF  IO_STD
U2 JKFF(1) DPWR DGND
+ $D_HI   CLRBAR23 CLOCK2   $D_HI $D_HI    QB QBBAR 
+ D0_EFF  IO_STD
U3 JKFF(1) DPWR DGND
+ $D_HI   CLRBAR23 QB       $D_HI $D_HI    QC QCBAR 
+ D0_EFF  IO_STD
U4 JKFF(1) DPWR DGND
+ SET9BAR CLRBAR   CLOCK4   $D_HI $D_HI    QD QDBAR 
+ D0_EFF  IO_STD
*
U490LOG LOGICEXP (7,8) DPWR DGND
+ CLR_I  SET9_I  CLK_I QA QBBAR QCBAR QDBAR
+ CLR    SET9    CLK  CLRBAR23 CLOCK2 CLOCK4 CLRBAR SET9BAR
+ D0_GATE IO_STD
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   CLR      = { CLR_I }
+   CLRBAR   = { ~CLR }
+   SET9     = { SET9_I }
+   SET9BAR  = { ~SET9 }
+   CLK      = { CLK_I }
+   CLRBAR23 = { CLRBAR & SET9BAR }
+   CLOCK2   = { QA & QDBAR }
+   CLOCK4   = { ~( (QBBAR & QDBAR) | (QCBAR & QDBAR) ) & QA }
*
U490DLY PINDLY (4,0,3) DPWR DGND
+ QA QB QC QD
+ CLR SET9 CLK
+ QA_O QB_O QC_O QD_O
+ IO_STD
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLOCKED = { CHANGED_HL(CLK,0) }
+   CLEARED = { CHANGED_LH(CLR,0) }
+   SETNINE = { CHANGED_LH(SET9,0) }
+
+ PINDLY:
+   QA_O = {
+     CASE (
+       CLOCKED & TRN_LH, DELAY(-1,12NS,20NS),
+       CLOCKED & TRN_HL, DELAY(-1,13NS,20NS),
+       DELAY(-1,24NS,39NS)
+       )
+     }
+   QB_O = {
+     CASE (
+       SETNINE, DELAY(-1,20NS,36NS),
+       CLEARED, DELAY(-1,24NS,39NS),
+       TRN_LH,  DELAY(-1,24NS,39NS),
+       DELAY(-1,26NS,39NS)
+       )
+     }
+   QC_O = {
+     CASE (
+       SETNINE, DELAY(-1,20NS,36NS),
+       CLEARED, DELAY(-1,24NS,39NS),
+       TRN_LH,  DELAY(-1,32NS,54NS),
+       DELAY(-1,36NS,54NS)
+       )
+     }
+   QD_O = {
+     CASE (
+       TRN_LH,  DELAY(-1,24NS,39NS),
+       CLEARED, DELAY(-1,24NS,39NS),
+       DELAY(-1,26NS,39NS)
+       )
+     }
+
+ FREQ:
+   NODE           = CLK
+   MAXFREQ        = 25MEGHZ
+ WIDTH:
+   NODE           = CLK
+   MIN_LO         = 20NS
+   MIN_HI         = 20NS
+ WIDTH:
+   NODE           = CLR
+   MIN_HI         = 20NS
+   WHEN           = { SET9!='1 }
+ WIDTH:
+   NODE           = SET9
+   MIN_HI         = 20NS
+ SETUP_HOLD:
+   DATA(1)        = CLR
+   CLOCK HL       = CLK
+   RELEASETIME_HL = 25NS
+   WHEN           = { SET9!='1 }
+ SETUP_HOLD:
+   DATA(1)        = SET9
+   CLOCK HL       = CLK
+   RELEASETIME_HL = 25NS
*
.ENDS
*
*$

