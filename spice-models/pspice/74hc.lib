* Library of 74HC Family Digital Models
*
*  Copyright OrCAD, Inc. 1998 All Rights Reserved.
*
*
* $Revision:   1.3  $
* $Author:   RPEREZ  $
* $Date:   16 Apr 1998 14:34:06  $
*
*
*$
*---------
* 74HC00  Quadruple 2-input Positive-Nand Gates
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn   06/23/89	Update interface and model names
*
.subckt 74HC00  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(2) DPWR DGND
+	A B   Y 
+	D_HC00 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC00 ugate (
+	tplhty=9ns	tplhmx=23ns
+	tphlty=9ns	tphlmx=23ns
+	)
*$
*---------
* 74HC01  Quadruple 2-input Positive-Nand Gates with Open-Collector Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 74HC01  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(2) DPWR DGND
+	A B   Y 
+	D_HC01 IO_HC_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC01 ugate (
+	tplhty=13ns	tplhmx=31ns
+	tphlty=10ns	tphlmx=25ns
+	)
*$
*---------
* 74HC02  Quadruple 2-input Positive-Nor Gates
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 74HC02  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nor(2) DPWR DGND
+	A B   Y 
+	D_HC02 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC02 ugate (
+	tplhty=9ns	tplhmx=23ns
+	tphlty=9ns	tphlmx=23ns
+	)
*$
*---------
* 74HC03  Quadruple 2-input Positive-Nand Gates with Open-Collector Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 74HC03  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(2) DPWR DGND
+	A B   Y 
+	D_HC03 IO_HC_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC03 ugate (
+	tplhty=13ns	tplhmx=31ns
+	tphlty=10ns	tphlmx=25ns
+	)
*$
*---------
* 74HC04  Hex Inverters
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 74HC04  A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 inv DPWR DGND
+	A   Y 
+	D_H04C IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_H04C ugate (
+	tplhty=9ns	tplhmx=24ns
+	tphlty=9ns	tphlmx=24ns
+	)
*$
*---------
* 74HC05  Hex Inverters with Open-Collector Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn 	06/23/89	Update interface and model names
*
.subckt 74HC05  A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 inv DPWR DGND
+	A   Y 
+	D_HC05 IO_HC_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC05 ugate (
+	tplhty=13ns	tplhmx=29ns
+	tphlty=9ns	tphlmx=21ns
+	)
*$
*---------
* 74HC08  Quadruple 2-input Positive-And Gates
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 74HC08  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 and(2) DPWR DGND
+	A B   Y 
+	D_HC08 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC08 ugate (
+	tplhty=10ns	tplhmx=25ns
+	tphlty=10ns	tphlmx=25ns
+	)
*$
*---------
* 74HC09  Quadruple 2-input Positive-And Gates with Open-Collector Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn 	06/23/89	Update interface and model names
*
.subckt 74HC09  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 and(2) DPWR DGND
+	A B   Y 
+	D_HC09 IO_HC_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC09 ugate (
+	tplhty=13ns	tplhmx=31ns
+	tphlty=10ns	tphlmx=25ns
+	)
*$
*---------
* 74HC10  Triple 3-input Positive-Nand Gates
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 74HC10  A B C Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(3) DPWR DGND
+	A B C   Y 
+	D_HC10 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC10 ugate (
+	tplhty=10ns	tplhmx=24ns
+	tphlty=10ns	tphlmx=24ns
+	)
*$
*---------
* 74HC11  Triple 3-input Positive-And Gates
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	06/23/89	Update interface and model names
*
.subckt 74HC11  A B C Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 and(3) DPWR DGND
+	A B C   Y 
+	D_HC11 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC11 ugate (
+	tplhty=10ns	tplhmx=25ns
+	tphlty=10ns	tphlmx=25ns
+	)
*$
*---------
* 74HC14  Hex Schmitt-Trigger Inverters
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn 	06/26/89	Update interface and model names
*
.subckt 74HC14  A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* Note: These devices are modeled as simple inverters
*       Hysteresis is modeled in the AtoD interface
*
U1 inv DPWR DGND
+	A   Y 
+	D_HC14 IO_HC_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC14 ugate (
+	tplhty=12ns	tplhmx=31ns
+	tphlty=12ns	tphlmx=31ns
+	)
*$
*---------
* 74HC20  Dual 4-input Positive-Nand Gates
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn 	06/26/89	Update interface and model names
*
.subckt 74HC20  A B C D Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(4) DPWR DGND
+	A B C D   Y 
+	D_HC20 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC20 ugate (
+	tplhty=14ns	tplhmx=28ns
+	tphlty=14ns	tphlmx=28ns
+	)
*$
*---------
* 74HC21  Dual 4-input Positive-And Gates
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn 	06/26/89	Update interface and model names
*
.subckt 74HC21  A B C D Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 and(4) DPWR DGND
+	A B C D   Y 
+	D_HC21 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC21 ugate (
+	tplhty=14ns	tplhmx=28ns
+	tphlty=14ns	tphlmx=28ns
+	)
*$
*---------
* 74HC27  Triple 3-input Positive-Nor Gates
* 
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn 	06/26/89	Update interface and model names
*
.subckt 74HC27  A B C Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nor(3) DPWR DGND
+	A B C   Y 
+	D_HC27 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC27 ugate (
+	tplhty=10ns	tplhmx=23ns
+	tphlty=10ns	tphlmx=23ns
+	)
*$
*---------
* 74HC30  8-input Positive-Nand Gates
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn 	06/26/89	Update interface and model names
*
.subckt 74HC30  A B C D E F G H Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(8) DPWR DGND
+	A B C D E F G H   Y 
+	D_HC30 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC30 ugate (
+	tplhty=15ns	tplhmx=33ns
+	tphlty=15ns	tphlmx=33ns
+	)
*$
*---------
* 74HC32  Quadruple 2-input Positive-Or Gates
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn 	06/26/89	Update interface and model names
*
.subckt 74HC32  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 or(2) DPWR DGND
+	A B   Y 
+	D_HC32 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC32 ugate (
+	tplhty=10ns	tplhmx=25ns
+	tphlty=10ns	tphlmx=25ns
+	)
*$
*---------
* 74HC35  Hex Noninverters with Open-Collector Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn 	06/26/89	Update interface and model names
*
.subckt 74HC35  A Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 buf DPWR DGND
+	A   Y 
+	D_HC35 IO_HC_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC35 ugate (
+	tplhmx=28ns	tphlmx=28ns
+	)
*$
*---------
* 74HC36  Quadruple 2-input Positive-Nor Gate
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	08/10/89	Update interface and model names
*
.subckt 74HC36  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nor(2) DPWR DGND
+	A B   Y 
+	D_HC36 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC36 ugate (
+	tphlty=10ns	tphlmx=25ns
+	tplhty=10ns	tplhmx=25ns
+	)
*$
*--------
* 74HC42  DECODER BCD-DECIMAL 4-10 LINE
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   7-30-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74HC42   A_I B_I C_I D_I
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC42LOG LOGICEXP (4,14) DPWR DGND
+ A_I B_I C_I D_I
+ A   B   C   D
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   A    = { A_I }
+   B    = { B_I }
+   C    = { C_I }
+   D    = { D_I }
+   ABAR = { ~A }
+   BBAR = { ~B }
+   CBAR = { ~C }
+   DBAR = { ~D }
+   Y0   = { ~(DBAR & CBAR & BBAR & ABAR ) }
+   Y1   = { ~(DBAR & CBAR & BBAR & A    ) }
+   Y2   = { ~(DBAR & CBAR & B    & ABAR ) }
+   Y3   = { ~(DBAR & CBAR & B    & A    ) }
+   Y4   = { ~(DBAR & C    & BBAR & ABAR ) }
+   Y5   = { ~(DBAR & C    & BBAR & A    ) }
+   Y6   = { ~(DBAR & C    & B    & ABAR ) }
+   Y7   = { ~(DBAR & C    & B    & A    ) }
+   Y8   = { ~(D    & CBAR & BBAR & ABAR ) }
+   Y9   = { ~(D    & CBAR & BBAR & A    ) }
*
UHC42DLY PINDLY (10,0,4) DPWR DGND
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9
+ A B C D
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O Y9_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   Y0_O Y1_O Y2_O Y3_O Y4_O
+   Y5_O Y6_O Y7_O Y8_O Y9_O = { DELAY(-1,18NS,38NS) }
*
.ENDS
*
*$
*---------
* 75HC51  And-Or-Invert Gates
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	06/27/89	Update interface and model names
*
.subckt 74HC51  A1 B1 C1 D1 E1 F1 Y1 A2 B2 C2 D2 Y2
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 aoi(3,2) DPWR DGND
+	A1 B1 C1 D1 E1 F1   Y1 
+	D_HC51_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 aoi(2,2) DPWR DGND
+	A2 B2 C2 D2   Y2 
+	D_HC51_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC51_1 ugate (
+	tplhty=15ns	tplhmx=35ns
+	tphlty=15ns	tphlmx=35ns
+	)
*$
*---------
* 74HC73  Dual J-K Flip-Flops with Clear	 
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	06/28/89	Update interface and model names
*
.subckt 74HC73  CLK CLRBAR J K Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 jkff(1) DPWR DGND
+	$D_HI CLRBAR CLK   J K   Q QBAR 
+	D_HC73 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC73 ueff (
+	tppcqlhty=16ns	tppcqlhmx=39ns
+	tppcqhlty=16ns	tppcqhlmx=39ns
+	tpclkqlhty=13ns	tpclkqlhmx=32ns
+	tpclkqhlty=13ns	tpclkqhlmx=32ns
+	twclkhmx=20ns	twclkhty=20ns
+	twclklmx=20ns	twclklty=20ns
+	twpclmx=20ns	twpclty=20ns
+	tsudclkmx=30ns	tsudclkty=30ns
+	tsupcclkhmx=30ns	tsupcclkhty=30ns
+	)
*$
*---------
* 74HC74  Dual D-Type Positive-Edge-Triggered Flip-Flops w/ Preset & Clear
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	06/28/89	Update interface and model names
*
.subckt 74HC74  1CLRBAR 1D 1CLK 1PREBAR 1Q 1QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UFF1 dff(1) DPWR DGND
+	1PREBAR 1CLRBAR 1CLK   1D   1Q 1QBAR 
+	D_HC74 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC74 ueff (
+	twpclmn=25ns	twclklmn=20ns
+	twclkhmn=20ns	tsudclkmn=25ns
+	tsupcclkhmn=6ns	thdclkmn=0ns
+	tppcqlhty=20ns	tppcqlhmx=58ns
+	tppcqhlty=20ns	tppcqhlmx=58ns
+	tpclkqlhty=20ns	tpclkqlhmx=44ns
+	tpclkqhlty=20ns	tpclkqhlmx=44ns
+	)
*$
*---------
* 74HC75  4-bit bistable latches (dual 2-bit common clock)
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* muw	12/05/89	Created
*
.subckt 74HC75  1D 2D C 1Q 1QBAR 2Q 2QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(3) DPWR DGND
+	1D 2D C   1D_BUF 2D_BUF C_BUF 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U12 dltch(2) DPWR DGND
+	$D_HI $D_HI C_BUF   1D_BUF 2D_BUF   1Q 2Q 1QBAR 2QBAR 
+	D_HC75_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC75_1 ugff (
+	twghmx=100ns	tsudgmx=125ns
+	thdgmx=5ns	tpgqlhty=44ns
+	tpgqlhmx=165ns	tpgqhlty=44ns
+	tpgqhlmx=165ns	tpdqlhty=40ns
+	tpdqlhmx=150ns	tpdqhlty=40ns
+	tpdqhlmx=150ns
+	)
*$
*---------
* 74HC76  Dual J-K Flip-Flops with Preset and Clear
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	06/28/89	Update interface and model names
*
.subckt 74HC76  CLK PREBAR CLRBAR J K Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
*--NOTE--
* These Flip-Flops are negative-edge-triggered
*
U1 jkff(1) DPWR DGND
+	PREBAR CLRBAR CLK   J K   Q QBAR 
+	D_HC76 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC76 ueff (
+	tppcqlhty=16ns	tppcqlhmx=39ns
+	tppcqhlty=16ns	tppcqhlmx=39ns
+	tpclkqlhty=19ns	tpclkqlhmx=36ns
+	tpclkqhlty=19ns	tpclkqhlmx=36ns
+	twclkhmn=20ns	twclklmn=20ns
+	twpclmn=25ns	tsudclkmn=38ns
+	tsupcclkhmn=25ns
+	)
*$
*---------
* 74HC78  Dual J-K Flip-Flops with Preset, Common Clear, and Common Clock
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn    06/28/89    Update interface and model names
*
.subckt 74HC78  CLK CLRBAR 1PREBAR 1J 1K 1Q 1QBAR 2PREBAR 2J 2K 2Q 2QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(4) DPWR DGND
+	CLK CLRBAR 1PREBAR 2PREBAR   CLK_BUF CLRBAR_BUF 1PREB 2PREB 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U1 jkff(1) DPWR DGND
+	1PREB CLRBAR_BUF CLK_BUF   1J 1K   1Q 1QBAR 
+	D_HC78 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 jkff(1) DPWR DGND
+	2PREB CLRBAR_BUF CLK_BUF   2J 2K   2Q 2QBAR 
+	D_HC78 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC78 ueff (
+	tppcqlhty=16ns	tppcqlhmx=39ns
+	tppcqhlty=16ns	tppcqhlmx=39ns
+	tpCLKqlhty=13ns	tpCLKqlhmx=32ns
+	tpCLKqhlty=13ns	tpCLKqlhmx=32ns
+	twclkhmx=20ns	twclkhty=20ns
+	twclklmx=20ns	twclklty=20ns
+	twpclmx=20ns	twpclty=20ns
+	tsudclkmx=30ns	tsudclkty=30ns
+	tsupcclkhmx=30ns	tsupcclkhty=30ns
+	)
*$
*--------
* 74HC85A 4-BIT MAGNITUDE COMPARATOR
*
* THE HIGH-SPEED CMOS LOGIC DATA BOOK, 1988, TI
* KN   8-20-92      REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74HC85A P3_I P2_I P1_I P0_I Q3_I Q2_I Q1_I Q0_I
+ PGQ_I PEQ_I PLQ_I YPGQ_O YPEQ_O YPLQ_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC85ALOG LOGICEXP(11,14) DPWR DGND
+ P3_I P2_I P1_I P0_I Q3_I Q2_I Q1_I Q0_I PGQ_I PEQ_I PLQ_I
+ P3   P2   P1   P0   Q3   Q2   Q1   Q0   PGQ   PEQ   PLQ
+ YPGQ YPEQ YPLQ
+ D0_GATE
+ IO_HC IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
*   BUFFER:
+   P3     = { P3_I }
+   P2     = { P2_I }
+   P1     = { P1_I }
+   P0     = { P0_I }
+   Q3     = { Q3_I }
+   Q2     = { Q2_I }
+   Q1     = { Q1_I }
+   Q0     = { Q0_I }
+   PGQ    = { PGQ_I }
+   PEQ    = { PEQ_I }
+   PLQ    = { PLQ_I }
+
*   INTERMEDIATE TERMS:
+   C3     = { ~(P3 & Q3) }
+   C2     = { ~(P2 & Q2) }
+   C1     = { ~(P1 & Q1) }
+   C0     = { ~(P0 & Q0) }
+   P3C3    = { P3 & C3 }
+   P2C2    = { P2 & C2 }
+   P1C1    = { P1 & C1 }
+   P0C0    = { P0 & C0 }
+   Q3C3    = { Q3 & C3 }
+   Q2C2    = { Q2 & C2 }
+   Q1C1    = { Q1 & C1 }
+   Q0C0    = { Q0 & C0 }
+   D3      = { ~(P3C3 | Q3C3) }
+   D2      = { ~(P2C2 | Q2C2) }
+   D1      = { ~(P1C1 | Q1C1) }
+   D0      = { ~(P0C0 | Q0C0) }
+   D32     = { D3 & D2 }
+   D31     = { D32 & D1 }
+   D30     = { D31 & D0 }
+
*   OUTPUT ASSIGNMENTS:
+   YPGQ  = { ~Q3C3 & ~(Q2C2 & D3) & ~(Q1C1 & D32) & ~(Q0C0 & D31) &
+             ~(PLQ & D30) & ~(PEQ & D30) }
+   YPEQ  = { D30 & PEQ }
+   YPLQ  = { ~(PEQ & D30) & ~(PGQ & D30) & ~(P0C0 & D31) & ~(P1C1 & D32) &
+             ~(P2C2 & D3) & ~P3C3 }
*
UHC85ADLY PINDLY (3,0,11) DPWR DGND
+ YPGQ YPEQ YPLQ
+ P3 P2 P1 P0 Q3 Q2 Q1 Q0 PGQ PEQ PLQ
+ YPGQ_O YPEQ_O YPLQ_O
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+  DATA_CHANGE = { CHANGED(P3,0) | CHANGED(P2,0) | CHANGED(P1,0) | CHANGED(P0,0)
+              | CHANGED(Q3,0) | CHANGED(Q2,0) | CHANGED(Q1,0) | CHANGED(Q0,0) }
+  PEQ_CHANGE   = { CHANGED(PEQ,0) }
+  PGEQ_CHANGE  = { CHANGED(PGQ,0) | CHANGED(PEQ,0) }
+  PLEQ_CHANGE  = { CHANGED(PLQ,0) | CHANGED(PEQ,0) }
+
+ PINDLY:
+   YPGQ_O  =  {
+     CASE(
+       DATA_CHANGE, DELAY(-1,26NS,58NS),
+       PLEQ_CHANGE, DELAY(-1,21NS,50NS),
+                    DELAY(-1,27NS,59NS)  ;DEFAULT
+     )
+   }
+
+   YPEQ_O  =  {
+     CASE(
+       DATA_CHANGE, DELAY(-1,22NS,50NS),
+       PEQ_CHANGE, DELAY(-1,17NS,37NS),
+                    DELAY(-1,23NS,51NS)  ;DEFAULT
+     )
+   }
+
+   YPLQ_O  =  {
+     CASE(
+       DATA_CHANGE, DELAY(-1,26NS,58NS),
+       PGEQ_CHANGE, DELAY(-1,24NS,50NS),
+                    DELAY(-1,27NS,59NS)  ;DEFAULT
+     )
+   }
*
.ENDS
*
*$
*---------
* 74HC86  Quadruple 2-input Exclusive-Or Gates
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	06/29/89	Update interface and model names
*
.subckt 74HC86  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 xor DPWR DGND
+	A B   Y 
+	D_HC86 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC86 ugate (
+	tplhty=12ns	tplhmx=25ns
+	tphlty=12ns	tphlmx=25ns
+	)
*$
*---------
* 74HC93  COUNTER BINARY 4-BIT, ASYNCHRONOUS
*
* HIGH SPEED CMOS LOGIC FAMILY BOOK, 1991, PHILIPS SEMICONDUCTORS
* JLS   6-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
* NOTICE -- THE CKA TO QD PIN DELAY IS NOT INCLUDED IN THIS MODEL SINCE
*           THE DIV2 AND DIV8 SECTIONS OF THE COUNTER ACT INDEPENDENTLY. 
*
.SUBCKT 74HC93   CKA_I CKB_I R01_I R02_I   QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CKA   $D_HI $D_HI     QA $D_NC
+ D0_EFF  IO_HC
U2 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CKB   $D_HI $D_HI     QB $D_NC 
+ D0_EFF  IO_HC
U3 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QB    $D_HI $D_HI     QC $D_NC 
+ D0_EFF  IO_HC
U4 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QC    $D_HI $D_HI     QD $D_NC 
+ D0_EFF  IO_HC
U5 BUFA(4) DPWR DGND
+ CKA_I CKB_I R01_I R02_I   CKA CKB R01 R02
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U6 NAND(2) DPWR DGND
+ R01 R02   CLRBAR 
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
*
UHC93DLY PINDLY (4,0,5) DPWR DGND
+ QA QB QC QD
+ CKA CKB CLRBAR R01 R02
+ QA_O QB_O QC_O QD_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLOCKEDA = { CHANGED_HL(CKA,0) }
+   CLOCKEDB = { CHANGED_HL(CKB,0) }
+   CLEARED  = { CHANGED_HL(CLRBAR,0) }
+
+ PINDLY:
+ QA_O = {
+   CASE (
+     CLOCKEDA, DELAY(-1,15NS,31NS),
+     DELAY(-1,18NS,39NS)
+     )
+   }
+ QB_O = {
+   CASE (
+     CLOCKEDB, DELAY(-1,16NS,34NS),
+     DELAY(-1,18NS,39NS)
+     )
+   }
+ QC_O = {
+   CASE (
+     CLEARED, DELAY(-1,18NS,39NS),
+     DELAY(-1,22NS,46NS)
+     )
+   }
+ QD_O = {
+   CASE (
+     CLEARED, DELAY(-1,18NS,39NS),
+     DELAY(-1,29NS,61NS)
+     )
+   }
+
+ FREQ:
+   NODE           = CKA
+   MAXFREQ        = 24MEGHZ
+ FREQ:
+   NODE           = CKB
+   MAXFREQ        = 24MEGHZ
+ WIDTH:
+   NODE           = CKA
+   MIN_LO         = 20NS
+   MIN_HI         = 20NS
+ WIDTH:
+   NODE           = CKB
+   MIN_LO         = 20NS
+   MIN_HI         = 20NS
+ WIDTH:
+   NODE           = R01
+   MIN_HI         = 20NS
+ WIDTH:
+   NODE           = R02
+   MIN_HI         = 20NS
+ SETUP_HOLD:
+   DATA(2)        = R01 R02
+   CLOCK HL       = CKA
+   RELEASETIME_HL = 13NS
+   WHEN           = { CHANGED(CLRBAR,13NS) }
+ SETUP_HOLD:
+   DATA(2)        = R01 R02
+   CLOCK HL       = CKB
+   RELEASETIME_HL = 13NS
+   WHEN           = { CHANGED(CLRBAR,13NS) }
*
.ENDS
*
*$
*--------
* 74HC95   4-BIT PARALLEL SHIFT REGISTERS
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, 1988, HITACHI AMERICA
* KN   7-6-92      REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74HC95   MODE_I CLK1_I CLK2_I SER_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR   DGND=$G_DGND
+ PARAMS:   MNTYMXDLY=0    IO_LEVEL=0
*
UHC95LOG LOGICEXP(11,13) DPWR DGND
+ MODE_I CLK1_I CLK2_I SER_I A_I B_I C_I D_I QA QB QC
+ MODE CLK1 CLK2 SER A B C D CLK DA DB DC DD
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   MODE = { MODE_I }
+   CLK1 = { CLK1_I }
+   CLK2 = { CLK2_I }
+   SER = { SER_I }
+   A   = { A_I }
+   B   = { B_I }
+   C   = { C_I }
+   D   = { D_I }
+
* INTERMEDIATE TERM
+   MODEBAR = { ~MODE }
+
+   CLK = { ~((MODEBAR  & CLK1) | (MODE  & CLK2)) }
+   DA  = { (MODEBAR  & SER)    | (MODE  & A) }
+   DB  = { (MODEBAR  & QA) | (MODE  & B) }
+   DC  = { (MODEBAR  & QB) | (MODE  & C) }
+   DD  = { (MODEBAR  & QC) | (MODE  & D) }
*
U1 DFF(4) DPWR DGND $D_HI $D_HI CLK
+ DA DB DC DD QA QB QC QD
+ $D_NC $D_NC $D_NC $D_NC
+ D0_EFF  IO_HC
*
UHC95DLY PINDLY (4,0,8) DPWR DGND
+ QA QB QC QD
+ CLK1 CLK2 MODE SER A B C D
+ QA_O QB_O QC_O QD_O
+ IO_HC  MNTYMXDLY={MNTYMXDLY}  IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+    CLK = { CHANGED_HL(CLK1,0) | CHANGED_HL(CLK2,0) }
+
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CLK & TRN_LH,  DELAY(-1,17NS,36NS),
+       CLK & TRN_HL,  DELAY(-1,17NS,43NS),
+                      DELAY(-1,18NS,44NS)  ;DEFAULT
+       )
+     }
+
+ FREQ:
+   NODE = CLK1
+   MAXFREQ = 16MEG
+
+ FREQ:
+   NODE = CLK2
+   MAXFREQ = 16MEG
+
+ WIDTH:
+   NODE = CLK1
+   MIN_HI = 20NS
+   MIN_LO = 20NS
+
+ WIDTH:
+   NODE = CLK2
+   MIN_HI = 20NS
+   MIN_LO = 20NS
+
+ SETUP_HOLD:
+   DATA(1) SER
+   CLOCK HL = CLK1
+   SETUPTIME = 25NS
+   HOLDTIME = 10NS
+   WHEN = { (MODE!='1 ^ CHANGED(MODE,0)) }
+
+ SETUP_HOLD:
+   DATA(4) A  B  C  D
+   CLOCK HL = CLK2
+   SETUPTIME = 25NS
+   HOLDTIME = 10NS
+   WHEN = { (MODE!='0 ^ CHANGED(MODE,0)) }
+
*
.ENDS
*
*
*$
*---------
* 74HC107  Dual J-K Flip-Flops with Clear
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	06/29/89	Update interface and model names
*
.subckt 74HC107  CLK CLRBAR J K Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 jkff(1) DPWR DGND
+	$D_HI CLRBAR CLK   J K   Q QBAR 
+	D_HC107 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC107 ueff (
+	tppcqlhty=25ns	tppcqlhmx=39ns
+	tppcqhlty=25ns	tppcqhlmx=39ns
+	tpclkqlhty=20ns	tpclkqlhmx=32ns
+	tpclkqhlty=20ns	tpclkqhlmx=32ns
+	twclkhmx=20ns	twclkhty=20ns
+	twclklmx=20ns	twclklty=20ns
+	twpclmx=25ns	twpclty=25ns
+	tsudclkmx=25ns	tsudclkty=25ns
+	tsupcclkhmx=25ns	tsupcclkhty=25ns
+	)
*$
*---------	 
* 74HC109  Dual J-Kbar Positive-Edge-Triggered Flip-Flops w/ Preset & Clear
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	06/30/89	Update interface and model names
*
.subckt 74HC109  CLK PREBAR CLRBAR J KBAR Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 jkff(1) DPWR DGND
+	PREBAR CLRBAR CLKBAR   J K   Q QBAR 
+	D_HC109 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 inva(2) DPWR DGND
+	KBAR CLK   K CLKBAR 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC109 ueff (
+	tppcqlhty=15ns	tppcqlhmx=58ns
+	tppcqhlty=15ns	tppcqhlmx=58ns
+	tpclkqlhty=15ns	tpclkqlhmx=44ns
+	tpclkqhlty=15ns	tpclkqhlmx=44ns
+	twclkhmx=20ns	twclklmx=20ns
+	twclkhty=20ns	twclklty=20ns
+	twpclmx=25ns	twpclty=25ns
+	tsudclkmx=25ns	tsudclkty=25ns
+	tsupcclkhmx=6ns	tsupcclkhty=6ns
+	)
*$
*---------
* 74HC112  Dual J-K Negative-Edge-Triggered Flip-Flops with Preset & Clear
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	07/05/89	Update interface and model names
*
.subckt 74HC112  CLK PREBAR CLRBAR J K Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 jkff(1) DPWR DGND
+	PREBAR CLRBAR CLK   J K   Q QBAR 
+	D_HC112 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC112 ueff (
+	tppcqlhty=16ns	tppcqlhmx=41ns
+	tppcqhlty=16ns	tppcqhlmx=41ns
+	tpclkqlhty=16ns	tpclkqlhmx=31ns
+	tpclkqhlty=16ns	tpclkqhlmx=31ns
+	twclkhmx=25ns	twclkhty=25ns
+	twclklmx=25ns	twclklty=25ns
+	twpclmx=25ns	twpclty=25ns
+	tsudclkmx=25ns	tsudclkty=25ns
+	tsupcclkhmx=25ns	tsupcclkhty=25ns
+	)
*$
*---------
* 74HC113  Dual J-K Negative-Edge-Triggered Flip-Flops with Preset
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	07/05/89	Update interface and model names
*
.subckt 74HC113  CLK PREBAR J K Q QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 jkff(1) DPWR DGND
+	PREBAR $D_HI CLK   J K   Q QBAR 
+	D_HC113 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC113 ueff (
+	tppcqlhty=18ns	tppcqlhmx=41ns
+	tppcqhlty=18ns	tppcqhlmx=41ns
+	tpclkqlhty=19ns	tpclkqlhmx=35ns
+	tpclkqhlty=19ns	tpclkqhlmx=35ns
+	twclkhmx=20ns	twclkhty=20ns
+	twclklmx=20ns	twclklty=20ns
+	twpclmx=25ns	twpclty=25ns
+	tsudclkmx=25ns	tsudclkmn=25ns
+	tsupcclkhmx=6ns	tsupcclkhmn=6ns
+	)
*$
*---------
* 74HC114  Dual J-K Negative-Edge-Triggered Flip-Flops with Preset & Common Clear, & Common Clock
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	07/05/89	Update interface and model names
*
.subckt 74HC114  CLK CLRBAR 1PREBAR 1J 1K 1Q 1QBAR 2PREBAR 2J 2K 2Q 2QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UIBUF bufa(4) DPWR DGND
+	CLK CLRBAR 1PREBAR 2PREBAR   CLK_BUF CLRBAR_BUF 1PREB 2PREB 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U1 jkff(1) DPWR DGND
+	1PREB CLRBAR_BUF CLK_BUF   1J 1K   1Q 1QBAR 
+	D_HC114 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 jkff(1) DPWR DGND
+	2PREB CLRBAR_BUF CLK_BUF   2J 2K   2Q 2QBAR 
+	D_HC114 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC114 ueff (
+	tppcqlhty=20ns	tppcqlhmx=44ns
+	tppcqhlty=20ns	tppcqhlmx=44ns
+	tpclkqlhty=19ns	tpclkqlhmx=44ns
+	tpclkqhlty=19ns	tpclkqhlmx=44ns
+	twclkhmx=25ns	twclkhty=25ns
+	twclklmx=25ns	twclklty=25ns
+	twpclmx=25ns	twpclty=25ns
+	tsudclkmx=25ns	tsudclkty=25ns
+	tsupcclkhmx=25ns	tsupcclkhty=25ns
+	)
*$
*---------
* 74HC125  Quadruple Bus Buffer with 3-state Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	07/05/89	Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC125  A GBAR Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 buf3 DPWR DGND
+	A   G   Y 
+	D_HC125 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 inv DPWR DGND
+	GBAR   G 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC125 utgate (
+	tplhty=14ns	tplhmx=30ns
+	tphlty=14ns	tphlmx=30ns
+	tpzhty=14ns	tpzhmx=30ns
+	tpzlty=14ns	tpzlmx=30ns
+	tphzty=15ns	tphzmx=30ns
+	tplzty=15ns	tplzmx=30ns
+	)
*$
*---------
* 74HC126  Quadruple Bus Buffer with 3-state Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	07/05/89	Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC126  A G Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 buf3 DPWR DGND
+	A   G   Y 
+	D_HC126 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC126 utgate (
+	tplhty=14ns	tplhmx=30ns
+	tphlty=14ns	tphlmx=30ns
+	tpzhty=16ns	tpzhmx=30ns
+	tpzlty=16ns	tpzlmx=30ns
+	tphzty=17ns	tphzmx=30ns
+	tplzty=17ns	tplzmx=30ns
+	)
*$
*---------
* 74HC132  Quadruple 2-input Positive-Nand Schmitt Triggers
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	07/05/89	Update interface and model names
*
.subckt 74HC132  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* Note: These devices are modeled as simple Nand gates.
*       Hysteresis is modeled by the AtoD interface.
*
U1 nand(2) DPWR DGND
+	A B   Y 
+	D_HC132 IO_HC_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC132 ugate (
+	tplhty=18ns	tplhmx=31ns
+	tphlty=18ns	tphlmx=31ns
+	)
*$
*---------
* 74HC133  13-input Positive-Nand Gates
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	07/05/89	Update interface and model names
*
.subckt 74HC133  A B C D E F G H I J K L M Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(13) DPWR DGND
+	A	B	C	D	E	F	G	H	I
+	J	K	L	M
+	Y
+	D_HC133 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC133 ugate (
+	tplhty=16ns	tplhmx=38ns
+	tphlty=16ns	tphlmx=38ns
+	)
*$
*---------
* 74HC137  DECODER/DEMULTIPLEXER 3-8 LINE WITH ADDRESS LATCHES
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   8-4-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*    
.SUBCKT 74HC137   G1_I G2BAR_I GLBAR_I A_I B_I C_I
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 DLTCH(3) DPWR DGND
+ $D_HI $D_HI LATCHEN
+  A     B     C
+ QA    QB    QC
+ QABAR QBBAR QCBAR
+ D0_GFF  IO_HC
*
UHC137LOG LOGICEXP (12,14) DPWR DGND
+ G1_I G2BAR_I GLBAR_I A_I B_I C_I QA QB QC QABAR QBBAR QCBAR
+              GLBAR   A   B   C   LATCHEN ENABLE
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   G1      = { G1_I }
+   G2BAR   = { G2BAR_I }
+   GLBAR   = { GLBAR_I }
+   A       = { A_I }
+   B       = { B_I }
+   C       = { C_I }
+   LATCHEN = { ~GLBAR }
+   ENABLE  = { G1 & ~G2BAR }
+   Y0      = { ~(ENABLE & QCBAR & QBBAR & QABAR) }
+   Y1      = { ~(ENABLE & QCBAR & QBBAR & QA   ) }
+   Y2      = { ~(ENABLE & QCBAR & QB    & QABAR) }
+   Y3      = { ~(ENABLE & QCBAR & QB    & QA   ) }
+   Y4      = { ~(ENABLE & QC    & QBBAR & QABAR) }
+   Y5      = { ~(ENABLE & QC    & QBBAR & QA   ) }
+   Y6      = { ~(ENABLE & QC    & QB    & QABAR) }
+   Y7      = { ~(ENABLE & QC    & QB    & QA   ) }
*
UHC137DLY PINDLY (8,0,5) DPWR DGND
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7
+ ENABLE GLBAR A B C
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ABLE  = { CHANGED(ENABLE,0) }
+   ABLEL = { CHANGED(GLBAR,0) }
+   ADDR  = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+
+ PINDLY:
+   Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O = {
+     CASE (
+       ABLE , DELAY(-1,17NS,36NS),
+       ABLEL, DELAY(-1,22NS,48NS),
+       ADDR , DELAY(-1,23NS,48NS),
+       DELAY(-1,23NS,48NS)
+       )
+     }
+
+ WIDTH:
+   NODE      = GLBAR
+   MIN_LO    = 20NS
+ SETUP_HOLD:
+   DATA(3)   = A B C
+   CLOCK LH  = GLBAR
+   SETUPTIME = 19NS
+   HOLDTIME  =  5NS
*
.ENDS
*
*$
*---------
* 74HC138  DECODER/DEMULTIPLEXER 3-8 LINE
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   8-4-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*    
.SUBCKT 74HC138   G1_I G2ABAR_I G2BBAR_I A_I B_I C_I
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC138LOG LOGICEXP (6,9) DPWR DGND
+ G1_I G2ABAR_I G2BBAR_I A_I B_I C_I
+ ENABLE
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   G1     = { G1_I }
+   G2ABAR = { G2ABAR_I }
+   G2BBAR = { G2BBAR_I }
+   A      = { A_I }
+   B      = { B_I }
+   C      = { C_I }
+   ABAR   = { ~A }
+   BBAR   = { ~B }
+   CBAR   = { ~C }
+   ENABLE = { ~G2ABAR & ~G2BBAR & G1 }
+   Y0     = { ~(ENABLE & CBAR & BBAR & ABAR) }
+   Y1     = { ~(ENABLE & CBAR & BBAR & A   ) }
+   Y2     = { ~(ENABLE & CBAR & B    & ABAR) }
+   Y3     = { ~(ENABLE & CBAR & B    & A   ) }
+   Y4     = { ~(ENABLE & C    & BBAR & ABAR) }
+   Y5     = { ~(ENABLE & C    & BBAR & A   ) }
+   Y6     = { ~(ENABLE & C    & B    & ABAR) }
+   Y7     = { ~(ENABLE & C    & B    & A   ) }
*
UHC138DLY PINDLY (8,0,1) DPWR DGND
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7
+ ENABLE
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ABLE = { CHANGED(ENABLE,0) }
+
+ PINDLY:
+   Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O = {
+     CASE (
+       ABLE, DELAY(-1,18NS,39NS),
+       DELAY(-1,18NS,45NS)
+       )
+     }
*
.ENDS
*
*$
*--------
* 74HC139  DECODER/DEMULTIPLEXER 2-4 LINE
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   8-1-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*    
.SUBCKT 74HC139   GBAR_I A_I B_I   Y0_O Y1_O Y2_O Y3_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC139LOG LOGICEXP (3,7) DPWR DGND
+ GBAR_I A_I B_I
+ GBAR   A   B
+ Y0 Y1 Y2 Y3
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   GBAR   = { GBAR_I }
+   A      = { A_I }
+   B      = { B_I }
+   ABAR   = { ~A }
+   BBAR   = { ~B }
+   ENABLE = { ~GBAR }
+   Y0     = { ~(ENABLE & BBAR & ABAR ) }
+   Y1     = { ~(ENABLE & BBAR & A    ) }
+   Y2     = { ~(ENABLE & B    & ABAR ) }
+   Y3     = { ~(ENABLE & B    & A    ) }
*
UHC139DLY PINDLY (4,0,3) DPWR DGND
+ Y0 Y1 Y2 Y3
+ GBAR A B
+ Y0_O Y1_O Y2_O Y3_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ABLE = { CHANGED(GBAR,0) }
+   ADDR = { CHANGED(A,0) | CHANGED(B,0) }
+
+ PINDLY:
+   Y0_O Y1_O Y2_O Y3_O = {
+     CASE (
+       ABLE, DELAY(-1,11NS,44NS),
+       ADDR, DELAY(-1,14NS,44NS),
+       DELAY(-1,14NS,44NS)
+       )
+     }
*
.ENDS
*
*$
*---------
* 74HC147  PRIORITY ENCODER 10-4 LINE
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74HC147   IN1_I IN2_I IN3_I IN4_I IN5_I IN6_I IN7_I IN8_I IN9_I
+ A_O B_O C_O D_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC147LOG LOGICEXP (9,13) DPWR DGND
+ IN1_I IN2_I IN3_I IN4_I IN5_I IN6_I IN7_I IN8_I IN9_I
+ IN1   IN2   IN3   IN4   IN5   IN6   IN7   IN8   IN9
+ A B C D
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+ IN1    = { IN1_I }
+ IN2    = { IN2_I }
+ IN3    = { IN3_I }
+ IN4    = { IN4_I }
+ IN5    = { IN5_I }
+ IN6    = { IN6_I }
+ IN7    = { IN7_I }
+ IN8    = { IN8_I }
+ IN9    = { IN9_I }
+ IN1BAR = { ~IN1 }
+ IN2BAR = { ~IN2 }
+ IN3BAR = { ~IN3 }
+ IN4BAR = { ~IN4 }
+ IN5BAR = { ~IN5 }
+ IN6BAR = { ~IN6 }
+ IN7BAR = { ~IN7 }
+ IN8BAR = { ~IN8 }
+ IN9BAR = { ~IN9 }
+
+ D      = { IN8 & IN9 }
+ C      = { ~(D & (IN4BAR | IN5BAR | IN6BAR | IN7BAR)) }
+ B      = { ~(D & ((IN2BAR & IN4 & IN5) |
+                       (IN3BAR & IN4 & IN5) | IN6BAR | IN7BAR)) }
+ A      = { ~(IN9BAR | D & ((IN1BAR & IN2 & IN4 & IN6) |
+                       (IN3BAR & IN4 & IN6) | (IN5BAR & IN6) | IN7BAR)) }
*
UHC147DLY PINDLY (4,0,9) DPWR DGND
+ A B C D
+ IN1 IN2 IN3 IN4 IN5 IN6 IN7 IN8 IN9
+ A_O B_O C_O D_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   A_O B_O C_O D_O = { DELAY(-1,25NS,48NS) }
*
.ENDS
*
*$
*---------
* 74HC148  PRIORITY ENCODER 8-3 LINE
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   8-26-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74HC148   IN0_I IN1_I IN2_I IN3_I IN4_I IN5_I IN6_I IN7_I EI_I
+ A0_O A1_O A2_O GS_O EO_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC148LOG LOGICEXP (9,14) DPWR DGND
+ IN0_I IN1_I IN2_I IN3_I IN4_I IN5_I IN6_I IN7_I EI_I
+ IN0   IN1   IN2   IN3   IN4   IN5   IN6   IN7   EI
+ A0 A1 A2 GS EO
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+ IN0    = { IN0_I }
+ IN1    = { IN1_I }
+ IN2    = { IN2_I }
+ IN3    = { IN3_I }
+ IN4    = { IN4_I }
+ IN5    = { IN5_I }
+ IN6    = { IN6_I }
+ IN7    = { IN7_I }
+ EI     = { EI_I }
+ IN0BAR = { ~IN0 }
+ IN1BAR = { ~IN1 }
+ IN2BAR = { ~IN2 }
+ IN3BAR = { ~IN3 }
+ IN4BAR = { ~IN4 }
+ IN5BAR = { ~IN5 }
+ IN6BAR = { ~IN6 }
+ IN7BAR = { ~IN7 }
+ EIBAR  = { ~EI }
+
+ A0     = { ~(EIBAR & ((IN1BAR & IN2 & IN4 & IN6) |
+                       (IN3BAR & IN4 & IN6) | (IN5BAR & IN6) | IN7BAR)) }
+ A1     = { ~(EIBAR & ((IN2BAR & IN4 & IN5) |
+                       (IN3BAR & IN4 & IN5) | IN6BAR | IN7BAR)) }
+ A2     = { ~(EIBAR & (IN4BAR | IN5BAR | IN6BAR | IN7BAR)) }
+ EO     = { ~(IN0 & IN1 & IN2 & IN3 & IN4 & IN5 & IN6 & IN7 & EIBAR) }
+ GS     = { ~(EO & EIBAR) }
*
UHC148DLY PINDLY (5,0,9) DPWR DGND
+ A0 A1 A2 GS EO
+ IN0 IN1 IN2 IN3 IN4 IN5 IN6 IN7 EI
+ A0_O A1_O A2_O GS_O EO_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   DATAHI   = { IN7=='1 & IN6=='1 & IN5=='1 & IN4=='1 &
+                IN3=='1 & IN2=='1 & IN1=='1 & IN0=='1 }
+   ENABLE   = { CHANGED(EI,0) }
+
+ PINDLY:
+   A2_O A1_O A0_O = {
+     CASE (
+       ENABLE, DELAY(-1,26NS,49NS),
+       DELAY(-1,23NS,45NS)
+       )
+     }
+   GS_O = {
+     CASE (
+       ENABLE, DELAY(-1,19NS,36NS),
+       DELAY(-1,25NS,48NS)
+       )
+     }
+   EO_O = {
+     CASE (
+       ENABLE, DELAY(-1,22NS,41NS),
+       DELAY(-1,20NS,38NS)
+       )
+     }
*
.ENDS
*
*$
*---------
* 74HC151  MULTIPLEXER/DATA SELECTOR 8-1 LINE
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG. 1989, TI
* TC  08/21/92  REMODELED USING LOGICEXP, PINDLY, & CONSTRAINT DEVICES
*
* NOTE: THE LOGIC FROM 74151A IS USED TO MODEL THIS DEVICE.
*
.SUBCKT 74HC151 GBAR_I A_I B_I C_I D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I
+ Y_O W_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC151LOG LOGICEXP(12,14) DPWR DGND
+ GBAR_I A_I B_I C_I D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I
+ GBAR A B C D0 D1 D2 D3 D4 D5 D6 D7 W Y
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   GBAR = { GBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D0 = { D0_I }
+   D1 = { D1_I }
+   D2 = { D2_I }
+   D3 = { D3_I }
+   D4 = { D4_I }
+   D5 = { D5_I }
+   D6 = { D6_I }
+   D7 = { D7_I }
+   IA = { ~A }
+   IB = { ~B }
+   IC = { ~C }
+   IG = { ~GBAR }
+   ID0 = { D0 & IA & IB & IC & IG }
+   ID1 = { D1 & A & IB & IC & IG }
+   ID2 = { D2 & IA & B & IC & IG }
+   ID3 = { D3 & A & B & IC & IG }
+   ID4 = { D4 & IA & IB & C & IG }
+   ID5 = { D5 & A & IB & C & IG }
+   ID6 = { D6 & IA & B & C & IG }
+   ID7 = { D7 & A & B & C & IG }
+   W = { ~(ID0 | ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7) }
+   Y = { ~W }
*
UHC151DLY PINDLY (2,0,12) DPWR DGND
+ W Y
+ GBAR A B C D0 D1 D2 D3 D4 D5 D6 D7
+ W_O Y_O
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   DATA = { CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) |
+     CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0) }
+   SELECT = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+ PINDLY:
+   Y_O W_O = {
+     CASE(
+       SELECT, DELAY(-1,30NS,63NS),
+       DATA, DELAY(-1,23NS,49NS),
+       CHANGED(GBAR,0), DELAY(-1,15NS,32NS),
+       DELAY(-1,31NS,64NS)
+       )
+     }
*
.ENDS
*
*$
*---------
* 74HC152  MULTIPLEXER/DATA SELECTOR 8-1 LINE
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG. 1989, TI
* TC  08/24/92  REMODELED USING LOGICEXP, PINDLY, & CONSTRAINT DEVICES
*
* NOTE: THE LOGIC FROM 54152A IS USED TO MODEL TO THIS DEVICE.
*
.SUBCKT 74HC152 A_I B_I C_I D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I W_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC152LOG LOGICEXP(11,12) DPWR DGND
+ A_I B_I C_I D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I
+ A B C D0 D1 D2 D3 D4 D5 D6 D7 W
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D0 = { D0_I }
+   D1 = { D1_I }
+   D2 = { D2_I }
+   D3 = { D3_I }
+   D4 = { D4_I }
+   D5 = { D5_I }
+   D6 = { D6_I }
+   D7 = { D7_I }
+   IA = { ~A }
+   IB = { ~B }
+   IC = { ~C }
+   ID0 = { D0 & IA & IB & IC }
+   ID1 = { D1 & A & IB & IC }
+   ID2 = { D2 & IA & B & IC }
+   ID3 = { D3 & A & B & IC }
+   ID4 = { D4 & IA & IB & C }
+   ID5 = { D5 & A & IB & C }
+   ID6 = { D6 & IA & B & C }
+   ID7 = { D7 & A & B & C }
+   W = { ~(ID0 | ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7) }
*
UHC152DLY PINDLY (1,0,11) DPWR DGND
+ W
+ A B C D0 D1 D2 D3 D4 D5 D6 D7
+ W_O
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   DATA = { CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) |
+     CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0) }
+   SELECT = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+ PINDLY:
+   W_O = {
+     CASE(
+       SELECT, DELAY(-1,18NS,43NS),
+       DATA, DELAY(-1,14NS,33NS),
+       DELAY(-1,19NS,44NS)
+       )
+     }
*
.ENDS
*
*$
*---------
* 74HC153  DUAL 4-LINE TO 1-LINE DATA SELECTORS/MULTIPLEXERS
*
* High Speed CMOS Logic Data Book, 1989, TI
* JSW   8/12/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices
* NOTICE:  Logic diagram from 74153 was used.
*
.SUBCKT 74HC153 G1BAR_I G2BAR_I A_I B_I 1C0_I 1C1_I 1C2_I  1C3_I
+ 2C0_I 2C1_I 2C2_I 2C3_I Y1_O Y2_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC153LOG LOGICEXP(12,14) DPWR DGND
+ G1BAR_I G2BAR_I A_I B_I 1C0_I 1C1_I 1C2_I 1C3_I 2C0_I 2C1_I 2C2_I 2C3_I
+ G1BAR G2BAR A B 1C0 1C1 1C2  1C3 2C0 2C1 2C2 2C3 Y1 Y2
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   G1BAR = { G1BAR_I }
+   G2BAR = { G2BAR_I }
+   A = { A_I }
+   B = { B_I }
+   1C0 = { 1C0_I }
+   1C1 = { 1C1_I }
+   1C2 = { 1C2_I }
+   1C3 = { 1C3_I }
+   2C0 = { 2C0_I }
+   2C1 = { 2C1_I }
+   2C2 = { 2C2_I }
+   2C3 = { 2C3_I }
+   G1 = { ~G1BAR }
+   G2 = { ~G2BAR }
+   ABAR = { ~A }
+   BBAR = { ~B }
+   I0 = { G1 & BBAR & ABAR & 1C0 }
+   I1 = { G1 & BBAR & A    & 1C1 }
+   I2 = { G1 & B    & ABAR & 1C2 }
+   I3 = { G1 & B    & A    & 1C3 }
+   I4 = { G2 & BBAR & ABAR & 2C0 }
+   I5 = { G2 & BBAR & A    & 2C1 }
+   I6 = { G2 & B    & ABAR & 2C2 }
+   I7 = { G2 & B    & A    & 2C3 }
+   Y1 = { I0 | I1 | I2 | I3 }
+   Y2 = { I4 | I5 | I6 | I7 }
*
UHC153DLY PINDLY (2,0,12) DPWR DGND
+ Y1 Y2
+ G1BAR G2BAR A B 1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3
+ Y1_O Y2_O
+ IO_HC
+ MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+ BOOLEAN:
+   DATA1 = { (CHANGED(1C0,0) | CHANGED(1C1,0) | CHANGED(1C2,0) |
+     CHANGED(1C3,0)) }
+   DATA2 = { (CHANGED(2C0,0) | CHANGED(2C1,0) | CHANGED(2C2,0) |
+     CHANGED(2C3,0)) }
+   SELECT = { CHANGED(A,0) | CHANGED(B,0) }
+ PINDLY:
+   Y1_O = {
+     CASE(
+       SELECT, DELAY(-1,21NS,38NS),
+       DATA1, DELAY(-1,17NS,35NS),
+       CHANGED(G1BAR,0), DELAY(-1,11NS,24NS),
+       DELAY(-1,22NS,39NS)
+       )
+     }
+   Y2_O = {
+     CASE(
+       SELECT, DELAY(-1,21NS,38NS),
+       DATA2, DELAY(-1,17NS,35NS),
+       CHANGED(G2BAR,0), DELAY(-1,11NS,24NS),
+       DELAY(-1,22NS,39NS)
+       )
+     }
*
.ENDS
*
*$
*---------
* 74HC154  DECODER/DEMULTIPLEXER 4-16 LINE
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, 1989, TI
* JLS   8-6-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*    
.SUBCKT 74HC154   G1BAR_I G2BAR_I A_I B_I C_I D_I
+ Y0_O Y1_O  Y2_O  Y3_O  Y4_O  Y5_O  Y6_O  Y7_O
+ Y8_O Y9_O Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC154LOG LOGICEXP (6,21) DPWR DGND
+ G1BAR_I G2BAR_I A_I B_I C_I D_I
+ ENABLE          A   B   C   D
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   G1BAR  = { G1BAR_I }
+   G2BAR  = { G2BAR_I }
+   ENABLE = { ~(G1BAR | G2BAR) }
+   A      = { A_I }
+   B      = { B_I }
+   C      = { C_I }
+   D      = { D_I }
+   ABAR   = { ~A }
+   BBAR   = { ~B }
+   CBAR   = { ~C }
+   DBAR   = { ~D }
+   Y0     = { ~(ENABLE & DBAR & CBAR & BBAR & ABAR) }
+   Y1     = { ~(ENABLE & DBAR & CBAR & BBAR & A   ) }
+   Y2     = { ~(ENABLE & DBAR & CBAR & B    & ABAR) }
+   Y3     = { ~(ENABLE & DBAR & CBAR & B    & A   ) }
+   Y4     = { ~(ENABLE & DBAR & C    & BBAR & ABAR) }
+   Y5     = { ~(ENABLE & DBAR & C    & BBAR & A   ) }
+   Y6     = { ~(ENABLE & DBAR & C    & B    & ABAR) }
+   Y7     = { ~(ENABLE & DBAR & C    & B    & A   ) }
+   Y8     = { ~(ENABLE & D    & CBAR & BBAR & ABAR) }
+   Y9     = { ~(ENABLE & D    & CBAR & BBAR & A   ) }
+   Y10    = { ~(ENABLE & D    & CBAR & B    & ABAR) }
+   Y11    = { ~(ENABLE & D    & CBAR & B    & A   ) }
+   Y12    = { ~(ENABLE & D    & C    & BBAR & ABAR) }
+   Y13    = { ~(ENABLE & D    & C    & BBAR & A   ) }
+   Y14    = { ~(ENABLE & D    & C    & B    & ABAR) }
+   Y15    = { ~(ENABLE & D    & C    & B    & A   ) }
*
UHC154DLY PINDLY (16,0,0) DPWR DGND
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15
+
+ Y0_O Y1_O  Y2_O  Y3_O  Y4_O  Y5_O  Y6_O  Y7_O
+ Y8_O Y9_O Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   Y0_O Y1_O  Y2_O  Y3_O  Y4_O  Y5_O  Y6_O  Y7_O
+   Y8_O Y9_O Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O = { DELAY(-1,24NS,45NS) }
*
.ENDS
*
*$
*---------
* 74HC155  DECODER/DEMULTIPLEXER 2-4 LINE
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, 1990, GOLDSTAR SEMICONDUCTORS
* JLS   7-29-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*    
.SUBCKT 74HC155   G1BAR_I G2BAR_I A_I B_I C1_I C2BAR_I
+ 1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC155LOG LOGICEXP (6,14) DPWR DGND
+ G1BAR_I G2BAR_I A_I B_I C1_I C2BAR_I
+         G2BAR   A   B   C2BAR      ENABLE1 ENABLE2
+ 1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   G1BAR   = { G1BAR_I }
+   G2BAR   = { G2BAR_I }
+   A       = { A_I }
+   B       = { B_I }
+   C1      = { C1_I }
+   C2BAR   = { C2BAR_I }
+   ABAR    = { ~A }
+   BBAR    = { ~B }
+   ENABLE1 = { ~G1BAR &  C1 }
+   ENABLE2 = { ~G2BAR & ~C2BAR }
+
+   1Y0     = { ~(ENABLE1 & BBAR & ABAR) }
+   1Y1     = { ~(ENABLE1 & BBAR & A   ) }
+   1Y2     = { ~(ENABLE1 & B    & ABAR) }
+   1Y3     = { ~(ENABLE1 & B    & A   ) }
+
+   2Y0     = { ~(ENABLE2 & BBAR & ABAR) }
+   2Y1     = { ~(ENABLE2 & BBAR & A   ) }
+   2Y2     = { ~(ENABLE2 & B    & ABAR) }
+   2Y3     = { ~(ENABLE2 & B    & A   ) }
*
UHC155DLY PINDLY (8,0,6) DPWR DGND
+ 1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+ G2BAR A B C2BAR ENABLE1 ENABLE2
+ 1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ABLE   = { CHANGED(ENABLE1,0) |
+             (CHANGED(G2BAR,0) & CHANGED(ENABLE2,0)) }
+   ADDR   = { CHANGED(A,0) | CHANGED(B,0) }
+   ADDRC2 = { CHANGED(C2BAR,0) & CHANGED(ENABLE2,0) }
+
+ PINDLY:
+   1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O = {
+     CASE (
+       ADDR  , DELAY(-1,18NS,40NS),
+       ADDRC2, DELAY(-1,18NS,40NS),
+       ABLE  , DELAY(-1,22NS,48NS),
+       DELAY(-1,22NS,48NS)
+       )
+     }
*
.ENDS
*
*$
*---------
* 74HC157  QUADRUPLE 2-LINE TO 1-LINE DATA SELECTORS/MULTIPLEXERS
*
* High Speed CMOS Logic Data Book, 1989, TI
* JSW   8/25/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices
*
.SUBCKT 74HC157 GBAR_I 1A_I 1B_I 2A_I 2B_I 3A_I 3B_I 4A_I 4B_I SEL_I
+ Y1_O Y2_O Y3_O Y4_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC157LOG LOGICEXP(10,14) DPWR DGND
+ GBAR_I 1A_I 1B_I 2A_I 2B_I 3A_I 3B_I 4A_I 4B_I SEL_I
+ GBAR 1A 1B 2A 2B 3A 3B 4A 4B SEL Y1 Y2 Y3 Y4
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   GBAR = { GBAR_I }
+   1A = { 1A_I }
+   1B = { 1B_I }
+   2A = { 2A_I }
+   2B = { 2B_I }
+   3A = { 3A_I }
+   3B = { 3B_I }
+   4A = { 4A_I }
+   4B = { 4B_I }
+   SEL = { SEL_I }
+   SEL1 = { ~GBAR & ~SEL }
+   SEL2 = { ~GBAR &  SEL }
+   Y1 = { (1A & SEL1) | (1B & SEL2) }
+   Y2 = { (2A & SEL1) | (2B & SEL2) }
+   Y3 = { (3A & SEL1) | (3B & SEL2) }
+   Y4 = { (4A & SEL1) | (4B & SEL2) }
*
UHC157DLY PINDLY (4,0,10) DPWR DGND
+ Y1 Y2 Y3 Y4
+ GBAR 1A 1B 2A 2B 3A 3B 4A 4B SEL
+ Y1_O Y2_O Y3_O Y4_O
+ IO_HC
+ MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+ BOOLEAN:
+   DATA = { CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(2A,0) | CHANGED(2B,0) |
+     CHANGED(3A,0) | CHANGED(3B,0) | CHANGED(4A,0) | CHANGED(4B,0) }
+   SELECT = { CHANGED(SEL,0) }
+   ENABLE = { CHANGED(GBAR,0) }
+ PINDLY:
+   Y1_O Y2_O Y3_O Y4_O = {
+     CASE(
+       DATA, DELAY(-1,13NS,32NS),
+       SELECT, DELAY(-1,18NS,31NS),
+       ENABLE, DELAY(-1,16NS,29NS),
+       DELAY(-1,19NS,33NS)
+       )
+     }
*
.ENDS
*
*$
*---------
* 74HC158  DUAL 4-LINE TO 1-LINE DATA SELECTORS/MULTIPLEXERS
*
* High Speed CMOS Logic Data Book, 1989, TI
* JSW   8/25/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices
*
.SUBCKT 74HC158 GBAR_I 1A_I 1B_I 2A_I 2B_I 3A_I 3B_I 4A_I 4B_I SEL_I
+ Y1_O Y2_O Y3_O Y4_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC158LOG LOGICEXP(10,14) DPWR DGND
+ GBAR_I 1A_I 1B_I 2A_I 2B_I 3A_I 3B_I 4A_I 4B_I SEL_I
+ GBAR 1A 1B 2A 2B 3A 3B 4A 4B SEL Y1 Y2 Y3 Y4
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   GBAR = { GBAR_I }
+   1A = { 1A_I }
+   1B = { 1B_I }
+   2A = { 2A_I }
+   2B = { 2B_I }
+   3A = { 3A_I }
+   3B = { 3B_I }
+   4A = { 4A_I }
+   4B = { 4B_I }
+   SEL = { SEL_I }
+   SEL1 = { ~GBAR & ~SEL }
+   SEL2 = { ~GBAR &  SEL }
+   Y1 = { ~((1A & SEL1) | (1B & SEL2)) }
+   Y2 = { ~((2A & SEL1) | (2B & SEL2)) }
+   Y3 = { ~((3A & SEL1) | (3B & SEL2)) }
+   Y4 = { ~((4A & SEL1) | (4B & SEL2)) }
*
UHC158DLY PINDLY (4,0,10) DPWR DGND
+ Y1 Y2 Y3 Y4
+ GBAR 1A 1B 2A 2B 3A 3B 4A 4B SEL
+ Y1_O Y2_O Y3_O Y4_O
+ IO_HC
+ MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+ BOOLEAN:
+   DATA = { CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(2A,0) | CHANGED(2B,0) |
+     CHANGED(3A,0) | CHANGED(3B,0) | CHANGED(4A,0) | CHANGED(4B,0) }
+   SELECT = { CHANGED(SEL,0) }
+   ENABLE = { CHANGED(GBAR,0) }
+ PINDLY:
+   Y1_O Y2_O Y3_O Y4_O = {
+     CASE(
+       DATA, DELAY(-1,13NS,32NS),
+       SELECT, DELAY(-1,18NS,31NS),
+       ENABLE, DELAY(-1,16NS,29NS),
+       DELAY(-1,19NS,33NS)
+       )
+     }
*
.ENDS
*
*$
*---------
* 74HC160  Synchronous 4-bit Decade Counters with asynchronous clear
*
* HIGH SPEED CMOS DATA BOOK, 1991, PHILIPS SEMICONDUCTORS 
* JSW   7/1/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
*
.SUBCKT 74HC160  CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O RCO_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
* 
UHC160LOG LOGICEXP(15,15) DPWR DGND
+ CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I QA QD
+ QABAR QBBAR QCBAR QDBAR
+ CLK ENP ENT CLRBAR LOADBAR A B C D RCO DA DB DC DD EN
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLK = { CLK_I }                     ;Buffering
+   ENP = { ENP_I }
+   ENT = { ENT_I }
+   CLRBAR = { CLRBAR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   LOAD = { ~LOADBAR }               ;Logic expressions
+   EN = { ~(ENP & ENT) }
+   DA = { (A & LOAD) | (LOADBAR & ~(QABAR ^ ~EN)) }
+   IB1 = { ~(EN | QABAR | QD) }
+   DB = { (B & LOAD) | (LOADBAR & ~(IB1 ^ QBBAR)) }
+   IC1 = { ~(EN | QABAR | QBBAR) }
+   DC = { (C & LOAD) | (LOADBAR & ~(IC1 ^ QCBAR)) }
+   ID1 = { ~(EN | QABAR | QBBAR | QCBAR) }
+   ID2 = { ~(EN | ~(QDBAR | QA)) }
+   DD = { (D & LOAD ) | ( LOADBAR & ((QDBAR & ID1) | ~(QDBAR | ID2))) }
+   RCO = { ENT & QA & QBBAR & QCBAR & QD }
*
UDFF DFF(4) DPWR DGND $D_HI CLRBAR CLK DA DB DC DD
+ QA QB QC QD QABAR QBBAR QCBAR QDBAR D0_EFF IO_HC
*
UHC160DLY PINDLY (5,0,10) DPWR DGND
+ RCO QA QB QC QD
+ CLK ENT CLRBAR ENP LOADBAR A B C D EN
+ RCO_O QA_O QB_O QC_O QD_O
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = { CHANGED_LH(CLK,0) }
+   CNTENT = { CHANGED(ENT,0) }
+   CLEAR = { CHANGED_HL(CLRBAR,0) }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CLOCK, DELAY(-1,22NS,46NS),
+       CLEAR, DELAY(-1,25NS,53NS),
+       DELAY(-1,25NS,53NS)
+   	)
+     }
+   RCO_O = {
+     CASE(
+       CNTENT, DELAY(-1,17NS,38NS),
+       CLOCK, DELAY(-1,25NS,54NS),
+       CLEAR, DELAY(-1,25NS,55NS),
+       DELAY(-1,25NS,55NS)
+       )
+     }
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 20MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 20NS
+   MIN_HI = 20NS
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   WHEN = { (LOADBAR!='1 ^ CHANGED(LOADBAR,0)) & CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(2) = ENP ENT
+   CLOCK LH = CLK
+   SETUPTIME = 50NS
+   WHEN = { CLRBAR!='0 & (LOADBAR!='0 ^ CHANGED(LOADBAR,0)) 
+     & CHANGED(EN,50NS) }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = CLK
+   SETUPTIME = 34NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK LH = CLK
+   RELEASETIME_LH = 25NS
*
.ENDS
*
*$
*---------
* 74HC161  Synchronous 4-bit Binary Counter with Direct Clear
*
* THE HIGH SPEED CMOS LOGIC DATA BOOK, 1989, TI
* tc  07/02/92  Remodeled using LOGICEXP, PINDLY & CONSTRAINT devices
*
* NOTE: Philips Semiconductors 1991 74HC/HCT161's logic is used.
*
.SUBCKT 74HC161 CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O RCO_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 DFF(4) DPWR DGND $D_HI CLRBAR CLK
+ DA DB DC DD QA QB QC QD QABAR QBBAR QCBAR QDBAR
+ D0_EFF IO_HC
*
UHC161LOG LOGICEXP(17,15) DPWR DGND
+ CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I QA QB QC QD
+ QABAR QBBAR QCBAR QDBAR
+ CLK ENP ENT CLRBAR LOADBAR A B C D RCO DA DB DC DD IEN
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLK = { CLK_I }
+   ENP = { ENP_I }
+   ENT = { ENT_I }
+   CLRBAR = { CLRBAR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   IEN = { ~(ENT & ENP) }
+   ILD = { ~LOADBAR }
+   IA1 = { A & ILD }
+   IA2 = { ~(~IEN ^ QABAR) & LOADBAR }
+   IB1 = { B & ILD }
+   IB2 = { ~(~(IEN | QABAR) ^ QBBAR) & LOADBAR }
+   IC1 = { C & ILD }
+   IC2 = { (~((~(IEN | QBBAR | QABAR)) ^ QCBAR)) & LOADBAR }
+   ID1 = { D & ILD }
+   ID2 = { ~(IEN | QCBAR | QBBAR | QABAR) }
+   ID3 = { LOADBAR & ((ID2 & QDBAR) | ~(ID2 | QDBAR)) }
+   RCO = { QD & QC & QB & QA & ENT }
+   DA = { IA1 | IA2 }
+   DB = { IB1 | IB2 }
+   DC = { IC1 | IC2 }
+   DD = { ID1 | ID3 }
*
UHC161DLY PINDLY (5,0,10) DPWR DGND
+ RCO QA QB QC QD
+ CLK ENT CLRBAR ENP LOADBAR A B C D IEN
+ RCO_O QA_O QB_O QC_O QD_O
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = { CHANGED_LH(CLK,0) }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CLOCK, DELAY(-1,25NS,51NS),
+       DELAY(-1,21NS,53NS)
+       )
+     }
+   RCO_O = {
+     CASE(
+       CHANGED(ENT,0), DELAY(-1,17NS,49NS),
+       CLOCK, DELAY(-1,24NS,54NS),
+       DELAY(-1,22NS,55NS)
+       )
+     }
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 20NS
+   MIN_HI = 20NS
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = CLK
+   SETUPTIME = 38NS
+   WHEN = { (LOADBAR!='1 ^ CHANGED(LOADBAR,0)) & CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = CLK
+   SETUPTIME = 34NS
+   WHEN = { CLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(2) = ENP ENT
+   CLOCK LH = CLK
+   SETUPTIME = 43NS
+   WHEN = { (LOADBAR!='0 ^ CHANGED(LOADBAR,0)) & CLRBAR!='0 &
+     CHANGED(IEN,43NS) }
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK LH = CLK
+   RELEASETIME_LH = 31NS
*
.ENDS
*
*$
*---------
* 74HC162  Synchronous 4-bit Decade Counters with asynchronous clear 
*
* HIGH SPEED CMOS DATA BOOK, 1991, PHILIPS SEMICONDUCTORS 
* JSW   7/1/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
*
.SUBCKT 74HC162  CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O RCO_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
* 
UHC162LOG LOGICEXP(15,15) DPWR DGND
+ CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I QA QD
+ QABAR QBBAR QCBAR QDBAR
+ CLK ENP ENT CLRBAR LOADBAR A B C D RCO DA DB DC DD EN
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLK = { CLK_I }                     ;Buffering
+   ENP = { ENP_I }
+   ENT = { ENT_I }
+   CLRBAR = { CLRBAR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   LOAD = { ~(LOADBAR | ~CLRBAR) }   ;Logic expressions
+   LOADB = { ~(LOAD | ~CLRBAR) }
+   EN = { ~(ENP & ENT) }
+   DA = { (A & LOAD) | (LOADB & ~(QABAR ^ ~EN)) }
+   IB1 = { ~(EN | QABAR | QD) }
+   DB = { (B & LOAD) | (LOADB & ~(IB1 ^ QBBAR)) }
+   IC1 = { ~(EN | QABAR | QBBAR) }
+   DC = { (C & LOAD) | (LOADB & ~(IC1 ^ QCBAR)) }
+   ID1 = { ~(EN | QABAR | QBBAR | QCBAR) }
+   ID2 = { ~(EN | ~(QDBAR | QA)) }
+   DD = { (D & LOAD ) | ( LOADB & ((QDBAR & ID1) | ~(QDBAR | ID2))) }
+   RCO = { ENT & QA & QBBAR & QCBAR & QD }
*
UDFF DFF(4) DPWR DGND $D_HI $D_HI CLK DA DB DC DD
+ QA QB QC QD QABAR QBBAR QCBAR QDBAR D0_EFF IO_HC
*
UHC162DLY PINDLY (5,0,10) DPWR DGND
+ RCO QA QB QC QD
+ CLK ENT ENP CLRBAR LOADBAR A B C D EN
+ RCO_O QA_O QB_O QC_O QD_O
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+   QA_O QB_O QC_O QD_O = { DELAY(-1,21NS,48NS) }
+   RCO_O = {
+     CASE(
+       CHANGED(ENT,0), DELAY(-1,14NS,38NS),
+       CHANGED_LH(CLK,0), DELAY(-1,25NS,54NS),
+       DELAY(-1,25NS,54NS)
+       )
+     }
+ BOOLEAN:
+   NOTCLEAR = { CLRBAR!='0 ^ CHANGED(CLRBAR,0) }
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 24MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 20NS
+   MIN_HI = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = CLK
+   SETUPTIME = 25NS
+   WHEN = { (LOADBAR!='1 ^ CHANGED(LOADBAR,0)) & NOTCLEAR }
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK LH = CLK
+   SETUPTIME = 25NS
+ SETUP_HOLD:
+   DATA(2) = ENT ENP 
+   CLOCK LH = CLK
+   SETUPTIME = 50NS
+   WHEN = { (LOADBAR!='0 ^ CHANGED(LOADBAR,0)) & NOTCLEAR & CHANGED(EN,50NS) }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = CLK
+   SETUPTIME = 34NS
+   WHEN = { NOTCLEAR }
*
.ENDS
*
*$
*---------
* 74HC163  Synchronous 4-bit Binary Counter with Direct Clear
*
* THE HIGH SPEED CMOS LOGIC DATA BOOK, 1989, TI
* tc  07/02/92  Remodeled using LOGICEXP, PINDLY & CONSTRAINT Devices
*
* NOTE: The Philips Semiconductors 74HC/HCT163 (1991) logic is used.
*
.SUBCKT 74HC163 CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O RCO_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 DFF(4) DPWR DGND $D_HI $D_HI CLK
+ DA DB DC DD QA QB QC QD QABAR QBBAR QCBAR QDBAR
+ D0_EFF IO_HC
*
UHC163LOG LOGICEXP(17,15) DPWR DGND
+ CLK_I ENP_I ENT_I CLRBAR_I LOADBAR_I A_I B_I C_I D_I QA QB QC QD
+  QABAR QBBAR QCBAR QDBAR
+ CLK ENP ENT CLRBAR LOADBAR A B C D RCO DA DB DC DD IEN
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLK = { CLK_I }
+   ENP = { ENP_I }
+   ENT = { ENT_I }
+   CLRBAR = { CLRBAR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   IEN = { ~(ENT & ENP) }
+   ILD = { ~(LOADBAR | ~CLRBAR) }
+   ILC = { ~(ILD | ~CLRBAR) }
+   IA1 = { A & ILD }
+   IA2 = { ~(~IEN ^ QABAR) & ILC }
+   IB1 = { B & ILD }
+   IB2 = { ~(~(IEN | QABAR) ^ QBBAR) & ILC }
+   IC1 = { C & ILD }
+   IC2 = { (~((~(IEN | QBBAR | QABAR)) ^ QCBAR)) & ILC }
+   IDB = { D & ILD }
+   IDC = { ~(IEN | QCBAR | QBBAR | QABAR) }
+   IDD = { ILC & ((IDC & QDBAR) | ~(IDC | QDBAR)) }
+   RCO = { QD & QC & QB & QA & ENT }
+   DA = { IA1 | IA2 }
+   DB = { IB1 | IB2 }
+   DC = { IC1 | IC2 }
+   DD = { IDB | IDD }
*
UHC163DLY PINDLY (5,0,10) DPWR DGND
+ RCO QA QB QC QD
+ CLK ENT CLRBAR ENP LOADBAR A B C D IEN
+ RCO_O QA_O QB_O QC_O QD_O
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = { CHANGED_LH(CLK,0) }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = { DELAY(-1,25NS,51NS) }
+   RCO_O = {
+     CASE(
+       CHANGED(ENT,0), DELAY(-1,17NS,49NS),
+       CLOCK, DELAY(-1,24NS,54NS),
+       DELAY(-1,24NS,54NS)
+       )
+     }
+ BOOLEAN:
+   NOTCLEAR = { CLRBAR!='0 ^ CHANGED(CLRBAR,0) }
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 20NS
+   MIN_HI = 20NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = CLK
+   SETUPTIME = 38NS
+   WHEN = { (LOADBAR!='1 ^ CHANGED(LOADBAR,0)) & NOTCLEAR }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = CLK
+   SETUPTIME_LO = 34NS
+   WHEN = { NOTCLEAR }
+ SETUP_HOLD:
+   DATA(2) = ENP ENT
+   CLOCK LH = CLK
+   SETUPTIME = 43NS
+   WHEN = { (LOADBAR!='0 ^ CHANGED(LOADBAR,0)) & NOTCLEAR & CHANGED(IEN,43NS) }
+ SETUP_HOLD:
+   DATA(1) = CLRBAR
+   CLOCK LH = CLK
+   SETUPTIME = 40NS
*
.ENDS
*
*$
*---------
*74HC164  8-BIT PARALLEL-OUT SERIAL SHIFT REGISTERS
*
* HIGH-SPEED CMOS DATA BOOK 1989, TI
* KN   6-30-92        REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74HC164  CLRBAR_I CLK_I A_I B_I QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 BUFA(4) DPWR DGND
+ CLRBAR_I CLK_I A_I B_I  CLRBAR CLK A B
+ D0_GATE IO_HC  IO_LEVEL={IO_LEVEL}
*
U2 AND(2) DPWR DGND
+ A B   IN
+ D0_GATE IO_HC 
*
U3 DFF(8) DPWR DGND
+ $D_HI   CLRBAR  CLK
+ IN      QA  QB  QC  QD  QE  QF  QG
+ QA  QB  QC  QD  QE  QF  QG  QH
+ $D_NC   $D_NC   $D_NC   $D_NC   $D_NC   $D_NC   $D_NC   $D_NC
+ D0_EFF IO_HC 
*
UHC164DLY PINDLY (8,0,4) DPWR DGND
+ QA QB QC QD QE QF QG QH
+ CLRBAR CLK A B
+ QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+   QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O = {
+     CASE(
+       CHANGED_HL(CLRBAR,0), DELAY(-1,14NS,35NS),
+       CHANGED_LH(CLK,0), DELAY(-1,15NS,43NS),
+       DELAY(-1,16NS,44NS)  ;DEFAULT
+       )
+     }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 24MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HIGH = 20NS
+   MIN_LOW = 20NS
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LOW = 15NS
+
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(2) A B
+   SETUPTIME = 15NS
+   HOLDTIME = 4NS
+   WHEN = { CLRBAR != '0 }
+
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(1) CLRBAR
+   RELEASETIME_LH = 15NS
*
.ENDS
*
*$
*---------
* 74HC165  PARALLEL-LOAD 8-BIT SHIFT REGISTERS
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, 1989, TI
* NH 7/27/92            REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74HC165 SH/LDBAR_I CLK_INH_I CLK_I SER_I A_I B_I C_I D_I E_I F_I G_I H_I
+ QH_O QHBAR_O
+ OPTIONAL: DPWR = $G_DPWR   DGND = $G_DGND
+ PARAMS:   MNTYMXDLY = 0    IO_LEVEL = 0
*
UHC165LOG LOGICEXP(12,29) DPWR DGND
+ SH/LDBAR_I CLK_INH_I CLK_I SER_I A_I B_I C_I D_I E_I F_I G_I H_I
+ SH/LDBAR CLK_INH CLK SER A B C D E F G H SA SB SC SD SE SF SG SH
+ RA RB RC RD RE RF RG RH CK
+ D0_GATE  IO_HC  IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+
+   SH/LDBAR = { SH/LDBAR_I }
+   CLK_INH = { CLK_INH_I }
+   CLK = { CLK_I }
+   SER = { SER_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   E = { E_I }
+   F = { F_I }
+   G = { G_I }
+   H = { H_I }
+
* INTERMEDIATE TERM
+   LOAD = { ~SH/LDBAR }
+
+   SA = { ~(LOAD & A) }
+   SB = { ~(LOAD & B) }
+   SC = { ~(LOAD & C) }
+   SD = { ~(LOAD & D) }
+   SE = { ~(LOAD & E) }
+   SF = { ~(LOAD & F) }
+   SG = { ~(LOAD & G) }
+   SH = { ~(LOAD & H) }
+
+   RA = { ~(LOAD & SA) }
+   RB = { ~(LOAD & SB) }
+   RC = { ~(LOAD & SC) }
+   RD = { ~(LOAD & SD) }
+   RE = { ~(LOAD & SE) }
+   RF = { ~(LOAD & SF) }
+   RG = { ~(LOAD & SG) }
+   RH = { ~(LOAD & SH) }
+
+   CK = { CLK_INH | CLK }
*
U1 DFF(1) DPWR DGND SA RA CK SER QA $D_NC
+ D0_EFF  IO_HC
*
U2 DFF(1) DPWR DGND SB RB CK QA QB $D_NC
+ D0_EFF  IO_HC
*
U3 DFF(1) DPWR DGND SC RC CK QB QC $D_NC
+ D0_EFF  IO_HC
*
U4 DFF(1) DPWR DGND SD RD CK QC QD $D_NC
+ D0_EFF  IO_HC
*
U5 DFF(1) DPWR DGND SE RE CK QD QE $D_NC
+ D0_EFF  IO_HC
*
U6 DFF(1) DPWR DGND SF RF CK QE QF $D_NC
+ D0_EFF  IO_HC
*
U7 DFF(1) DPWR DGND SG RG CK QF QG $D_NC
+ D0_EFF  IO_HC
*
U8 DFF(1) DPWR DGND SH RH CK QG QH QHBAR
+ D0_EFF  IO_HC
*
UHC165DLY PINDLY (2,0,12) DPWR DGND
+ QH QHBAR
+ SH/LDBAR CLK H CLK_INH SER A B C D E F G
+ QH_O QHBAR_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY}   IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   LMODE = { SH/LDBAR=='0 }
+   SMODE = { SH/LDBAR=='1 }
+   CH_H = { CHANGED(H,0) }
+
+ PINDLY:
+   QH_O, QHBAR_O = {
+     CASE(
+       CH_H & LMODE, DELAY(-1,15NS,38NS),
+       CHANGED_LH(CLK,0) & SMODE, DELAY(-1,15NS,38NS),
+       CHANGED_HL(SH/LDBAR,0), DELAY(-1,20NS,38NS),
+       DELAY(-1,21NS,39NS)            ;DEFAULT
+       )
+     }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 20NS
+   MIN_HI = 20NS
+
+ WIDTH:
+   NODE = SH/LDBAR
+   MIN_LO = 20NS
+
+ SETUP_HOLD:
+   DATA(1) = CLK_INH
+   CLOCK LH = CLK
+   SETUPTIME_LO = 25NS
+   SETUPTIME_HI = 10NS
+   MESSAGE = "CLOCK INHIBIT SETUP TIME IS NOT MET"
+
+ SETUP_HOLD:
+   DATA(1) = SH/LDBAR
+   CLOCK LH = CLK
+   SETUPTIME_HI = 20NS
+
+ SETUP_HOLD:
+   DATA(1) = SER
+   CLOCK LH = CLK
+   SETUPTIME = 10NS
+   HOLDTIME = 5NS
+   WHEN = { (SH/LDBAR!='0 ^ CHANGED(SH/LDBAR,0)) }
+
+ SETUP_HOLD:
+   DATA(8) = A B C D E F G H
+   CLOCK LH = SH/LDBAR
+   SETUPTIME = 25NS
+   HOLDTIME = 5NS
*
.ENDS
*
*$
*--------
* 74HC166  PARALLEL LOAD 8-BIT SHIFT REGISTERS
*
* THE HIGH-SPEED CMOS LOGIC DATABOOK, 1989, TI
* NH   7-22-92      REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74HC166 CLRBAR_I SH/LDBAR_I CLK_INH_I CLK_I SER_I A_I B_I C_I D_I E_I
+ F_I G_I H_I QH_O
+ OPTIONAL: DPWR=$G_DPWR    DGND=$G_DGND
+ PARAMS:   MNTYMXDLY=0     IO_LEVEL=0
*
UHC166LOG LOGICEXP(20,30) DPWR DGND
+ CLRBAR_I SH/LDBAR_I CLK_INH_I CLK_I SER_I A_I B_I C_I D_I E_I F_I G_I H_I
+  QA QB QC QD QE QF QG
+ CLRBAR SH/LDBAR CLK_INH CLK SER A B C D E F G H JA JB JC JD JE JF JG JH
+  KA KB KC KD KE KF KG KH CK
+ D0_GATE  IO_HC  IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   CLRBAR    = { CLRBAR_I }
+   SH/LDBAR  = { SH/LDBAR_I }
+   CLK_INH   = { CLK_INH_I }
+   CLK       = { CLK_I }
+   SER       = { SER_I }
+   A         = { A_I }
+   B         = { B_I }
+   C         = { C_I }
+   D         = { D_I }
+   E         = { E_I }
+   F         = { F_I }
+   G         = { G_I }
+   H         = { H_I }
+
* INTERMEDIATE TERM
+   LOAD = { ~SH/LDBAR }
+
+   KA = { ~((SH/LDBAR & SER) | (LOAD & A)) }
+   KB = { ~((SH/LDBAR & QA)  | (LOAD & B)) }
+   KC = { ~((SH/LDBAR & QB)  | (LOAD & C)) }
+   KD = { ~((SH/LDBAR & QC)  | (LOAD & D)) }
+   KE = { ~((SH/LDBAR & QD)  | (LOAD & E)) }
+   KF = { ~((SH/LDBAR & QE)  | (LOAD & F)) }
+   KG = { ~((SH/LDBAR & QF)  | (LOAD & G)) }
+   KH = { ~((SH/LDBAR & QG)  | (LOAD & H)) }
+   JA = { ~KA }
+   JB = { ~KB }
+   JC = { ~KC }
+   JD = { ~KD }
+   JE = { ~KE }
+   JF = { ~KF }
+   JG = { ~KG }
+   JH = { ~KH }
+   CK = { ~(CLK | CLK_INH) }
*
U1 JKFF(8) DPWR DGND  $D_HI CLRBAR CK
+ JA JB JC JD JE JF JG JH KA KB KC KD KE KF KG KH
+ QA QB QC QD QE QF QG QH $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF  IO_HC
*
UHC166DLY PINDLY (1,0,13) DPWR DGND
+ QH
+ CLRBAR CLK SH/LDBAR CLK_INH SER A B C D E F G H
+ QH_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY}  IO_LEVEL={IO_LEVEL}
+
+   PINDLY:
+    QH_O = {
+     CASE(
+       CHANGED_HL(CLRBAR,0) & TRN_HL, DELAY(-1,18NS,30NS),
+       CHANGED_LH(CLK,0),DELAY(-1,15NS,38NS),
+       DELAY(-1,19NS,39NS);  DEFAULT
+       )
+     }
+
+ BOOLEAN:
+   ACTIVE_MODE = { CLRBAR!='0 & CLK_INH!='1 }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 20NS
+   MIN_LO = 20NS
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 25NS
+
+ SETUP_HOLD:
+   DATA(1) SH/LDBAR
+   CLOCK LH = CLK
+   SETUPTIME = 36NS
+   WHEN = { ACTIVE_MODE }
+
+ SETUP_HOLD:
+   DATA(8) A B C D E F G H
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   HOLDTIME = 5NS
+   WHEN = { ACTIVE_MODE & (SH/LDBAR!='1 ^ CHANGED(SH/LDBAR,0)) }
+
+ SETUP_HOLD:
+   DATA(1) SER
+   CLOCK LH = CLK
+   SETUPTIME = 20NS
+   HOLDTIME = 5NS
+   WHEN = { ACTIVE_MODE & (SH/LDBAR!='0 ^ CHANGED(SH/LDBAR,0)) }
+
+ SETUP_HOLD:
+   DATA(1) CLRBAR
+   CLOCK LH = CLK
+   RELEASETIME_LH = 10NS
+
+ SETUP_HOLD:
+   DATA(1) CLK_INH
+   CLOCK LH = CLK
+   SETUPTIME_LO = 25NS
*
.ENDS
*
*$
*---------
* 74HC173  REGISTERS D-TYPE 4-BIT WITH 3-STATE OUTPUTS
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   7-9-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
* rbh   11/11/92	Added bus I/O model
* 
.SUBCKT 74HC173   CLR_I CLK_I E0BAR_I E1BAR_I M_I N_I
+ 1D_I 2D_I 3D_I 4D_I   1Q_O 2Q_O 3Q_O 4Q_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 DFF(4) DPWR DGND
+ $D_HI CLRBAR CLK
+ DFF1  DFF2  DFF3  DFF4
+ 1Q    2Q    3Q    4Q
+ $D_NC $D_NC $D_NC $D_NC
+ D0_EFF  IO_HC
*
UHC173LOG LOGICEXP (14,13) DPWR DGND
+ CLR_I  CLK_I E0BAR_I E1BAR_I M_I N_I 1D_I 2D_I 3D_I 4D_I 1Q 2Q 3Q 4Q
+ CLR CLRBAR CLK DATEN OE 1D 2D 3D 4D
+ DFF1 DFF2 DFF3 DFF4
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   CLR      = { CLR_I }
+   CLRBAR   = { ~CLR }
+   CLK      = { CLK_I }
+   E0BAR    = { E0BAR_I }
+   E1BAR    = { E1BAR_I }
+   M        = { M_I }
+   N        = { N_I }
+   1D       = { 1D_I }
+   2D       = { 2D_I }
+   3D       = { 3D_I }
+   4D       = { 4D_I }
+
+   DATENBAR = { E0BAR | E1BAR }
+   DATEN    = { ~DATENBAR }
+   OE       = { ~(M | N) }
+   DFF1     = { (1D & DATEN) | (1Q & DATENBAR) }
+   DFF2     = { (2D & DATEN) | (2Q & DATENBAR) }
+   DFF3     = { (3D & DATEN) | (3Q & DATENBAR) }
+   DFF4     = { (4D & DATEN) | (4Q & DATENBAR) }
*
UHC173DLY PINDLY (4,1,8) DPWR DGND
+ 1Q 2Q 3Q 4Q
+ OE
+ CLR CLK CLK DATEN 1D 2D 3D 4D
+ 1Q_O 2Q_O 3Q_O 4Q_O
+ IO_HC_BUS
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ TRISTATE:
+   ENABLE HI OE
+   1Q_O 2Q_O 3Q_O 4Q_O = {
+     CASE (
+       TRN_Z$,  DELAY(-1,20NS,38NS),
+       TRN_$Z,  DELAY(-1,18NS,38NS),
+       DELAY(-1,21NS,38NS)
+       )
+     }
+
+ FREQ:
+   NODE           = CLK
+   MAXFREQ        = 25MEGHZ
+ WIDTH:
+   NODE           = CLK
+   MIN_LO         = 20NS
+   MIN_HI         = 20NS
+ WIDTH:
+   NODE           = CLR
+   MIN_HI         = 20NS
+ SETUP_HOLD:
+   DATA(1)        = CLR
+   CLOCK LH       = CLK
+   RELEASETIME_HL = 23NS
+ SETUP_HOLD:
+   DATA(1)        = DATEN
+   CLOCK LH       = CLK
+   SETUPTIME      = 25NS
+   WHEN           = { CLR!='1 }
+ SETUP_HOLD:
+   DATA(4)        = 1D 2D 3D 4D
+   CLOCK LH       = CLK
+   SETUPTIME      = 25NS
+   WHEN           = { CLR!='1 & (DATEN!='0 ^ CHANGED(DATEN,0)) }
*
.ENDS
*
*$
*----------
* 74HC174  HEX D-TYPE FLIP-FLOPS WITH CLEAR
*
* The High-speed CMOS Logic Data Book, 1988, TI
* tvh	06/27/89	Update interface and model names
*
.subckt 74HC174  CLRBAR CLK D1 D2 D3 D4 D5 D6 Q1 Q2 Q3 Q4 Q5 Q6
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UD dff(6) DPWR DGND
+	$D_HI	CLRBAR	CLK
+	D1	D2	D3	D4	D5	D6
+	Q1	Q2	Q3	Q4	Q5	Q6
+	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC
+	D_HC174 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC174 ueff (
+	TWCLKLMN=20NS	TWCLKHMN=20NS
+	TWPCLMN=20NS	TSUDCLKMN=25NS
+	TSUPCCLKHMN=25NS	THDCLKMN=0NS
+	TPPCQHLMX=40NS	TPCLKQLHMX=40NS
+	TPCLKQHLMX=40NS
+	)
*$
*----------
* 74HC175  QUADRUPLE D-TYPE FLIP-FLOPS WITH CLEAR
*
* The High-speed CMOS Logic Data Book, 1988, TI
* tvh	06/27/89	Update interface and model names
*
.subckt 74HC175  CLRBAR CLK D1 D2 D3 D4 Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UD dff(4) DPWR DGND
+	$D_HI	CLRBAR	CLK
+	D1	D2	D3	D4
+	Q1	Q2	Q3	Q4	Q1BAR	Q2BAR	Q3BAR	Q4BAR
+	D_HC175 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC175 ueff (
+	TWCLKLMN=20NS	TWCLKHMN=20NS
+	TWPCLMN=20NS	TSUDCLKMN=25NS
+	TSUPCCLKHMN=25NS	TPPCQLHMX=38NS
+	TPPCQHLMX=38NS	TPCLKQLHMX=38NS
+	TPCLKQHLMX=38NS
+	)
*$
*---------
* 74HC180  PARITY GENERATOR/CHECKER ODD/EVEN 9-BIT
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   8-17-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74HC180   A_I B_I C_I D_I E_I F_I G_I H_I EIN_I OIN_I
+ EOUT_O OOUT_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC180LOG LOGICEXP (10,4) DPWR DGND
+ A_I B_I C_I D_I E_I F_I G_I H_I EIN_I OIN_I
+                                 EIN   OIN   EOUT OOUT
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   A      = { A_I }
+   B      = { B_I }
+   C      = { C_I }
+   D      = { D_I }
+   E      = { E_I }
+   F      = { F_I }
+   G      = { G_I }
+   H      = { H_I }
+   EIN    = { EIN_I }
+   OIN    = { OIN_I }
+
+   PARITY = { A ^ B ^ C ^ D ^ E ^ F ^ G ^ H }
+   EOUT   = { ~((~PARITY & OIN) | (PARITY & EIN)) }
+   OOUT   = { ~((~PARITY & EIN) | (PARITY & OIN)) }
*
UHC180DLY PINDLY (2,0,2) DPWR DGND
+ EOUT OOUT
+ EIN OIN
+ EOUT_O OOUT_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   POLAR = { CHANGED(EOUT,0) | CHANGED(OOUT,0) }
+
+ PINDLY:
+   EOUT_O = {
+     CASE (
+       POLAR, DELAY(-1,15NS,28NS),
+       DELAY(-1,36NS,65NS)
+       )
+     }
+
+   OOUT_O = {
+     CASE (
+       POLAR, DELAY(-1,15NS,28NS),
+       DELAY(-1,33NS,61NS)
+       )
+     }
*
.ENDS
*
*$
*---------
* 74HC181  ALU / FUNCTION GENERATOR
*
* HIGH SPEED CMOS LOGIC FAMILY BOOK, 1991, PHILIPS SEMICONDUCTORS
* JLS   9-4-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES

.SUBCKT 74HC181   A0BAR_I A1BAR_I A2BAR_I A3BAR_I B0BAR_I B1BAR_I B2BAR_I
+ B3BAR_I S0_I S1_I S2_I S3_I M_I CN_I F0BAR_O F1BAR_O F2BAR_O F3BAR_O
+ AEQUALB_O PBAR_O GBAR_O CN+4_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

UHC181LOG LOGICEXP (14,22) DPWR DGND
+ A0BAR_I A1BAR_I A2BAR_I A3BAR_I B0BAR_I B1BAR_I B2BAR_I B3BAR_I
+ S0_I S1_I S2_I S3_I M_I CN_I
+ A0BAR   A1BAR   A2BAR   A3BAR   B0BAR   B1BAR   B2BAR   B3BAR
+ S0   S1   S2   S3   M   CN
+ F0BAR   F1BAR   F2BAR   F3BAR   AEQUALB PBAR    GBAR    CN+4
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   A0BAR   = { A0BAR_I }
+   A1BAR   = { A1BAR_I }
+   A2BAR   = { A2BAR_I }
+   A3BAR   = { A3BAR_I }
+   B0BAR   = { B0BAR_I }
+   B1BAR   = { B1BAR_I }
+   B2BAR   = { B2BAR_I }
+   B3BAR   = { B3BAR_I }
+   S0      = { S0_I }
+   S1      = { S1_I }
+   S2      = { S2_I }
+   S3      = { S3_I }
+   M       = { M_I }
+   CN      = { CN_I }
+
+   TOP3    = { ~( (A3BAR & B3BAR & S3) | (A3BAR & ~B3BAR & S2) ) }
+   BOT3    = { ~(        (~B3BAR & S1) |  A3BAR | (B3BAR & S0) ) }
+   TOP2    = { ~( (A2BAR & B2BAR & S3) | (A2BAR & ~B2BAR & S2) ) }
+   BOT2    = { ~(        (~B2BAR & S1) |  A2BAR | (B2BAR & S0) ) }
+   TOP1    = { ~( (A1BAR & B1BAR & S3) | (A1BAR & ~B1BAR & S2) ) }
+   BOT1    = { ~(        (~B1BAR & S1) |  A1BAR | (B1BAR & S0) ) }
+   TOP0    = { ~( (A0BAR & B0BAR & S3) | (A0BAR & ~B0BAR & S2) ) }
+   BOT0    = { ~(        (~B0BAR & S1) |  A0BAR | (B0BAR & S0) ) }
+   MBAR    = { ~M }
+
+   F3BAR   = { (TOP3 ^ BOT3) ^ ~( (  CN & MBAR & TOP2 & TOP1 & TOP0) |
+                                  (BOT0 & MBAR & TOP2 & TOP1) |
+                                  (BOT1 & MBAR & TOP2) |
+                                  (BOT2 & MBAR) ) }
+   F2BAR   = { (TOP2 ^ BOT2) ^ ~( (  CN & MBAR & TOP1 & TOP0) |
+                                  (BOT0 & MBAR & TOP1) |
+                                  (BOT1 & MBAR) ) }
+   F1BAR   = { (TOP1 ^ BOT1) ^ ~( (  CN & MBAR & TOP0) |
+                                  (BOT0 & MBAR) ) }
+   F0BAR   = { (TOP0 ^ BOT0) ^ ~(    CN & MBAR) }
+   AEQUALB = { F3BAR & F2BAR & F1BAR & F0BAR }
+   PBAR    = { ~(         TOP3 & TOP2 & TOP1 & TOP0) }
+   GBAR    = { ~( (BOT0 & TOP3 & TOP2 & TOP1) |
+                  (BOT1 & TOP3 & TOP2) |
+                  (BOT2 & TOP3) | 
+                   BOT3 ) }
+   CN+4    = { ~GBAR | (~PBAR & CN) }

UHC181DLY PINDLY (7,0,14) DPWR DGND
+ F0BAR   F1BAR   F2BAR   F3BAR   PBAR   GBAR   CN+4
+ A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3 M CN
+ F0BAR_O F1BAR_O F2BAR_O F3BAR_O PBAR_O GBAR_O CN+4_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   OPERA3 = { CHANGED(A3BAR,0) }
+   OPERA2 = { CHANGED(A2BAR,0) }
+   OPERA1 = { CHANGED(A1BAR,0) }
+   OPERA0 = { CHANGED(A0BAR,0) }
+   OPERB3 = { CHANGED(B3BAR,0) }
+   OPERB2 = { CHANGED(B2BAR,0) }
+   OPERB1 = { CHANGED(B1BAR,0) }
+   OPERB0 = { CHANGED(B0BAR,0) }
+   OPERA  = { OPERA3 | OPERA2 | OPERA1 | OPERA0 }
+   OPERB  = { OPERB3 | OPERB2 | OPERB1 | OPERB0 }
+   OPER   = { OPERA | OPERB }
+   NOTM   = { M=='0 }
+   SUM    = { NOTM & S0=='1 & S1=='0 & S2=='0 & S3=='1 }
+   DIF    = { NOTM & S0=='0 & S1=='1 & S2=='1 & S3=='0 }
+   SUMDIF = { SUM | DIF }
+   CARRY  = { CHANGED(CN,0) & NOTM & SUMDIF }
+
+ PINDLY:
+   F3BAR_O = {
+     CASE (
+       CARRY          , DELAY(-1,25NS,50NS),
+       SUM    & OPERA3, DELAY(-1,28NS,58NS),
+       DIF    & OPERA3, DELAY(-1,28NS,59NS),
+       SUMDIF & OPERB3, DELAY(-1,31NS,64NS),
+       OPERA  & M=='1 , DELAY(-1,27NS,58NS),
+       OPERB  & M=='1 , DELAY(-1,30NS,64NS),
+       SUM    & OPERA , DELAY(-1,30NS,64NS),
+       SUM    & OPERB , DELAY(-1,31NS,66NS),
+       DIF    & OPERA , DELAY(-1,28NS,60NS),
+       DIF    & OPERB , DELAY(-1,32NS,69NS),
+       DELAY(-1,32NS,69NS)
+       )
+     }
+   F2BAR_O = {
+     CASE (
+       CARRY          , DELAY(-1,25NS,50NS),
+       SUM    & OPERA2, DELAY(-1,28NS,58NS),
+       DIF    & OPERA2, DELAY(-1,28NS,59NS),
+       SUMDIF & OPERB2, DELAY(-1,31NS,64NS),
+       OPERA  & M=='1 , DELAY(-1,27NS,58NS),
+       OPERB  & M=='1 , DELAY(-1,30NS,64NS),
+       SUM    & OPERA , DELAY(-1,30NS,64NS),
+       SUM    & OPERB , DELAY(-1,31NS,66NS),
+       DIF    & OPERA , DELAY(-1,28NS,60NS),
+       DIF    & OPERB , DELAY(-1,32NS,69NS),
+       DELAY(-1,32NS,69NS)
+       )
+     }
+   F1BAR_O = {
+     CASE (
+       CARRY          , DELAY(-1,25NS,50NS),
+       SUM    & OPERA1, DELAY(-1,28NS,58NS),
+       DIF    & OPERA1, DELAY(-1,28NS,59NS),
+       SUMDIF & OPERB1, DELAY(-1,31NS,64NS),
+       OPERA  & M=='1 , DELAY(-1,27NS,58NS),
+       OPERB  & M=='1 , DELAY(-1,30NS,64NS),
+       SUM    & OPERA , DELAY(-1,30NS,64NS),
+       SUM    & OPERB , DELAY(-1,31NS,66NS),
+       DIF    & OPERA , DELAY(-1,28NS,60NS),
+       DIF    & OPERB , DELAY(-1,32NS,69NS),
+       DELAY(-1,32NS,69NS)
+       )
+     }
+   F0BAR_O = {
+     CASE (
+       CARRY          , DELAY(-1,25NS,50NS),
+       SUM    & OPERA0, DELAY(-1,28NS,58NS),
+       DIF    & OPERA0, DELAY(-1,28NS,59NS),
+       SUMDIF & OPERB0, DELAY(-1,31NS,64NS),
+       OPERA  & M=='1 , DELAY(-1,27NS,58NS),
+       OPERB  & M=='1 , DELAY(-1,30NS,64NS),
+       SUM    & OPERA , DELAY(-1,30NS,64NS),
+       SUM    & OPERB , DELAY(-1,31NS,66NS),
+       DIF    & OPERA , DELAY(-1,28NS,60NS),
+       DIF    & OPERB , DELAY(-1,32NS,69NS),
+       DELAY(-1,32NS,69NS)
+       )
+     }
+   PBAR_O = {
+     CASE (
+       OPERA & SUM   , DELAY(-1,22NS,46NS),
+       OPERA & DIF   , DELAY(-1,20NS,43NS),
+       OPERB & SUMDIF, DELAY(-1,23NS,49NS),
+       DELAY(-1,23NS,49NS)
+       )
+     }
+   GBAR_O = {
+     CASE (
+       OPERA & SUM, DELAY(-1,26NS,53NS),
+       OPERB & SUM, DELAY(-1,28NS,58NS),
+       OPERA & DIF, DELAY(-1,26NS,54NS),
+       OPERB & DIF, DELAY(-1,28NS,60NS),
+       DELAY(-1,28NS,60NS)
+       )
+     }
+   CN+4_O = {
+     CASE (
+       CARRY      , DELAY(-1,20NS,41NS),
+       OPER  & SUM, DELAY(-1,29NS,59NS),
+       OPERA & DIF, DELAY(-1,28NS,59NS),
+       OPERB & DIF, DELAY(-1,31NS,64NS),
+       DELAY(-1,31NS,64NS)
+       )
+     }

UHC181DLY_OC PINDLY (1,0,13) DPWR DGND
+ AEQUALB
+ A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3 M
+ AEQUALB_O
+ IO_HC_OC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   OPERA = { CHANGED(A3BAR,0) | CHANGED(A2BAR,0) |
+             CHANGED(A1BAR,0) | CHANGED(A0BAR,0) }
+   OPERB = { CHANGED(B3BAR,0) | CHANGED(B2BAR,0) |
+             CHANGED(B1BAR,0) | CHANGED(B0BAR,0) }
+   NOTM  = { M=='0 }
+   DIF   = { NOTM & S0=='0 & S1=='1 & S2=='1 & S3=='0 }
+
+ PINDLY:
+   AEQUALB_O = {
+     CASE (
+       OPERA & DIF, DELAY(-1,29NS,61NS),
+       OPERB & DIF, DELAY(-1,32NS,68NS),
+       DELAY(-1,32NS,68NS)
+       )
+     }

.ENDS

*$
*---------
* 74HC182  LOOK-AHEAD CARRY GENERATOR
*
* HIGH SPEED CMOS LOGIC FAMILY BOOK, 1991, PHILIPS SEMICONDUCTORS
* JLS   9-17-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74HC182   G3BAR_I G2BAR_I G1BAR_I G0BAR_I
+ P3BAR_I P2BAR_I P1BAR_I P0BAR_I CN_I GBAR_O PBAR_O CN+X_O CN+Y_O CN+Z_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC182LOG LOGICEXP (9,14) DPWR DGND
+ G3BAR_I G2BAR_I G1BAR_I G0BAR_I P3BAR_I P2BAR_I P1BAR_I P0BAR_I CN_I
+ G3BAR   G2BAR   G1BAR   G0BAR   P3BAR   P2BAR   P1BAR   P0BAR   CN  
+ GBAR PBAR CN+X CN+Y CN+Z
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   G3BAR = { G3BAR_I }
+   G2BAR = { G2BAR_I }
+   G1BAR = { G1BAR_I }
+   G0BAR = { G0BAR_I }
+   P3BAR = { P3BAR_I }
+   P2BAR = { P2BAR_I }
+   P1BAR = { P1BAR_I }
+   P0BAR = { P0BAR_I }
+   CN    = { CN_I }
+   CNBAR = { ~CN }
+   PBAR  = { P0BAR | P1BAR | P2BAR | P3BAR }
+   GBAR  = {    (        G0BAR & G1BAR & G2BAR & G3BAR) |
+                (P1BAR         & G1BAR & G2BAR & G3BAR) |
+                (P2BAR                 & G2BAR & G3BAR) |
+                (P3BAR                         & G3BAR) }
+   CN+Z  = { ~( (CNBAR & G0BAR & G1BAR & G2BAR) |
+                (P0BAR & G0BAR & G1BAR & G2BAR) |
+                (P1BAR         & G1BAR & G2BAR) |
+                (P2BAR                 & G2BAR) ) }
+   CN+Y  = { ~( (CNBAR & G0BAR & G1BAR) |
+                (P0BAR & G0BAR & G1BAR) |
+                (P1BAR         & G1BAR) ) }
+   CN+X  = { ~( (CNBAR & G0BAR) |
+                (P0BAR & G0BAR) ) }
*
UHC182DLY PINDLY (5,0,9) DPWR DGND
+ GBAR PBAR CN+X CN+Y CN+Z
+ G3BAR G2BAR G1BAR G0BAR P3BAR P2BAR P1BAR P0BAR CN
+ GBAR_O PBAR_O CN+X_O CN+Y_O CN+Z_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   GENER   = { CHANGED(G2BAR,0) | CHANGED(G1BAR,0) | CHANGED(G0BAR,0) }
+   PROP012 = { CHANGED(P2BAR,0) | CHANGED(P1BAR,0) | CHANGED(P0BAR,0) }
+   PROP123 = { CHANGED(P3BAR,0) | CHANGED(P2BAR,0) | CHANGED(P1BAR,0) }
+
+ PINDLY:
+   GBAR_O = {
+     CASE (
+       PROP123                   , DELAY(-1,17NS,36NS),
+       (GENER | CHANGED(G3BAR,0)), DELAY(-1,15NS,34NS),
+       DELAY(-1,17NS,36NS)
+       )
+     }
+   PBAR_O = { DELAY(-1,14NS,30NS) }
+   CN+X_O CN+Y_O CN+Z_O = {
+     CASE (
+       CHANGED(CN,0), DELAY(-1,20NS,43NS),
+       PROP012      , DELAY(-1,17NS,36NS),
+       GENER        , DELAY(-1,16NS,34NS),
+       DELAY(-1,20NS,43NS)
+       )
+     }
*
.ENDS
*
*$
*---------
* 74HC190  Synchronous 4-bit Up/Down Decade Counters 
*
* High Speed CMOS Logic Data Book, 1989, TI
* JSW   7/15/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
*
.SUBCKT 74HC190 CLK_I DUBAR_I CTENBAR_I LOADBAR_I A_I B_I C_I D_I 
+ RCOBAR_O MXMNOUT_O QA_O QB_O QC_O QD_O 
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC190 LOGICEXP (12,22) DPWR DGND
+ CLK_I DUBAR_I CTENBAR_I LOADBAR_I A_I B_I C_I D_I QABAR QBBAR QCBAR QDBAR
+ CLK DUBAR CTENBAR LOADBAR A B C D MXMNOUT RCOBAR 
+ SA RA DA SB RB DB SC RC DC SD RD DD
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL} 
+
+ LOGIC:
+   CLK = { CLK_I }
+   DUBAR = { DUBAR_I }
+   CTENBAR = { CTENBAR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   DU = { ~DUBAR }
+   LOAD = { ~LOADBAR }
+   CTEN = { ~CTENBAR }
+   CTD = { DUBAR & CTEN }
+   CTU = { DU & CTEN }
+   MXMNOUT = { (~QABAR & ~QDBAR & DU) | (QABAR & QBBAR & QCBAR & 
+     QDBAR & DUBAR) }
+   RCOBAR = { ~(MXMNOUT & CTEN & ~CLK) }
+   SA = { ~(A & LOAD) }
+   RA = { ~(~A & LOAD) }
+   DA = { ~QABAR ^ CTEN }
+   SB = { ~(B & LOAD) }
+   RB = { ~(~B & LOAD) }
+   I1DB = { ~QABAR & QDBAR }
+   I2DB = { QABAR & ~(QBBAR & QCBAR & QDBAR) }
+   I3DB = { I1DB ^ ~QBBAR }
+   I4DB = { I2DB ^ ~QBBAR }
+   I5DB = { I3DB & CTU }
+   I6DB = { CTENBAR & ~QBBAR }
+   I7DB = { I4DB & CTD }
+   DB = { I5DB | I6DB | I7DB }
+   SC = { ~(C & LOAD) }
+   RC = { ~(~C & LOAD) }
+   I1DC = { ~QABAR & ~QBBAR }
+   I2DC = { QABAR & QBBAR & ~(QBBAR & QCBAR & QDBAR) }
+   I3DC = { I1DC ^ ~QCBAR }
+   I4DC = { I2DC ^ ~QCBAR }
+   I5DC = { I3DC & CTU }
+   I6DC = { CTENBAR & ~QCBAR }
+   I7DC = { I4DC & CTD }
+   DC = { I5DC | I6DC | I7DC }
+   SD = { ~(D & LOAD) }
+   RD = { ~(~D & LOAD) }
+   I1DD = { QABAR & ~QDBAR }
+   I2DD = { ~QABAR & ~QBBAR & ~QCBAR & QDBAR }
+   I3DD = { QABAR & QBBAR & QCBAR }
+   I4DD = { I1DD | I2DD }
+   I5DD = { I3DD ^ ~QDBAR }
+   I6DD = { I4DD & CTU }
+   I7DD = { ~QDBAR & CTENBAR }
+   I8DD = { I5DD & CTD }
+   DD = { I6DD | I7DD | I8DD }
*
UDA DFF(1) DPWR DGND SA RA CLK DA QA QABAR D0_EFF IO_HC
UDB DFF(1) DPWR DGND SB RB CLK DB QB QBBAR D0_EFF IO_HC
UDC DFF(1) DPWR DGND SC RC CLK DC QC QCBAR D0_EFF IO_HC
UDD DFF(1) DPWR DGND SD RD CLK DD QD QDBAR D0_EFF IO_HC
*
UHC190DLY PINDLY (6,0,8) DPWR DGND
+ QA QB QC QD RCOBAR MXMNOUT
+ A B C D CLK DUBAR CTENBAR LOADBAR
+ QA_O QB_O QC_O QD_O RCOBAR_O MXMNOUT_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   ABCD = { (CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0))
+     & LOADBAR!='1 }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CHANGED_LH(CLK,0), DELAY(-1,31NS,48NS),
+       CHANGED_HL(LOADBAR,0), DELAY(-1,40NS,66NS),
+       ABCD, DELAY(-1,36NS,60NS),
+       DELAY(-1,40NS,66NS)
+       )
+     }
+   RCOBAR_O = {
+     CASE(
+       CHANGED(CLK,0), DELAY(-1,17NS,30NS),
+       CHANGED(CTENBAR,0), DELAY(-1,15NS,33NS),
+       CHANGED(DUBAR,0), DELAY(-1,29NS,57NS),
+       DELAY(-1,29NS,57NS)
+       )
+     }
+   MXMNOUT_O = {
+     CASE(
+       CHANGED(DUBAR,0), DELAY(-1,24NS,48NS),
+       CHANGED_LH(CLK,0), DELAY(-1,39NS,63NS),
+       DELAY(-1,39NS,63NS)
+       )
+     }
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 17MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 30NS
+   MIN_HI = 30NS
+ WIDTH:
+   NODE = LOADBAR
+   MIN_LO = 30NS
+ SETUP_HOLD:
+   DATA(1) CTENBAR
+   CLOCK LH = CLK
+   SETUPTIME = 51NS
+   HOLDTIME = 5NS
+   WHEN = { LOADBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) DUBAR
+   CLOCK LH = CLK
+   SETUPTIME = 51NS
+   HOLDTIME = 5NS
+   WHEN = { LOADBAR!='0 & (CTENBAR!='1 ^ CHANGED(CTENBAR,0)) }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = CLK
+   RELEASETIME_LH = 38NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = LOADBAR
+   SETUPTIME = 38NS
+   HOLDTIME = 5NS
*
.ENDS
*
*$
*---------
*  74HC191  Synchronous 4-bit Up/Down Binary Counters 
*
*  HIGH SPEED CMOS LOGIC DATA BOOK, 1989, TI
*  tc   7/23/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
*
.SUBCKT 74HC191 CLK_I DUBAR_I CTENBAR_I LOADBAR_I A_I B_I C_I D_I
+ RCOBAR_O MXMNOUT_O QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 DFF(1) DPWR DGND SA RA CLK DA QA QABAR
+ D0_EFF IO_HC
U2 DFF(1) DPWR DGND SB RB CLK DB QB QBBAR
+ D0_EFF IO_HC
U3 DFF(1) DPWR DGND SC RC CLK DC QC QCBAR
+ D0_EFF IO_HC
U4 DFF(1) DPWR DGND SD RD CLK DD QD QDBAR
+ D0_EFF IO_HC
*
UHC191LOG LOGICEXP (12,22) DPWR DGND
+ CLK_I DUBAR_I CTENBAR_I LOADBAR_I A_I B_I C_I D_I QABAR QBBAR QCBAR QDBAR
+ CLK DUBAR CTENBAR LOADBAR A B C D MXMNOUT RCOBAR 
+ SA RA DA SB RB DB SC RC DC SD RD DD
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL} MNTYMXDLY={MNTYMXDLY}
+ LOGIC:
+   CLK = { CLK_I }
+   DUBAR = { DUBAR_I }
+   CTENBAR = { CTENBAR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   IEN1 = { ~(~DUBAR | CTENBAR) }
+   IEN2 = { ~(DUBAR | CTENBAR) }
+   ILD = { ~LOADBAR }
+   IQA = { ~QABAR }
+   IQB = { ~QBBAR }
+   IQC = { ~QCBAR }
+   IQD = { ~QDBAR }
+   IM1 = { ~(IQA & IQB & IQC & IQD & ~DUBAR) }
+   IM2 = { ~(QABAR & QBBAR & QCBAR & QDBAR & DUBAR) }
+   IB1 = { ~(IEN2 & (IQA ^ IQB)) }
+   IB2 = { ~((IQB ^ QABAR) & IEN1) }
+   IC1 = { ~(IEN2 & ((IQA & IQB) ^ IQC)) }
+   IC2 = { ~((IQC ^ (QABAR & QBBAR)) & IEN1) }
+   ID1 = { ~(IEN2 & ((IQA & IQB & IQC) ^ IQD)) }
+   ID2 = { ~((IQD ^ (QABAR & QBBAR & QCBAR)) & IEN1) }
+   SA = { ~(A & ILD) }
+   RA = { ~(~A & ILD) }
+   SB = { ~(B & ILD) }
+   RB = { ~(~B & ILD) }
+   SC = { ~(C & ILD) }
+   RC = { ~(~C & ILD) }
+   SD = { ~(D & ILD) }
+   RD = { ~(~D & ILD) }
+   DA = { ~CTENBAR ^ IQA }
+   DB = { ~(IB1 & IB2 & ~(CTENBAR & IQB)) }
+   DC = { ~(IC1 & IC2 & ~(CTENBAR & IQC)) }
+   DD = { ~(ID1 & ID2 & ~(CTENBAR & IQD)) }
+   MXMNOUT = { ~(IM1 & IM2) }
+   RCOBAR = { ~(MXMNOUT & ~CTENBAR & ~CLK) }
*
UHC191DLY PINDLY (6,0,8) DPWR DGND
+ QA QB QC QD RCOBAR MXMNOUT
+ A B C D CLK DUBAR CTENBAR LOADBAR
+ QA_O QB_O QC_O QD_O RCOBAR_O MXMNOUT_O
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = { CHANGED_LH(CLK,0) }
+   DATA = { (CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0))
+     & LOADBAR!='1 }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CLOCK, DELAY(-1,31NS,48NS),
+       DATA, DELAY(-1,36NS,60NS),
+       CHANGED_HL(LOADBAR,0), DELAY(-1,40NS,66NS),
+       DELAY(-1,40NS,66NS)
+       )
+     }
+   RCOBAR_O = {
+     CASE(
+       CHANGED(CLK,0), DELAY(-1,17NS,30NS),
+       CHANGED(CTENBAR,0), DELAY(-1,15NS,33NS),
+       CHANGED(DUBAR,0), DELAY(-1,29NS,57NS),
+       DELAY(-1,29NS,57NS)
+       )
+     }
+   MXMNOUT_O = {
+     CASE(
+       CHANGED(DUBAR,0), DELAY(-1,24NS,48NS),
+       CLOCK, DELAY(-1,39NS,63NS),
+       DELAY(-1,39NS,63NS)
+       )
+     }
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 17MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 30NS
+   MIN_HI = 30NS
+ WIDTH:
+   NODE = LOADBAR
+   MIN_LO = 30NS
+ SETUP_HOLD:
+   DATA(1) = DUBAR
+   CLOCK LH = CLK
+   SETUPTIME = 51NS
+   HOLDTIME = 5NS
+   WHEN = { LOADBAR!='0 & (CTENBAR!='1 ^ CHANGED(CTENBAR,0)) }
+ SETUP_HOLD:
+   DATA(1) CTENBAR
+   CLOCK LH = CLK
+   SETUPTIME = 51NS
+   HOLDTIME = 5NS
+   WHEN = { LOADBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = CLK
+   RELEASETIME_LH = 38NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = LOADBAR
+   SETUPTIME = 38NS
+   HOLDTIME = 5NS
*
.ENDS
*
*$
*---------
*  74HC192  Synchronous 4-bit Up/Down Decade Counters (Dual clock w/ clear) 
*
*  HIGH-SPEED CMOS LOGIC DATA BOOK, 1989, TI
*   JSW   7/27/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
*
.SUBCKT 74HC192 UP_I DOWN_I CLR_I LOADBAR_I A_I B_I C_I D_I 
+ QA_O QB_O QC_O QD_O BOBAR_O COBAR_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 DFF(1) DPWR DGND SA RA MCLK QABAR QA QABAR
+ D0_EFF IO_HC
U2 DFF(1) DPWR DGND SB RB MCLK DB QB QBBAR
+ D0_EFF IO_HC
U3 DFF(1) DPWR DGND SC RC MCLK DC QC QCBAR
+ D0_EFF IO_HC
U4 DFF(1) DPWR DGND SD RD MCLK DD QD QDBAR
+ D0_EFF IO_HC
U5 SRFF(1) DPWR DGND UP DOWN $D_HI $D_LO $D_LO IU ID
+ D0_GFF IO_HC
*
UHC192LOG LOGICEXP (14,22) DPWR DGND
+ UP_I DOWN_I CLR_I LOADBAR_I A_I B_I C_I D_I QABAR QBBAR QCBAR QDBAR IU ID
+ UP DOWN CLR LOADBAR A B C D BOBAR COBAR MCLK 
+ SA RA SB RB SC RC SD RD DB DC DD
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   UP = { UP_I }
+   DOWN = { DOWN_I }
+   CLR = { CLR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   ICL = { ~CLR }
+   ILD = { ~LOADBAR }
+   MCLK = { UP & DOWN }
+   IN1 = { ~(QBBAR & QCBAR & QDBAR) }
+   IQA = { ~QABAR }
+   IQB = { ~QBBAR }
+   IQC = { ~QCBAR }
+   IQD = { ~QDBAR }
+   IB1 = { IU & ((IQA & QDBAR) ^ IQB) }
+   IB2 = { (IQB ^ (QABAR & IN1)) & ID }
+   IC1 = { IU & ((IQA & IQB) ^ IQC) }
+   IC2 = { (IQC ^ (QABAR & QBBAR & IN1)) & ID }
+   ID1 = { IU & ((QDBAR & IQC & IQB & IQA) | (QABAR & IQD)) }
+   ID2 = { (IQD ^ (QABAR & QBBAR & QCBAR)) & ID }
+   DB = { IB1 | IB2 }
+   DC = { IC1 | IC2 }
+   DD = { ID1 | ID2 }
+   SA = { ~(A & ICL & ILD) }
+   RA = { ~(~A & ILD) & ICL }
+   SB = { ~(B & ICL & ILD) }
+   RB = { ~(~B & ILD) & ICL }
+   SC = { ~(C & ICL & ILD) }
+   RC = { ~(~C & ILD) & ICL }
+   SD = { ~(D & ICL & ILD) }
+   RD = { ~(~D & ILD) & ICL }
+   COBAR = { ~(IQA & IQD & ~UP) }
+   BOBAR = { ~(QABAR & QBBAR & QCBAR & QDBAR & ~DOWN) }
*
UHC192DLY PINDLY (6,0,8) DPWR DGND
+ QA QB QC QD BOBAR COBAR
+ UP DOWN LOADBAR CLR A B C D
+ QA_O QB_O QC_O QD_O BOBAR_O COBAR_O
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   UPDN = { (CHANGED_LH(UP,0) | CHANGED_LH(DOWN,0)) & LOADBAR!='0
+     & CLR!='1 }
+   CLEAR = { CHANGED_LH(CLR,0) }
+   LOAD = { CHANGED_HL(LOADBAR,0) }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CLEAR, DELAY(-1,36NS,60NS),
+       UPDN, DELAY(-1,40NS,63NS),
+       LOAD, DELAY(-1,40NS,65NS),
+       DELAY(-1,40NS,65NS)
+       )
+     }
+   BOBAR_O = {
+     CASE(
+       CHANGED(DOWN,0), DELAY(-1,24NS,41NS),
+       CLEAR, DELAY(-1,36NS,60NS),
+       LOAD, DELAY(-1,40NS,65NS),
+       DELAY(-1,40NS,65NS)
+       )
+     }
+   COBAR_O = {
+     CASE(
+       CHANGED(UP,0), DELAY(-1,24NS,41NS),
+       CLEAR, DELAY(-1,36NS,60NS),
+       LOAD, DELAY(-1,40NS,65NS),
+       DELAY(-1,40NS,65NS)
+       )
+     }
+ FREQ:
+   NODE = UP
+   MAXFREQ = 17MEG
+ FREQ:
+   NODE = DOWN
+   MAXFREQ = 17MEG
+ WIDTH:
+   NODE = UP
+   MIN_LO = 30NS
+   MIN_HI = 30NS
+ WIDTH:
+   NODE = DOWN
+   MIN_LO = 30NS
+   MIN_HI = 30NS
+ WIDTH:
+   NODE = LOADBAR
+   MIN_LO = 30NS
+   WHEN = { CLR!='1 }
+ WIDTH:
+   NODE = CLR
+   MIN_HI = 30NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = LOADBAR
+   SETUPTIME = 28NS
+   HOLDTIME = 5NS
+   WHEN = { CLR!='1 }
+ SETUP_HOLD:
+   DATA(1) = CLR
+   CLOCK LH = UP
+   RELEASETIME_HL = 28NS
+ SETUP_HOLD:
+   DATA(1) = CLR
+   CLOCK LH = DOWN
+   RELEASETIME_HL = 28NS
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = UP
+   RELEASETIME_LH = 28NS
+   WHEN = { CLR!='1 }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = DOWN
+   RELEASETIME_LH = 28NS
+   WHEN = { CLR!='1 }
*
.ENDS
*
*$
*---------
*  74HC193  Synchronous 4-bit Up/Down Binary Counters (Dual clock w/ clear) 
*
*  HIGH-SPEED CMOS LOGIC DATA BOOK, 1989, TI
*  tc   7/27/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
*
.SUBCKT 74HC193 UP_I DOWN_I CLR_I LOADBAR_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O BOBAR_O COBAR_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 DFF(1) DPWR DGND SA RA MCLK QABAR QA QABAR
+ D0_EFF IO_HC
U2 DFF(1) DPWR DGND SB RB MCLK DB QB QBBAR
+ D0_EFF IO_HC
U3 DFF(1) DPWR DGND SC RC MCLK DC QC QCBAR
+ D0_EFF IO_HC
U4 DFF(1) DPWR DGND SD RD MCLK DD QD QDBAR
+ D0_EFF IO_HC
U5 SRFF(1) DPWR DGND UP DOWN $D_HI $D_LO $D_LO IU ID
+ D0_GFF IO_HC
*
UHC193LOG LOGICEXP (14,22) DPWR DGND
+ UP_I DOWN_I CLR_I LOADBAR_I A_I B_I C_I D_I QABAR QBBAR QCBAR QDBAR IU ID
+ UP DOWN CLR LOADBAR A B C D BOBAR COBAR MCLK 
+ SA RA SB RB SC RC SD RD DB DC DD
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   UP = { UP_I }
+   DOWN = { DOWN_I }
+   CLR = { CLR_I }
+   LOADBAR = { LOADBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+   ICL = { ~CLR }
+   ILD = { ~LOADBAR }
+   MCLK = { UP & DOWN }
+   IQA = { ~QABAR }
+   IQB = { ~QBBAR }
+   IQC = { ~QCBAR }
+   IQD = { ~QDBAR }
+   IB1 = { IU & (IQA ^ IQB) }
+   IB2 = { (IQB ^ QABAR) & ID }
+   IC1 = { IU & ((IQA & IQB) ^ IQC) }
+   IC2 = { (IQC ^ (QABAR & QBBAR)) & ID }
+   ID1 = { IU & ((IQA & IQB & IQC) ^ IQD) }
+   ID2 = { (IQD ^ (QABAR & QBBAR & QCBAR)) & ID }
+   DB = { IB1 | IB2 }
+   DC = { IC1 | IC2 }
+   DD = { ID1 | ID2 }
+   SA = { ~(A & ICL & ILD) }
+   RA = { ~(~A & ILD) & ICL }
+   SB = { ~(B & ICL & ILD) }
+   RB = { ~(~B & ILD) & ICL }
+   SC = { ~(C & ICL & ILD) }
+   RC = { ~(~C & ILD) & ICL }
+   SD = { ~(D & ICL & ILD) }
+   RD = { ~(~D & ILD) & ICL }
+   COBAR = { ~(IQA & IQB & IQC & IQD & ~UP) }
+   BOBAR = { ~(QABAR & QBBAR & QCBAR & QDBAR & ~DOWN) }
*
UHC193DLY PINDLY (6,0,8) DPWR DGND
+ QA QB QC QD BOBAR COBAR
+ UP DOWN LOADBAR CLR A B C D
+ QA_O QB_O QC_O QD_O BOBAR_O COBAR_O
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   UPDN = { (CHANGED_LH(UP,0) | CHANGED_LH(DOWN,0)) & LOADBAR!='0
+     & CLR!='1 }
+   CLEAR = { CHANGED_LH(CLR,0) }
+   LOAD = { CHANGED_HL(LOADBAR,0) }
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CLEAR, DELAY(-1,36NS,60NS),
+       UPDN , DELAY(-1,40NS,63NS),
+       LOAD , DELAY(-1,40NS,65NS),
+       DELAY(-1,40NS,65NS)
+       )
+     }
+   BOBAR_O = {
+     CASE(
+       CHANGED(DOWN,0), DELAY(-1,24NS,41NS),
+       CLEAR, DELAY(-1,36NA,60NS),
+       LOAD , DELAY(-1,40NS,65NS),
+       DELAY(-1,40NS,65NS)
+       )
+     }
+   COBAR_O = {
+     CASE(
+       CHANGED(UP,0), DELAY(-1,24NS,41NS),
+       CLEAR, DELAY(-1,36NA,60NS),
+       LOAD , DELAY(-1,40NS,65NS),
+       DELAY(-1,40NS,65NS)
+       )
+     }
+ FREQ:
+   NODE = UP
+   MAXFREQ = 17MEG
+ FREQ:
+   NODE = DOWN
+   MAXFREQ = 17MEG
+ WIDTH:
+   NODE = UP
+   MIN_LO = 30NS
+   MIN_HI = 30NS
+ WIDTH:
+   NODE = DOWN
+   MIN_LO = 30NS
+   MIN_HI = 30NS
+ WIDTH:
+   NODE = LOADBAR
+   MIN_LO = 30NS
+   WHEN = { CLR!='1 }
+ WIDTH:
+   NODE = CLR
+   MIN_HI = 30NS
+ SETUP_HOLD:
+   DATA(4) = A B C D
+   CLOCK LH = LOADBAR
+   SETUPTIME = 28NS
+   HOLDTIME = 5NS
+   WHEN = { CLR!='1 }
+ SETUP_HOLD:
+   DATA(1) = CLR
+   CLOCK LH = UP
+   RELEASETIME_HL = 28NS
+ SETUP_HOLD:
+   DATA(1) = CLR
+   CLOCK LH = DOWN
+   RELEASETIME_HL = 28NS
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = UP
+   RELEASETIME_LH = 28NS
+   WHEN = { CLR!='1 }
+ SETUP_HOLD:
+   DATA(1) = LOADBAR
+   CLOCK LH = DOWN
+   RELEASETIME_LH = 28NS
+   WHEN = { CLR!='1 }
*
.ENDS
*
*$
*---------
* 74HC194  4-BIT BIDIRECTIONAL UNIVERSAL SHIFT REGISTERS
*
* THE HIGH-SPEED CMOS LOGIC DATA BOOK, 1989, TI
* NH 7/7/92          REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
* 74HC194 WAS REMODELED USING THE LOGIC DIAGRAM OF 74AS194
*
.SUBCKT 74HC194 CLK_I CLRBAR_I S1_I S0_I SL_I SR_I A_I B_I C_I D_I
+               QA_O QB_O QC_O QD_O
+       OPTIONAL: DPWR = $G_DPWR   DGND = $G_DGND
+       PARAMS:   MNTYMXDLY = 0    IO_LEVEL = 0
*
UHC194LOG LOGICEXP(14,19) DPWR DGND
+ CLK_I CLRBAR_I S1_I S0_I SL_I SR_I A_I B_I C_I D_I QA QB QC QD
+ CLK CLRBAR S1 S0 SL SR A B C D KA KB KC KD JA JB JC JD CLOCK
+ D0_GATE  IO_HC  IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
*
* INTERMEDIATE TERM
+   LOAD   = { S1_I & S0_I }
+   SRIGHT = { ~S1_I & S0_I }
+   SLEFT  = { S1_I & ~S0_I }
+   HOLD   = { ~S1_I & ~S0_I }
*
* OUTPUT ASSIGNMENT
*
+   CLK = { CLK_I }
+   CLRBAR = { CLRBAR_I }
+   S1 = { S1_I }
+   S0 = { S0_I }
+   SL = { SL_I }
+   SR = { SR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+
+   KA = { ~( (SR & SRIGHT) | (LOAD & A) | (SLEFT & QB) | (HOLD & QA) ) }
+   KB = { ~( (QA & SRIGHT) | (LOAD & B) | (SLEFT & QC) | (HOLD & QB) ) }
+   KC = { ~( (QB & SRIGHT) | (LOAD & C) | (SLEFT & QD) | (HOLD & QC) ) }
+   KD = { ~( (QC & SRIGHT) | (LOAD & D) | (SLEFT & SL) | (HOLD & QD) ) }
+   JA = { ~KA }
+   JB = { ~KB }
+   JC = { ~KC }
+   JD = { ~KD }
+   CLOCK = { ~CLK }
*
U1 JKFF(4) DPWR DGND $D_HI CLRBAR CLOCK JA JB JC JD KA KB KC KD
+ QA QB QC QD $D_NC $D_NC $D-NC $D_NC
+ D0_EFF  IO_HC
*
UHC194DLY PINDLY (4,0,10) DPWR DGND
+ QA QB QC QD
+ CLK CLRBAR S0 S1 SL SR A B C D
+ QA_O QB_O QC_O QD_O
+ IO_HC
+ MNTYMXDLY = {MNTYMXDLY}   IO_LEVEL = {IO_LEVEL}
+
+ PINDLY:
+   QA_O QB_O QC_O QD_O = {
+     CASE(
+       CHANGED_LH(CLK,0), DELAY(-1,17NS,36NS),
+       CHANGED_HL(CLRBAR,0), DELAY(-1,17NS,38NS),
+       DELAY(8NS,18NS,39NS)          ;DEFAULT
+       )
+     }
+
+ BOOLEAN:
+   NOT_CLEAR = { CLRBAR!='0 }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 20NS
+   MIN_LO = 20NS
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+
+ SETUP_HOLD:
+   DATA(2) S0 S1
+   CLOCK LH = CLK
+   SETUPTIME = 25NS
+   WHEN = { NOT_CLEAR }
+
+ SETUP_HOLD:
+   DATA(1) SL
+   CLOCK LH = CLK
+   SETUPTIME = 25NS
+   WHEN = { NOT_CLEAR & (S1!='0 ^ CHANGED(S1,0)) & (S0!='1 ^ CHANGED(S0,0)) }
+
+ SETUP_HOLD:
+   DATA(1) SR
+   CLOCK LH = CLK
+   SETUPTIME = 25NS
+   WHEN = { NOT_CLEAR & (S1!='1 ^ CHANGED(S1,0)) & (S0!='0 ^ CHANGED(S0,0)) }
+
+ SETUP_HOLD:
+   DATA(4) A B C D
+   CLOCK LH = CLK
+   SETUPTIME = 25NS
+   WHEN = { NOT_CLEAR & (S1!='0 ^ CHANGED(S1,0)) & (S0!='0 ^ CHANGED(S0,0)) }
+
+ SETUP_HOLD:
+   DATA(1) CLRBAR
+   CLOCK LH = CLK
+   RELEASETIME_LH = 25NS
*
.ENDS
*
*$
*---------
* 74HC195  4-BIT PARALLEL-ACCESS SHIFT REGISTERS
*
* THE HIGH-SPEED CMOS LOGIC DATA BOOK, 1989, TI
* NH 7/6/92       REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
* 74HC195 WAS REMODELED USING THE LOGIC DIAGRAM OF 74LS915A
*
.SUBCKT 74HC195 CLK_I SH/LDBAR_I CLRBAR_I J_I KBAR_I A_I B_I C_I D_I
+ QA_O QB_O QC_O QD_O QDBAR_O
+ OPTIONAL: DPWR = $G_DPWR   DGND = $G_DGND
+ PARAMS:   MNTYMXDLY = 0   IO_LEVEL = 0
*
UHC195LOG LOGICEXP(13,18) DPWR DGND
+ CLK_I SH/LDBAR_I CLRBAR_I J_I KBAR_I A_I B_I C_I D_I QA QB QC QABAR
+ CLK SH/LDBAR CLRBAR J KBAR A B C D KA KB KC KD JA JB JC JD CLKBAR
+ D0_GATE  IO_HC  IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
+   CLK = { CLK_I }
+   SH/LDBAR = { SH/LDBAR_I }
+   CLRBAR = { CLRBAR_I }
+   J = { J_I }
+   KBAR = { KBAR_I }
+   A = { A_I }
+   B = { B_I }
+   C = { C_I }
+   D = { D_I }
+
* INTERMEDIATE TERM
+   LOAD = { ~SH/LDBAR }
+
+   KA = { ~((QABAR & J & SH/LDBAR) | (SH/LDBAR & KBAR & QA) | (LOAD & A)) }
+   KB = { ~( (QA & SH/LDBAR) | (LOAD & B) ) }
+   KC = { ~( (QB & SH/LDBAR) | (LOAD & C) ) }
+   KD = { ~( (QC & SH/LDBAR) | (LOAD & D) ) }
+   JA = { ~KA }
+   JB = { ~KB }
+   JC = { ~KC }
+   JD = { ~KD }
+   CLKBAR = { ~CLK }
*
U1 JKFF(4) DPWR DGND $D_HI CLRBAR CLKBAR JA JB JC JD KA KB KC KD
+ QA QB QC QD QABAR $D_NC $D_NC QDBAR
+ D0_EFF  IO_HC
*
UHC195DLY PINDLY (5,0,9) DPWR DGND
+ QA QB QC QD QDBAR
+ CLK CLRBAR SH/LDBAR J KBAR A B C D
+ QA_O QB_O QC_O QD_O QDBAR_O
+ IO_HC
+ MNTYMXDLY = {MNTYMXDLY}   IO_LEVEL = {IO_LEVEL}
+
+ PINDLY:
+   QA_O QB_O QC_O QD_O QDBAR_O = {
+     CASE(
+       CHANGED_LH(CLK,0), DELAY(-1,17NS,36NS),
+       CHANGED_HL(CLRBAR,0), DELAY(-1,17NS,38NS),
+       DELAY(8NS,18NS,39NS)            ;DEFAULT
+       )
+     }
+
+ BOOLEAN:
+   NOT_CLEAR = { CLRBAR!='0 }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 20NS
+   MIN_LO = 20NS
+
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+
+ SETUP_HOLD:
+   DATA(1) SH/LDBAR
+   CLOCK LH = CLK
+   SETUPTIME = 25NS
+   WHEN = { NOT_CLEAR }
+
+ SETUP_HOLD:
+   DATA(1) CLRBAR
+   CLOCK LH = CLK
+   RELEASETIME_LH = 25NS
+
+ SETUP_HOLD:                          ;SHIFT MODE
+   DATA(2) J KBAR                     ;WHEN SH/LDBAR = 1 OR
+   CLOCK LH = CLK                     ;AT THE TRANSITION FROM H TO L
+   SETUPTIME = 25NS
+   WHEN = { NOT_CLEAR & (SH/LDBAR!='0 ^ CHANGED(SH/LDBAR,0)) }
+
+ SETUP_HOLD:                          ;LOAD MODE
+   DATA(4) A B C D                    ;WHEN SH/LDBAR = 0 OR
+   CLOCK LH = CLK                     ;AT THE TRANSITION FROM L TO H
+   SETUPTIME = 25NS
+   WHEN = { NOT_CLEAR & (SH/LDBAR!='1 ^ CHANGED(SH/LDBAR,0)) }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74HC237  DECODER/DEMULTIPLEXER 3-8 LINE WITH ADDRESS LATCHES
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   8-4-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*    
.SUBCKT 74HC237   GLBAR_I G1_I G2BAR_I A_I B_I C_I
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 DLTCH(3) DPWR DGND
+ $D_HI $D_HI LATCHEN
+ A     B     C
+ QA    QB    QC
+ QABAR QBBAR QCBAR
+ D0_GFF  IO_HC
*
UHC237LOG LOGICEXP (12,14) DPWR DGND
+ GLBAR_I G1_I G2BAR_I A_I B_I C_I QA QB QC QABAR QBBAR QCBAR
+ GLBAR                A   B   C   LATCHEN ENABLE
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   GLBAR   = { GLBAR_I }
+   G1      = { G1_I }
+   G2BAR   = { G2BAR_I }
+   A       = { A_I }
+   B       = { B_I }
+   C       = { C_I }
+   LATCHEN = { ~GLBAR }
+   ENABLE  = { G1 & ~G2BAR }
+   Y0      = { ENABLE & QCBAR & QBBAR & QABAR }
+   Y1      = { ENABLE & QCBAR & QBBAR & QA    }
+   Y2      = { ENABLE & QCBAR & QB    & QABAR }
+   Y3      = { ENABLE & QCBAR & QB    & QA    }
+   Y4      = { ENABLE & QC    & QBBAR & QABAR }
+   Y5      = { ENABLE & QC    & QBBAR & QA    }
+   Y6      = { ENABLE & QC    & QB    & QABAR }
+   Y7      = { ENABLE & QC    & QB    & QA    }
*
UHC237DLY PINDLY (8,0,5) DPWR DGND
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7
+ GLBAR ENABLE A B C
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ABLE  = { CHANGED(ENABLE,0) }
+   ABLEL = { CHANGED(GLBAR,0) }
+   ADDR  = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+
+ PINDLY:
+   Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O = {
+     CASE (
+       ABLE , DELAY(-1,18NS,36NS),
+       ADDR , DELAY(-1,23NS,48NS),
+       ABLEL, DELAY(-1,24NS,48NS),
+       DELAY(-1,24NS,48NS)
+       )
+     }
+
+ WIDTH:
+   NODE      = GLBAR
+   MIN_LO    = 20NS
+ SETUP_HOLD:
+   DATA(3)   = A B C
+   CLOCK LH  = GLBAR
+   SETUPTIME = 19NS
+   HOLDTIME  =  5NS
*
.ENDS
*
*$
*---------
* 74HC238  DECODER/DEMULTIPLEXER 3-8 LINE
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   8-4-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*    
.SUBCKT 74HC238   G1_I G2ABAR_I G2BBAR_I A_I B_I C_I
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC238LOG LOGICEXP (6,12) DPWR DGND
+ G1_I G2ABAR_I G2BBAR_I A_I B_I C_I
+ G1   G2ABAR   G2BBAR  ENABLE
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   G1     = { G1_I }
+   G2ABAR = { G2ABAR_I }
+   G2BBAR = { G2BBAR_I }
+   A      = { A_I }
+   B      = { B_I }
+   C      = { C_I }
+   ABAR   = { ~A }
+   BBAR   = { ~B }
+   CBAR   = { ~C }
+   ENABLE = { ~G2ABAR & ~G2BBAR & G1 }
+   Y0     = { ENABLE & CBAR & BBAR & ABAR }
+   Y1     = { ENABLE & CBAR & BBAR & A    }
+   Y2     = { ENABLE & CBAR & B    & ABAR }
+   Y3     = { ENABLE & CBAR & B    & A    }
+   Y4     = { ENABLE & C    & BBAR & ABAR }
+   Y5     = { ENABLE & C    & BBAR & A    }
+   Y6     = { ENABLE & C    & B    & ABAR }
+   Y7     = { ENABLE & C    & B    & A    }
*
UHC238DLY PINDLY (8,0,1) DPWR DGND
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7
+ ENABLE
+ Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ABLE = { CHANGED(ENABLE,0) }
+
+ PINDLY:
+   Y0_O Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O = {
+     CASE (
+       ABLE, DELAY(-1,17NS,39NS),
+       DELAY(-1,20NS,45NS)
+       )
+     }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74HC239  DECODER/DEMULTIPLEXER 2-4 LINE
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   8-3-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*    
.SUBCKT 74HC239   GBAR_I A_I B_I   Y0_O Y1_O Y2_O Y3_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC239LOG LOGICEXP (3,7) DPWR DGND
+ GBAR_I A_I B_I
+ GBAR   A   B
+ Y0 Y1 Y2 Y3
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   GBAR   = { GBAR_I }
+   A      = { A_I }
+   B      = { B_I }
+   ABAR   = { ~A }
+   BBAR   = { ~B }
+   ENABLE = { ~GBAR }
+   Y0     = { ENABLE & BBAR & ABAR }
+   Y1     = { ENABLE & BBAR & A    }
+   Y2     = { ENABLE & B    & ABAR }
+   Y3     = { ENABLE & B    & A    }
*
UHC239DLY PINDLY (4,0,3) DPWR DGND
+ Y0 Y1 Y2 Y3
+ GBAR A B
+ Y0_O Y1_O Y2_O Y3_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ABLE = { CHANGED(GBAR,0) }
+   ADDR = { CHANGED(A,0) | CHANGED(B,0) }
+
+ PINDLY:
+   Y0_O Y1_O Y2_O Y3_O = {
+     CASE (
+       ABLE, DELAY(-1,14NS,30NS),
+       ADDR, DELAY(-1,18NS,38NS),
+       DELAY(-1,18NS,38NS)
+       )
+     }
*
.ENDS
*
*$
*----------
* 74HC240  OCTAL BUFFERS AND LINE DRIVERS WITH 3-STATE OUTPUTS
*
* The High-speed CMOS Logic Data Book, 1988, TI
* tvh	06/30/89	Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC240  1A1 1A2 1A3 1A4 2A1 2A2 2A3 2A4 G1BAR G2BAR 1Y1 1Y2 1Y3 1Y4
+	2Y1 2Y2 2Y3 2Y4
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UAB inva(2) DPWR DGND
+	G1BAR G2BAR   G1 G2 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U1 inv3a(4) DPWR DGND
+	1A1 1A2 1A3 1A4   G1   1Y1 1Y2 1Y3 1Y4 
+	D_HC240 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 inv3a(4) DPWR DGND
+	2A1 2A2 2A3 2A4   G2   2Y1 2Y2 2Y3 2Y4 
+	D_HC240 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC240 utgate (
+	tplhty=10ns	tplhmx=25ns
+	tphlty=10ns	tphlmx=25ns
+	tpzhty=15ns	tpzhmx=38ns
+	tpzlty=15ns	tpzlmx=38ns
+	tphzty=22ns	tphzmx=38ns
+	tplzty=22ns	tplzmx=38ns
+	)
*$
*----------
* 74HC241  OCTAL BUFFERS AND LINE DRIVERS WITH 3-STATE OUTPUTS
*
* The High-speed CMOS Logic Data Book, 1988, TI
* tvh	06/30/89	Update interface and model names
* jgt   09/08/92        Bug Fix: changed inverters to Buffers
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC241  1A1 1A2 1A3 1A4 2A1 2A2 2A3 2A4 G1BAR G2 1Y1 1Y2 1Y3 1Y4 2Y1
+	2Y2 2Y3 2Y4
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UA inv DPWR DGND
+	G1BAR   G1 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U1 buf3a(4) DPWR DGND
+	1A1 1A2 1A3 1A4   G1   1Y1 1Y2 1Y3 1Y4 
+	D_HC241 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 buf3a(4) DPWR DGND
+	2A1 2A2 2A3 2A4   G2   2Y1 2Y2 2Y3 2Y4 
+	D_HC241 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC241 utgate (
+	tplhty=12ns	tplhmx=29ns
+	tphlty=12ns	tphlmx=29ns
+	tpzhty=17ns	tpzhmx=38ns
+	tpzlty=17ns	tpzlmx=38ns
+	tphzty=18ns	tphzmx=38ns
+	tplzty=18ns	tplzmx=38ns
+	)
*
*$
*----------
* 74HC242  OCTAL BUS TRANSCEIVERS WITH 3-STATE OUTPUTS
*
* The High-speed CMOS Logic Data Book, 1988, TI
* tvh	06/30/89	Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC242  A1 A2 A3 A4 G1 G2 B1 B2 B3 B4
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UAB inva(2) DPWR DGND
+	G1 G2   G1A G2A 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
UC or(2) DPWR DGND
+	G1A G2A   G1B 
+	D0_GATE IO_HC 
UD nand(2) DPWR DGND
+	G1A G2A   G2B 
+	D0_GATE IO_HC 
UEF nora(2,2) DPWR DGND
+	G1B GAB G2B GBA   GBA GAB 
+	D0_GATE IO_HC 
U1 inv3a(4) DPWR DGND
+	A1 A2 A3 A4   GAB   B1 B2 B3 B4 
+	D_HC242 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 inv3a(4) DPWR DGND
+	B1 B2 B3 B4   GBA   A1 A2 A3 A4 
+	D_HC242 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC242 utgate (
+	tplhty=12ns	tplhmx=25ns
+	tphlty=12ns	tphlmx=25ns
+	tpzhty=21ns	tpzhmx=38ns
+	tpzlty=21ns	tpzlmx=38ns
+	tphzty=23ns	tphzmx=38ns
+	tplzty=23ns	tplzmx=38ns
+	)
*$
*----------
* 74HC243  OCTAL BUS TRANSCEIVERS WITH 3-STATE OUTPUTS
*
* The High-speed CMOS Logic Data Book, 1988, TI
* tvh	06/30/89	Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC243  A1 A2 A3 A4 G1 G2 B1 B2 B3 B4
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
* DIFFERENT CIRCUIT FROM ALS LS AND AS
UAB inva(2) DPWR DGND
+	G1 G2   G1A G2A 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
UC or(2) DPWR DGND
+	G1A G2A   G1B 
+	D0_GATE IO_HC 
UD nand(2) DPWR DGND
+	G1A G2A   G2B 
+	D0_GATE IO_HC 
UEF nora(2,2) DPWR DGND
+	G1B GAB G2B GBA   GBA GAB 
+	D0_GATE IO_HC 
U1 buf3a(4) DPWR DGND
+	A1 A2 A3 A4   GAB   B1 B2 B3 B4 
+	D_HC243 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 buf3a(4) DPWR DGND
+	B1 B2 B3 B4   GBA   A1 A2 A3 A4 
+	D_HC243 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC243 utgate (
+	tplhty=12ns	tplhmx=25ns
+	tphlty=12ns	tphlmx=25ns
+	tpzhty=21ns	tpzhmx=38ns
+	tpzlty=21ns	tpzlmx=38ns
+	tphzty=23ns	tphzmx=38ns
+	tplzty=23ns	tplzmx=38ns
+	)
*$
*----------
* 74HC244  OCTAL BUFFERS AND LINE DRIVERS WITH 3-STATE OUTPUTS
*
* The High-speed CMOS Logic Data Book, 1988, TI
* tvh	06/30/89	Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC244  1A1 1A2 1A3 1A4 2A1 2A2 2A3 2A4 G1BAR G2BAR 1Y1 1Y2 1Y3 1Y4
+	2Y1 2Y2 2Y3 2Y4
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UAB inva(2) DPWR DGND
+	G1BAR G2BAR   G1 G2 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U1 buf3a(4) DPWR DGND
+	1A1 1A2 1A3 1A4   G1   1Y1 1Y2 1Y3 1Y4 
+	D_HC244 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 buf3a(4) DPWR DGND
+	2A1 2A2 2A3 2A4   G2   2Y1 2Y2 2Y3 2Y4 
+	D_HC244 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC244 utgate (
+	tplhty=13ns	tplhmx=29ns
+	tphlty=13ns	tphlmx=29ns
+	tpzhty=15ns	tpzhmx=38ns
+	tpzlty=15ns	tpzlmx=38ns
+	tphzty=15ns	tphzmx=38ns
+	tplzty=15ns	tplzmx=38ns
+	)
*$
*----------
* 74HC245  OCTAL BUS TRANSCEIVERS WITH 3-STATE OUTPUTS
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   9-2-92   UPDATE TIMING
* rbh   11/11/92	Added bus I/O model
*
.SUBCKT 74HC245  DIR_I GBAR_I
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 BUFA(2) DPWR DGND
+ DIR_I GBAR_I
+ DIR   GBAR
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
U2 INV DPWR DGND
+ DIR   DIRBAR
+ D0_GATE IO_HC
U3 NORA(2,2) DPWR DGND
+ DIRBAR GBAR DIR GBAR
+ ENABLEAB    ENABLEBA
+ D0_GATE IO_HC
*
U4 BUF3A(8) DPWR DGND
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B
+ ENABLEAB
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ D_HC245 IO_HC_BUS
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U5 BUF3A(8) DPWR DGND
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ ENABLEBA
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B
+ D_HC245 IO_HC_BUS
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
*
.MODEL D_HC245 UTGATE (
+ TPLHTY=15NS		TPLHMX=26NS
+ TPHLTY=15NS		TPHLMX=26NS
+ TPZHTY=23NS		TPZHMX=58NS
+ TPZLTY=23NS		TPZLMX=58NS
+ TPHZTY=25NS		TPHZMX=50NS
+ TPLZTY=25NS		TPLZMX=50NS
+ )
*
.ENDS
*
*$
*---------
* 74HC251  MULTIPLEXER/DATA SELECTOR 8-1 LINE WITH 3-STATE OUTPUTS
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG. 1989, TI
* TC  08/24/92  REMODELED USING LOGICEXP, PINDLY, & CONSTRAINT DEVICES
*
* NOTE: THE LOGIC FROM 74ALS251 IS USED TO MODEL THIS DEVICE.
*
.SUBCKT 74HC251 GBAR_I A_I B_I C_I D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I
+ Y_O W_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC251LOG LOGICEXP(12,14) DPWR DGND
+ GBAR_I A_I B_I C_I D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I
+ GBAR A B C D0 D1 D2 D3 D4 D5 D6 D7 W Y
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   GBAR = { GBAR_I }
+   A = { A_I }  
+   B = { B_I }  
+   C = { C_I }  
+   D0 = { D0_I }
+   D1 = { D1_I }
+   D2 = { D2_I }
+   D3 = { D3_I }
+   D4 = { D4_I }
+   D5 = { D5_I }
+   D6 = { D6_I }
+   D7 = { D7_I }
+   IA = { ~A }
+   IB = { ~B }
+   IC = { ~C }
+   ID0 = { D0 & IA & IB & IC }
+   ID1 = { D1 & A & IB & IC }
+   ID2 = { D2 & IA & B & IC }
+   ID3 = { D3 & A & B & IC }
+   ID4 = { D4 & IA & IB & C }
+   ID5 = { D5 & A & IB & C }
+   ID6 = { D6 & IA & B & C }
+   ID7 = { D7 & A & B & C }
+   W = { ~(ID0 | ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7) }
+   Y = { ~W }
*
UHC251DLY PINDLY (2,1,11) DPWR DGND
+ W Y
+ GBAR
+ A B C D0 D1 D2 D3 D4 D5 D6 D7
+ W_O Y_O
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   DATA = { CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) |
+     CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0) }
+   SELECT = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+ TRISTATE:
+   ENABLE LO GBAR
+   Y_O W_O = { 
+     CASE(
+       SELECT, DELAY(-1,21NS,51NS),
+       DATA, DELAY(-1,17NS,49NS),
+       TRN_$Z, DELAY(-1,15NS,49NS),
+       TRN_Z$, DELAY(-1,10NS,36NS),
+       DELAY(-1,22NS,52NS)
+       )
+     }
*
.ENDS
*
*$
*---------
* 74HC253  DUAL 1-OF-4 DATA SELECTORS/MULTIPLEXERS WITH 3-STATE OUTPUTS
*
* High Speed CMOS Logic Data Book, 1989, TI
* JSW   8/24/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices
* rbh   11/11/92  Added bus I/O model
* NOTICE:  Logic diagram from 74253 was used.
*
.SUBCKT 74HC253 G1BAR_I G2BAR_I A_I B_I 1C0_I 1C1_I 1C2_I  1C3_I
+ 2C0_I 2C1_I 2C2_I 2C3_I Y1_O Y2_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC253LOG LOGICEXP(12,14) DPWR DGND
+ G1BAR_I G2BAR_I A_I B_I 1C0_I 1C1_I 1C2_I 1C3_I 2C0_I 2C1_I 2C2_I 2C3_I
+ G1BAR G2BAR A B 1C0 1C1 1C2  1C3 2C0 2C1 2C2 2C3 Y1 Y2
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   G1BAR = { G1BAR_I }
+   G2BAR = { G2BAR_I }
+   A = { A_I }
+   B = { B_I }
+   1C0 = { 1C0_I }
+   1C1 = { 1C1_I }
+   1C2 = { 1C2_I }
+   1C3 = { 1C3_I }
+   2C0 = { 2C0_I }
+   2C1 = { 2C1_I }
+   2C2 = { 2C2_I }
+   2C3 = { 2C3_I }
+   G1 = { ~G1BAR }
+   G2 = { ~G2BAR }
+   ABAR = { ~A }
+   BBAR = { ~B }
+   I0 = { G1 & BBAR & ABAR & 1C0 }
+   I1 = { G1 & BBAR & A    & 1C1 }
+   I2 = { G1 & B    & ABAR & 1C2 }
+   I3 = { G1 & B    & A    & 1C3 }
+   I4 = { G2 & BBAR & ABAR & 2C0 }
+   I5 = { G2 & BBAR & A    & 2C1 }
+   I6 = { G2 & B    & ABAR & 2C2 }
+   I7 = { G2 & B    & A    & 2C3 }
+   Y1 = { I0 | I1 | I2 | I3 }
+   Y2 = { I4 | I5 | I6 | I7 }
*
UHC253DLY PINDLY (2,2,10) DPWR DGND
+ Y1 Y2
+ G1BAR G2BAR
+ A B 1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3
+ Y1_O Y2_O
+ IO_HC_BUS
+ MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+ BOOLEAN:
+   DATA1 = { (CHANGED(1C0,0) | CHANGED(1C1,0) | CHANGED(1C2,0) |
+     CHANGED(1C3,0)) }
+   DATA2 = { (CHANGED(2C0,0) | CHANGED(2C1,0) | CHANGED(2C2,0) |
+     CHANGED(2C3,0)) }
+   SELECT = { CHANGED(A,0) | CHANGED(B,0) }
+ TRISTATE:
+   ENABLE LO  G1BAR
+   Y1_O = {
+     CASE(
+       TRN_Z$, DELAY(-1,11NS,25NS),
+       TRN_$Z, DELAY(-1,14NS,38NS),
+       SELECT, DELAY(-1,19NS,38NS),
+       DATA1, DELAY(-1,16NS,35NS),
+       DELAY(-1,20NS,36NS)
+       )
+     }
+ TRISTATE:
+   ENABLE LO  G2BAR
+   Y2_O = {
+     CASE(
+       TRN_Z$, DELAY(-1,11NS,25NS),
+       TRN_$Z, DELAY(-1,14NS,38NS),
+       SELECT, DELAY(-1,19NS,38NS),
+       DATA2, DELAY(-1,16NS,35NS),
+       DELAY(-1,20NS,36NS)
+       )
+     }
*
.ENDS
*
*$
*---------
* 74HC257  QUADRUPLE 2-LINE TO 1-LINE DATA SELECTORS/MULTIPLEXERS
*          WITH 3-STATE OUTPUTS
*
* High Speed CMOS Logic Data Book, 1989, TI
* JSW   8/25/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
* rbh   11/11/92  Added bus I/O model
*
.SUBCKT 74HC257 GBAR_I 1A_I 1B_I 2A_I 2B_I 3A_I 3B_I 4A_I 4B_I SEL_I
+ Y1_O Y2_O Y3_O Y4_O 
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC257LOG LOGICEXP(10,14) DPWR DGND
+ GBAR_I 1A_I 1B_I 2A_I 2B_I 3A_I 3B_I 4A_I 4B_I SEL_I
+ GBAR 1A 1B 2A 2B 3A 3B 4A 4B SEL Y1 Y2 Y3 Y4 
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   GBAR = { GBAR_I }
+   1A = { 1A_I }
+   1B = { 1B_I }
+   2A = { 2A_I }
+   2B = { 2B_I }
+   3A = { 3A_I }
+   3B = { 3B_I }
+   4A = { 4A_I }
+   4B = { 4B_I }
+   SEL = { SEL_I }
+   SELBAR = { ~SEL }
+   Y1 = { (1A & SELBAR) | (1B & SEL) }
+   Y2 = { (2A & SELBAR) | (2B & SEL) }
+   Y3 = { (3A & SELBAR) | (3B & SEL) }
+   Y4 = { (4A & SELBAR) | (4B & SEL) }
*
UHC257DLY PINDLY (4,1,9) DPWR DGND
+ Y1 Y2 Y3 Y4
+ GBAR
+ 1A 1B 2A 2B 3A 3B 4A 4B SEL
+ Y1_O Y2_O Y3_O Y4_O
+ IO_HC_BUS
+ MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+ BOOLEAN:
+   DATA = { CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(2A,0) | CHANGED(2B,0) | 
+     CHANGED(3A,0) | CHANGED(3B,0) | CHANGED(4A,0) | CHANGED(4B,0) }
+   SELECT = { CHANGED(SEL,0) }
+   ENABLE = { CHANGED(GBAR,0) }
+ TRISTATE:
+   ENABLE LO = GBAR
+   Y1_O Y2_O Y3_O Y4_O = {
+     CASE(
+       ENABLE, DELAY(-1,15NS,38NS),
+       SELECT, DELAY(-1,10NS,25NS),
+       DATA, DELAY(-1,10NS,25NS),
+       DELAY(-1,16NS,39NS)
+       )
+     }
*
.ENDS
*
*$
*---------
* 74HC258  QUADRUPLE 2-LINE TO 1-LINE DATA SELECTORS/MULTIPLEXERS
*          WITH 3-STATE OUTPUTS
*
* High Speed CMOS Logic Data Book, 1989, TI
* JSW   8/25/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
*
.SUBCKT 74HC258 GBAR_I 1A_I 1B_I 2A_I 2B_I 3A_I 3B_I 4A_I 4B_I SEL_I
+ Y1_O Y2_O Y3_O Y4_O 
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC258LOG LOGICEXP(10,14) DPWR DGND
+ GBAR_I 1A_I 1B_I 2A_I 2B_I 3A_I 3B_I 4A_I 4B_I SEL_I
+ GBAR 1A 1B 2A 2B 3A 3B 4A 4B SEL Y1 Y2 Y3 Y4 
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   GBAR = { GBAR_I }
+   1A = { 1A_I }
+   1B = { 1B_I }
+   2A = { 2A_I }
+   2B = { 2B_I }
+   3A = { 3A_I }
+   3B = { 3B_I }
+   4A = { 4A_I }
+   4B = { 4B_I }
+   SEL = { SEL_I }
+   SELBAR = { ~SEL }
+   Y1 = { ~((1A & SELBAR) | (1B & SEL)) }
+   Y2 = { ~((2A & SELBAR) | (2B & SEL)) }
+   Y3 = { ~((3A & SELBAR) | (3B & SEL)) }
+   Y4 = { ~((4A & SELBAR) | (4B & SEL)) }
*
UHC258DLY PINDLY (4,1,9) DPWR DGND
+ Y1 Y2 Y3 Y4
+ GBAR
+ 1A 1B 2A 2B 3A 3B 4A 4B SEL
+ Y1_O Y2_O Y3_O Y4_O
+ IO_HC 
+ MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+ BOOLEAN:
+   DATA = { CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(2A,0) | CHANGED(2B,0) | 
+     CHANGED(3A,0) | CHANGED(3B,0) | CHANGED(4A,0) | CHANGED(4B,0) }
+   SELECT = { CHANGED(SEL,0) }
+   ENABLE = { CHANGED(GBAR,0) }
+ TRISTATE:
+   ENABLE LO = GBAR
+   Y1_O Y2_O Y3_O Y4_O = {
+     CASE(
+       ENABLE, DELAY(-1,15NS,38NS),
+       SELECT, DELAY(-1,13NS,29NS),
+       DATA, DELAY(-1,13NS,25NS),
+       DELAY(-1,16NS,39NS)
+       )
+     }
*
.ENDS
*
*$
*----------
* 74HC259  8-BIT ADDRESSABLE LATCHES
*
* The High-speed CMOS Logic Data Book, 1988, TI
* tvh	09/11/89	Update interface and model names
*
.subckt 74HC259  CLRBAR GBAR D S0 S1 S2 Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 bufa(3) DPWR DGND
+	CLRBAR GBAR D   RB GB DATA 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U2 bufa(3) DPWR DGND
+	S0 S1 S2   SA SB SC 
+	D_HC259_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U3 inva(3) DPWR DGND
+	SA SB SC   AB BB CB 
+	D0_GATE IO_HC 
U4 nanda(3,8) DPWR DGND
+	AB	BB	CB
+	SA	BB	CB
+	AB	SB	CB
+	SA	SB	CB
+	AB	BB	SC
+	SA	BB	SC
+	AB	SB	SC
+	SA	SB	SC
+	T0	T1	T2	T3	T4	T5	T6	T7
+	D0_GATE IO_HC 
U5 nora(2,8) DPWR DGND
+	GB	T0
+	GB	T1
+	GB	T2
+	GB	T3
+	GB	T4
+	GB	T5
+	GB	T6
+	GB	T7
+	G0	G1	G2	G3	G4	G5	G6	G7
+	D0_GATE IO_HC 
U6 ora(2,8) DPWR DGND
+	G0	RB
+	G1	RB
+	G2	RB
+	G3	RB
+	G4	RB
+	G5	RB
+	G6	RB
+	G7	RB
+	R0	R1	R2	R3	R4	R5	R6	R7
+	D0_GATE IO_HC 
U7 dltch(1) DPWR DGND
+	$D_HI R0 G0   DATA   Q0 $D_NC 
+	D_HC259_2 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U8 dltch(1) DPWR DGND
+	$D_HI R1 G1   DATA   Q1 $D_NC 
+	D_HC259_2 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U9 dltch(1) DPWR DGND
+	$D_HI R2 G2   DATA   Q2 $D_NC 
+	D_HC259_2 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U10 dltch(1) DPWR DGND
+	$D_HI R3 G3   DATA   Q3 $D_NC 
+	D_HC259_2 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U11 dltch(1) DPWR DGND
+	$D_HI R4 G4   DATA   Q4 $D_NC 
+	D_HC259_2 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U12 dltch(1) DPWR DGND
+	$D_HI R5 G5   DATA   Q5 $D_NC 
+	D_HC259_2 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U13 dltch(1) DPWR DGND
+	$D_HI R6 G6   DATA   Q6 $D_NC 
+	D_HC259_2 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U14 dltch(1) DPWR DGND
+	$D_HI R7 G7   DATA   Q7 $D_NC 
+	D_HC259_2 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC259_1 ugate (
+	TPLHTY=1NS	TPLHMX=7NS
+	TPHLTY=1NS	TPHLMX=7NS
+	)
.model D_HC259_2 ugff (
+	TWGHMN=20NS	TWPCLMN=20NS
+	TSUDGMN=19NS	THDGMN=5NS
+	TPPCQHLTY=18NS	TPPCQHLMX=38NS
+	TPDQLHTY=17NS	TPDQLHMX=33NS
+	TPDQHLTY=17NS	TPDQHLMX=33NS
+	TPGQLHTY=20NS	TPGQLHMX=43NS
+	TPGQHLTY=20NS	TPGQHLMX=43NS
+	)
*$
*--------------------------------------------------------------------------
* 74HC266  QUADRUPLE 2-INPUT EXCLUSIVE-NOR GATES WITH OPEN-COLLECTOR OUTPUTS.
*
* The High-speed CMOS Logic Data Book, 1988, TI
* tvh	07/05/89	Update interface and model names
*
.subckt 74HC266  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nxor DPWR DGND
+	A B   Y 
+	D_HC266 IO_HC_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC266 ugate (
+	TPLHTY=13NS	TPLHMX=31NS
+	TPHLTY=13NS	TPHLMX=25NS
+	)
*$
*----------
* 74HC273  OCTAL D-TYPE EDGE-TRIGGERED FLIP-FLOPS WITH CLEAR
*
* The High-speed CMOS Logic Data Book, 1988, TI
* tvh	07/05/89	Update interface and model names
*
.subckt 74HC273  CLRBAR CLK D1 D2 D3 D4 D5 D6 D7 D8 Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UD dff(8) DPWR DGND
+	$D_HI	CLRBAR	CLK
+	D1	D2	D3	D4	D5	D6	D7	D8
+	Q1	Q2	Q3	Q4	Q5	Q6	Q7	Q8
+	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC
+	D_HC273 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC273 ueff (
+	TWCLKLMN=20NS	TWCLKHMN=20NS
+	TWPCLMN=20NS	TSUDCLKMN=25NS
+	TSUPCCLKHMN=25NS	TPPCQHLTY=15NS
+	TPPCQHLMX=40NS	TPCLKQLHTY=15NS
+	TPCLKQLHMX=40NS	TPCLKQHLTY=15NS
+	TPCLKQHLMX=40NS
+	)
*$
*---------
* 74HC279  QUADRUPLE SBAR-RBAR LATCHES
*
* Motorola Semiconductor, 1989
* cv	09/10/90  	Created from HC
*
.subckt 74HC279  1RBAR 1S1BAR 1S2BAR 2RBAR 2SBAR 1Q 2Q
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 bufa(2) DPWR DGND
+	1RBAR 2RBAR   1RB 2RB 
+	D_HC279_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 nanda(3,2) DPWR DGND
+	1RB Q1 $D_HI 1S1BAR 1S2BAR Q1B   Q1B Q1 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U3 nanda(2,2) DPWR DGND
+	2RB Q2 2SBAR Q2B   Q2B Q2 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U4 wdthck(5) DPWR DGND
+	1RBAR	1S1BAR	1S2BAR	2RBAR	2SBAR
+	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC
+	1RLO	1S1LO	1S2LO	2RLO	2SLO
+	D_HC279_2 IO_HC MNTYMXDLY={MNTYMXDLY} 
U5 ora(3,2) DPWR DGND
+	1RLO 1S1LO 1S2LO 2RLO 2SLO $D_LO   X1 X2 
+	D0_GATE IO_HC 
U6 inva(2) DPWR DGND
+	X1 X2   T1 T2 
+	D0_GATE IO_HC 
U7 buf3 DPWR DGND
+	$D_X   X1   1Q 
+	D_HC279_3 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U8 buf3 DPWR DGND
+	$D_X   X2   2Q 
+	D_HC279_3 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U9 buf3 DPWR DGND
+	Q1   T1   1Q 
+	D_HC279_3 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U10 buf3 DPWR DGND
+	Q2   T2   2Q 
+	D_HC279_3 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC279_1 ugate (
+	TPHLTY=2NS	TPHLMX=3NS
+	)
.model D_HC279_2 uwdth (
+	TWLMN=20NS
+	)
.model D_HC279_3 utgate (
+	TPLHTY=10NS	TPHLTY=10NS
+	TPLHMX=17NS	TPHLMX=17NS
+	TPZHTY=10NS	TPZLTY=10NS
+	TPZHMX=17NS	TPZLMX=17NS
+	TPLZTY=10NS	TPHZTY=10NS
+	TPLZMX=17NS	TPHZMX=17NS
+	)
*$
*---------
* 74HC280  PARITY GENERATOR/CHECKER ODD/EVEN 9-BIT
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   8-25-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74HC280   A_I B_I C_I D_I E_I F_I G_I H_I I_I
+ EOUT_O OOUT_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC280LOG LOGICEXP (9,2) DPWR DGND
+ A_I B_I C_I D_I E_I F_I G_I H_I I_I
+ EOUT OOUT
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   A    = { A_I }
+   B    = { B_I }
+   C    = { C_I }
+   D    = { D_I }
+   E    = { E_I }
+   F    = { F_I }
+   G    = { G_I }
+   H    = { H_I }
+   I    = { I_I }
+
+   ABC  = { (A & ~B & ~C) | (~A & B & ~C) | (~A & ~B & C) | (A & B & C) }
+   DEF  = { (D & ~E & ~F) | (~D & E & ~F) | (~D & ~E & F) | (D & E & F) }
+   GHI  = { (G & ~H & ~I) | (~G & H & ~I) | (~G & ~H & I) | (G & H & I) }
+   EOUT = { (~ABC &  DEF &  GHI) | (ABC & ~DEF & GHI) | (ABC & DEF & ~GHI) |
+            (~ABC & ~DEF & ~GHI) }
+   OOUT = { ~EOUT }
*
UHC280DLY PINDLY (2,0,0) DPWR DGND
+ EOUT OOUT
+
+ EOUT_O OOUT_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   EOUT_O OOUT_O = { DELAY(-1,21NS,52NS) }
*
.ENDS
*
*$
*---------
* 74HC283 4-BIT BINARY FULL ADDERS WITH FAST CARRY
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, 1989, TI
* NH 8/26/92         REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74HC283 C0_I A1_I A2_I A3_I A4_I B1_I B2_I B3_I B4_I C4_O
+             SUM1_O SUM2_O SUM3_O SUM4_O
+ OPTIONAL: DPWR = $G_DPWR DGND = $G_DGND
+ PARAMS:   MNTYMXDLY = 0  IO_LEVEL = 0
*
UHC283LOG LOGICEXP(9,14) DPWR DGND
+ C0_I A1_I A2_I A3_I A4_I B1_I B2_I B3_I B4_I
+ C0 A1 A2 A3 A4 B1 B2 B3 B4 C4 SUM1 SUM2 SUM3 SUM4
+ D0_GATE IO_HC IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
+   C0 = { C0_I }
+   A1 = { A1_I }
+   A2 = { A2_I }
+   A3 = { A3_I }
+   A4 = { A4_I }
+   B1 = { B1_I }
+   B2 = { B2_I }
+   B3 = { B3_I }
+   B4 = { B4_I }
+
+   NAND4 = { ~(A4 & B4) }
+   NAND3 = { ~(A3 & B3) }
+   NAND2 = { ~(A2 & B2) }
+   NAND1 = { ~(A1 & B1) }
+   NOR4 = { ~(A4 | B4) }
+   NOR3 = { ~(A3 | B3) }
+   NOR2 = { ~(A2 | B2) }
+   NOR1 = { ~(A1 | B1) }
+   C0BAR = { ~C0 }
+
+   SUM1 = { (NAND1 & ~NOR1) ^ C0 }
+   SUM2 = { (NAND2 & ~NOR2) ^ (~(NOR1 | (NAND1 & C0BAR))) }
+   SUM3 = { (NAND3 & ~NOR3) ^ (~(NOR2 | (NOR1 & NAND2) |
+            (NAND2 & NAND1 & C0BAR))) }
+   SUM4 = { (NAND4 & ~NOR4) ^ (~(NOR3 | (NOR2 & NAND3) |
+            (NOR1 & NAND3 & NAND2) | (NAND3 & NAND2 & NAND1 & C0BAR))) }
+   C4 = { ~( NOR4 | (NOR3 & NAND4) | (NOR2 & NAND4 & NAND3) |
+             (NOR1 & NAND4 & NAND3 & NAND2) |
+             (NAND4 & NAND3 & NAND2 & NAND1 & C0BAR) ) }
*
UHC283DLY PINDLY (5,0,9) DPWR DGND
+ SUM1 SUM2 SUM3 SUM4 C4
+ C0 A1 A2 A3 A4 B1 B2 B3 B4
+ SUM1_O SUM2_O SUM3_O SUM4_O C4_O
+ IO_HC MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+
+ BOOLEAN:
+   ANY_CH_AB = { CHANGED(A1,0) | CHANGED(B1,0) | CHANGED(A2,0) |
+                 CHANGED(B2,0) | CHANGED(A3,0) | CHANGED(B3,0) |
+                 CHANGED(A4,0) | CHANGED(B4,0) }
+
+ PINDLY:
+   SUM1_O SUM2_O SUM3_O SUM4_O = {
+     CASE(
+       ANY_CH_AB, DELAY(-1,25NS,44NS),
+       CHANGED(C0,0), DELAY(-1,20NS,37NS),
+       DELAY(-1,26NS,45NS)                       ;DEFAULT
+       )
+     }
+   C4_O = {
+     CASE(
+       ANY_CH_AB, DELAY(-1,26NS,44NS),
+       CHANGED(C0,0), DELAY(-1,25NS,44NS),
+       DELAY(-1,27NS,45NS)                     ;DEFAULT
+       )
+     }
*
.ENDS
*
*$
*---------
* 74HC298  MULTIPLEXERS QUAD 2-INPUT WITH STORAGE
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, 1989, TI
* TC  08/25/92  REMODELED USING LOGICEXP, PINDLY, & CONSTRAINT DEVICES
*
* NOTE: THE LOGIC FROM 74298 IS USED TO MODEL TO THIS DEVICE.
*
.SUBCKT 74HC298 WS_I CLK_I A1_I A2_I B1_I B2_I C1_I C2_I D1_I D2_I
+ QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(4) DPWR DGND $D_HI $D_HI CLK
+ JA JB JC JD KA KB KC KD QA QB QC QD $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_HC
*
UHC298LOG LOGICEXP(10,18) DPWR DGND
+ WS_I CLK_I A1_I A2_I B1_I B2_I C1_I C2_I D1_I D2_I
+ WS CLK A1 A2 B1 B2 C1 C2 D1 D2 JA JB JC JD KA KB KC KD
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   WS = { WS_I }
+   CLK = { CLK_I }
+   A1 = { A1_I }
+   A2 = { A2_I }
+   B1 = { B1_I }
+   B2 = { B2_I }
+   C1 = { C1_I }
+   C2 = { C2_I }
+   D1 = { D1_I }
+   D2 = { D2_I }
+   IWS = { ~WS }
+   KA = { ~((A1 & IWS) | (WS & A2)) }
+   KB = { ~((B1 & IWS) | (WS & B2)) }
+   KC = { ~((C1 & IWS) | (WS & C2)) }
+   KD = { ~((D1 & IWS) | (WS & D2)) }
+   JA = { ~KA }
+   JB = { ~KB }
+   JC = { ~KC }
+   JD = { ~KD }
*
UHC298DLY PINDLY (4,0,10) DPWR DGND
+ QA QB QC QD
+ A1 A2 B1 B2 C1 C2 D1 D2 WS CLK
+ QA_O QB_O QC_O QD_O
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+   QA_O QB_O QC_O QD_O = { DELAY(-1,15NS,31NS) }
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 27MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 19NS
+   MIN_HI = 19NS
+ SETUP_HOLD:
+   DATA(4) = A1 B1 C1 D1
+   CLOCK HL = CLK
+   SETUPTIME = 21NS
+   WHEN = { WS!='1 ^ CHANGED(WS,0) }
+ SETUP_HOLD:
+   DATA(4) = A2 B2 C2 D2
+   CLOCK HL = CLK
+   SETUPTIME = 21NS
+   WHEN = { WS!='0 ^ CHANGED(WS,0) }
+ SETUP_HOLD:
+   DATA(1) = WS
+   CLOCK HL = CLK
+   SETUPTIME = 21NS
*
.ENDS
*
*$
*---------
* 74HC299  8-BIT UNIVERSAL SHIFT/STORAGE REGISTERS
* WITH DIRECT CLEAR AND 3-STATE OUTPUTS
*
* THE HIGH-SPEED CMOS LOGIC DATABOOK, 89, TI
* KN   7-23-92      REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
* rbh   11/11/92	Added bus I/O model
*
.SUBCKT 74HC299  CLK_I CLRBAR_I S1_I S0_I G1BAR_I G2BAR_I SL_I SR_I
+ A/QA_B B/QB_B C/QC_B D/QD_B E/QE_B F/QF_B G/QG_B H/QH_B QAP_O QHP_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC299LOG LOGICEXP(32,25) DPWR DGND
+ CLK_I CLRBAR_I S1_I S0_I G1BAR_I G2BAR_I SL_I SR_I
+ A/QA_B B/QB_B C/QC_B D/QD_B E/QE_B F/QF_B G/QG_B H/QH_B ; BUFFERING
+ LA/QA LB/QB LC/QC LD/QD LE/QE LF/QF LG/QG LH/QH
+ A/QA B/QB C/QC D/QD E/QE F/QF G/QG H/QH  ;
+
+ CLK CLRBAR S1 S0 G1BAR G2BAR SL SR
+ A/QA B/QB C/QC D/QD E/QE F/QF G/QG H/QH
+ D1A D1B D1C D1D D1E D1F D1G D1H OE
+ D0_GATE  IO_HC
+ IO_LEVEL={IO_LEVEL}
+ LOGIC:
*   BUFFERING:
+
+   CLK      = { CLK_I }
+   CLRBAR   = { CLRBAR_I }
+   S1       = { S1_I }
+   S0       = { S0_I }
+   G1BAR    = { G1BAR_I }
+   G2BAR    = { G2BAR_I }
+   SL       = { SL_I }
+   SR       = { SR_I }
+   A/QA     = { A/QA_B }
+   B/QB     = { B/QB_B }
+   C/QC     = { C/QC_B }
+   D/QD     = { D/QD_B }
+   E/QE     = { E/QE_B }
+   F/QF     = { F/QF_B }
+   G/QG     = { G/QG_B }
+   H/QH     = { H/QH_B }
+
*   INTERMEDIATE TERMS:
+   S0S1   = { S0  & S1 }
+   S0/S1  = { S0  & ~S1 }
+   /S0S1  = { ~S0 & S1 }
+   /S0/S1 = { ~S0 & ~S1 }
+
* OUTPUTS:
+   D1A = { (S0/S1 & SR )   | (/S0S1 & LB/QB)  |
+           (S0S1 & A/QA)   | (/S0/S1 & LA/QA) }
+   D1B = { (S0/S1 & LA/QA) | (/S0S1 & LC/QC)  |
+           (S0S1 & B/QB)   | (/S0/S1 & LB/QB) }
+   D1C = { (S0/S1 & LB/QB) | (/S0S1 & LD/QD)  |
+           (S0S1 & C/QC)   | (/S0/S1 & LC/QC) }
+   D1D = { (S0/S1 & LC/QC) | (/S0S1 & LE/QE)  |
+           (S0S1 & D/QD)   | (/S0/S1 & LD/QD) }
+   D1E = { (S0/S1 & LD/QD) | (/S0S1 & LF/QF)  |
+           (S0S1 & E/QE)   | (/S0/S1 & LE/QE) }
+   D1F = { (S0/S1 & LE/QE) | (/S0S1 & LG/QG)  |
+           (S0S1 & F/QF)   | (/S0/S1 & LF/QF) }
+   D1G = { (S0/S1 & LF/QF) | (/S0S1 & LH/QH)  |
+           (S0S1 & G/QG)   | (/S0/S1 & LG/QG) }
+   D1H = { (S0/S1 & LG/QG) | (/S0S1 & SL )    |
+           (S0S1 & H/QH)   | (/S0/S1 & LH/QH) }
+   OE  = { G1BAR | G2BAR | (S1 & S0) }
*
U1 DFF(8) DPWR DGND $D_HI CLRBAR CLK
+ D1A       D1B       D1C        D1D       D1E        D1F       D1G      D1H
+ LA/QA    LB/QB      LC/QC      LD/QD     LE/QE      LF/QF     LG/QG    LH/QH
+ $D_NC    $D_NC      $D_NC      $D_NC     $D_NC      $D_NC     $D_NC    $D_NC
+ D0_EFF  IO_HC
*
UHC299DLY PINDLY (10,1,17) DPWR DGND
+ LA/QA LB/QB LC/QC LD/QD LE/QE LF/QF LG/QG LH/QH LA/QA LH/QH
+ OE
+ G1BAR G2BAR CLK CLRBAR S1 S0 S0 A/QA B/QB C/QC D/QD E/QE F/QF G/QG H/QH SR SL
+ A/QA_B B/QB_B C/QC_B D/QD_B E/QE_B F/QF_B G/QG_B H/QH_B   QAP_O QHP_O
+ IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ENABLE1  = { G1BAR != '1 & G2BAR != '1 }
+   ENABLE2  = { S1 != '1    | S0 != '1 }
+   DISABLE1 = { G1BAR != '0 | G2BAR != '0 }
+   DISABLE2 = { S1 != '0    & S0 != '0 }
+
+ PINDLY:
+   QAP_O QHP_O = {
+     CASE(
+       CHANGED_LH(CLK,0),             DELAY(-1,16NS,48NS),
+       CHANGED_HL(CLRBAR,0) & TRN_HL, DELAY(-1,17NS,53NS),
+                                      DELAY(-1,18NS,54NS) ;DEFAULT
+       )
+      }
+
+ TRISTATE:
+   ENABLE LO OE
+   A/QA_B B/QB_B C/QC_B D/QD_B E/QE_B F/QF_B G/QG_B H/QH_B = {
+     CASE(
+       ENABLE1 & TRN_Z$, DELAY(-1,24NS,40NS),
+       ENABLE2 & TRN_Z$, DELAY(-1,44NS,75NS),
+       DISABLE1  & TRN_$Z, DELAY(-1,24NS,40NS),
+       DISABLE2  & TRN_$Z, DELAY(-1,44NS,75NS),
+       CHANGED_LH(CLK,0),             DELAY(-1,16NS,48NS),
+       CHANGED_HL(CLRBAR,0) & TRN_HL, DELAY(-1,17NS,53NS),
+                                      DELAY(-1,18NS,54NS)  ;DEFAULT
+       )
+      }
+
+ FREQ:
+   NODE    = CLK
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE   = CLK
+   MIN_HI = 20NS
+   MIN_LO = 20NS
+
+ WIDTH:
+   NODE   = CLRBAR
+   MIN_LO = 20NS
+
+ SETUP_HOLD:
+   DATA(2)   = S1 S0
+   CLOCK LH  = CLK
+   SETUPTIME = 44NS
+   WHEN = { CLRBAR!='0 }
+
+ SETUP_HOLD:
+   DATA(8)   = A/QA B/QB C/QC D/QD E/QE F/QF G/QG H/QH
+   CLOCK LH  = CLK
+   SETUPTIME = 16NS
+   WHEN = { CLRBAR!='0
+           & (S1!='0 ^ CHANGED(S1,0))
+           & (S0!='0 ^ CHANGED(S0,0)) }
+
+ SETUP_HOLD:
+   DATA(1)   = SL
+   CLOCK LH  = CLK
+   SETUPTIME = 25NS
+   WHEN = { CLRBAR!='0
+           & (S1!='0 ^ CHANGED(S1,0))
+           & (S0!='1 ^ CHANGED(S0,0)) }
+
+ SETUP_HOLD:
+   DATA(1)   = SR
+   CLOCK LH  = CLK
+   SETUPTIME = 25NS
+   WHEN = { CLRBAR!='0
+           & (S1!='1 ^ CHANGED(S1,0))
+           & (S0!='0 ^ CHANGED(S0,0)) }
+
+ SETUP_HOLD:
+   DATA(1)        = CLRBAR
+   CLOCK LH       = CLK
+   RELEASETIME_LH = 16NS
*
.ENDS
*
*$
*---------
* 74HC352  DUAL 4-LINE TO 1-LINE DATA SELECTORS/MULTIPLEXERS
*
* High Speed CMOS Logic Data Book, 1989, TI
* JSW   8/24/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices
* NOTICE:  Logic diagram from 74352 was used.
*
.SUBCKT 74HC352 G1BAR_I G2BAR_I A_I B_I 1C0_I 1C1_I 1C2_I  1C3_I
+ 2C0_I 2C1_I 2C2_I 2C3_I Y1_O Y2_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC352LOG LOGICEXP(12,14) DPWR DGND
+ G1BAR_I G2BAR_I A_I B_I 1C0_I 1C1_I 1C2_I 1C3_I 2C0_I 2C1_I 2C2_I 2C3_I
+ G1BAR G2BAR A B 1C0 1C1 1C2  1C3 2C0 2C1 2C2 2C3 Y1 Y2
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   G1BAR = { G1BAR_I }
+   G2BAR = { G2BAR_I }
+   A = { A_I }
+   B = { B_I }
+   1C0 = { 1C0_I }
+   1C1 = { 1C1_I }
+   1C2 = { 1C2_I }
+   1C3 = { 1C3_I }
+   2C0 = { 2C0_I }
+   2C1 = { 2C1_I }
+   2C2 = { 2C2_I }
+   2C3 = { 2C3_I }
+   G1 = { ~G1BAR }
+   G2 = { ~G2BAR }
+   ABAR = { ~A }
+   BBAR = { ~B }
+   I0 = { G1 & BBAR & ABAR & 1C0 }
+   I1 = { G1 & BBAR & A    & 1C1 }
+   I2 = { G1 & B    & ABAR & 1C2 }
+   I3 = { G1 & B    & A    & 1C3 }
+   I4 = { G2 & BBAR & ABAR & 2C0 }
+   I5 = { G2 & BBAR & A    & 2C1 }
+   I6 = { G2 & B    & ABAR & 2C2 }
+   I7 = { G2 & B    & A    & 2C3 }
+   Y1 = { ~(I0 | I1 | I2 | I3) }
+   Y2 = { ~(I4 | I5 | I6 | I7) }
*
UHC352DLY PINDLY (2,0,12) DPWR DGND
+ Y1 Y2
+ G1BAR G2BAR A B 1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3
+ Y1_O Y2_O
+ IO_HC
+ MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+ BOOLEAN:
+   DATA1 = { (CHANGED(1C0,0) | CHANGED(1C1,0) | CHANGED(1C2,0) |
+     CHANGED(1C3,0)) }
+   DATA2 = { (CHANGED(2C0,0) | CHANGED(2C1,0) | CHANGED(2C2,0) |
+     CHANGED(2C3,0)) }
+   SELECT = { CHANGED(A,0) | CHANGED(B,0) }
+ PINDLY:
+   Y1_O = {
+     CASE(
+       SELECT, DELAY(-1,17NS,46NS),
+       DATA1, DELAY(-1,14NS,44NS),
+       CHANGED(G1BAR,0), DELAY(-1,10NS,34NS),
+       DELAY(-1,18NS,47NS)
+       )
+     }
+   Y2_O = {
+     CASE(
+       SELECT, DELAY(-1,17NS,46NS),
+       DATA2, DELAY(-1,14NS,44NS),
+       CHANGED(G2BAR,0), DELAY(-1,10NS,34NS),
+       DELAY(-1,18NS,47NS)
+       )
+     }
*
.ENDS
*
*$
*---------
* 74HC353  DUAL 1-OF-4 DATA SELECTORS/MULTIPLEXERS WITH 3-STATE OUTPUTS
*
* High Speed CMOS Logic Data Book, 1989, TI
* JSW   8/24/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices
* NOTICE:  Logic diagram from 74353 was used.
*
.SUBCKT 74HC353 G1BAR_I G2BAR_I A_I B_I 1C0_I 1C1_I 1C2_I  1C3_I
+ 2C0_I 2C1_I 2C2_I 2C3_I Y1_O Y2_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC353LOG LOGICEXP(12,14) DPWR DGND
+ G1BAR_I G2BAR_I A_I B_I 1C0_I 1C1_I 1C2_I 1C3_I 2C0_I 2C1_I 2C2_I 2C3_I
+ G1BAR G2BAR A B 1C0 1C1 1C2  1C3 2C0 2C1 2C2 2C3 Y1 Y2
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   G1BAR = { G1BAR_I }
+   G2BAR = { G2BAR_I }
+   A = { A_I }
+   B = { B_I }
+   1C0 = { 1C0_I }
+   1C1 = { 1C1_I }
+   1C2 = { 1C2_I }
+   1C3 = { 1C3_I }
+   2C0 = { 2C0_I }
+   2C1 = { 2C1_I }
+   2C2 = { 2C2_I }
+   2C3 = { 2C3_I }
+   G1 = { ~G1BAR }
+   G2 = { ~G2BAR }
+   ABAR = { ~A }
+   BBAR = { ~B }
+   I0 = { G1 & BBAR & ABAR & 1C0 }
+   I1 = { G1 & BBAR & A    & 1C1 }
+   I2 = { G1 & B    & ABAR & 1C2 }
+   I3 = { G1 & B    & A    & 1C3 }
+   I4 = { G2 & BBAR & ABAR & 2C0 }
+   I5 = { G2 & BBAR & A    & 2C1 }
+   I6 = { G2 & B    & ABAR & 2C2 }
+   I7 = { G2 & B    & A    & 2C3 }
+   Y1 = { ~(I0 | I1 | I2 | I3) }
+   Y2 = { ~(I4 | I5 | I6 | I7) }
*
UHC353DLY PINDLY (2,2,10) DPWR DGND
+ Y1 Y2
+ G1BAR G2BAR
+ A B 1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3
+ Y1_O Y2_O
+ IO_HC
+ MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+ BOOLEAN:
+   DATA1 = { (CHANGED(1C0,0) | CHANGED(1C1,0) | CHANGED(1C2,0) |
+     CHANGED(1C3,0)) }
+   DATA2 = { (CHANGED(2C0,0) | CHANGED(2C1,0) | CHANGED(2C2,0) |
+     CHANGED(2C3,0)) }
+   SELECT = { CHANGED(A,0) | CHANGED(B,0) }
+ TRISTATE:
+   ENABLE LO  G1BAR
+   Y1_O = {
+     CASE(
+       TRN_Z$, DELAY(-1,11NS,34NS),
+       TRN_$Z, DELAY(-1,13NS,34NS),
+       SELECT, DELAY(-1,17NS,46NS),
+       DATA1, DELAY(-1,14NS,44NS),
+       DELAY(-1,18NS,47NS) ; DEFAULT
+       )
+     }
+ TRISTATE:
+   ENABLE LO = G2BAR
+   Y2_O = {
+     CASE(
+       TRN_Z$, DELAY(-1,11NS,34NS),
+       TRN_$Z, DELAY(-1,13NS,34NS),
+       SELECT, DELAY(-1,17NS,46NS),
+       DATA2, DELAY(-1,14NS,44NS),
+       DELAY(-1,18NS,47NS) ; DEFAULT
+       )
+     }
*
.ENDS
*
*$
*--------------------------------------------------------------------------
* 74HC354 4-LINE TO 1-LINE LINE DATA SELECTORS/MULTIPLEXERS/REGISTERS
* WITH 3-STATE OUTPUTS
* THE HIGH-SPEED CMOS LOGIC DATA BOOK, 1988, TI
* KN   8-26-92      REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
* rbh   11/11/92	Added bus I/O model
*
.SUBCKT 74HC354 G1BAR_I G2BAR_I G3_I SCBAR_I S0_I S1_I S2_I DCBAR_I
+ D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I Y_O W_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC354LOG LOGICEXP(30,21) DPWR DGND
+ G1BAR_I G2BAR_I G3_I SCBAR_I S0_I S1_I S2_I DCBAR_I
+ D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I
+ QS2 QS2BAR QS1 QS1BAR QS0 QS0BAR Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ G1BAR G2BAR G3 SCBAR S0 S1 S2 DCBAR
+ D0 D1 D2 D3 D4 D5 D6 D7 Y W ENABLE13 DC SC
+ D0_GATE
+ IO_HC IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
*   BUFFER:
+   D0     = { D0_I }
+   D1     = { D1_I }
+   D2     = { D2_I }
+   D3     = { D3_I }
+   D4     = { D4_I }
+   D5     = { D5_I }
+   D6     = { D6_I }
+   D7     = { D7_I }
+   G1BAR  = { G1BAR_I }
+   G2BAR  = { G2BAR_I }
+   G3     = { G3_I }
+   SCBAR  = { SCBAR_I }
+   SC     = { ~SCBAR }
+   S0     = { S0_I }
+   S1     = { S1_I }
+   S2     = { S2_I }
+   DCBAR  = { DCBAR_I }
+   DC     = { ~DCBAR }
+
*   OUTPUT ASSIGNMENTS:
+   ENABLE13 = { ~G1BAR & ~G2BAR & G3 }
+   Y      = { (QS2BAR & QS1BAR & QS0BAR & Q0) |
+              (QS2BAR & QS1BAR & QS0    & Q1) |
+              (QS2BAR & QS1    & QS0BAR & Q2) |
+              (QS2BAR & QS1    & QS0    & Q3) |
+              (QS2    & QS1BAR & QS0BAR & Q4) |
+              (QS2    & QS1BAR & QS0    & Q5) |
+              (QS2    & QS1    & QS0BAR & Q6) |
+              (QS2    & QS1    & QS0    & Q7) }
+   W      = { ~Y }
*
U1 DLTCH(8) DPWR DGND $D_HI $D_HI DC
+ D0 D1 D2 D3 D4 D5 D6 D7
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ $D_NC $D_NC  $D_NC  $D_NC  $D_NC  $D_NC  $D_NC  $D_NC
+ D0_GFF IO_HC
*
U2 DLTCH(3) DPWR DGND $D_HI $D_HI SC
+ S0 S1 S2
+ QS0 QS1 QS2
+ QS0BAR QS1BAR QS2BAR
+ D0_GFF IO_HC
*
UHC354DLY PINDLY (2,1,16) DPWR DGND
+ Y W
+ ENABLE13
+ D0 D1 D2 D3 D4 D5 D6 D7 DCBAR S0 S1 S2 SCBAR G1BAR G2BAR G3
+ Y_O W_O
+ IO_HC_BUS  MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+  D_CHANGE  = { (CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0)
+              | CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0))
+                & DCBAR!='1 }
+  DCBAR_CHANGE = { CHANGED(DCBAR,0) }
+  SCBAR_CHANGE = { CHANGED(SCBAR,0) }
+  S_CHANGE   = { (CHANGED(S0,0) | CHANGED(S1,0) | CHANGED(S2,0)) & SCBAR!='1 }
+
+ TRISTATE:
+   ENABLE HI ENABLE13
+   Y_O  W_O = {
+     CASE(
+       SCBAR_CHANGE ,  DELAY(-1,45NS,75NS),
+       S_CHANGE ,      DELAY(-1,42NS,71NS),
+       DCBAR_CHANGE ,  DELAY(-1,40NS,68NS),
+       D_CHANGE ,      DELAY(-1,29NS,59NS),
+       TRN_$Z,         DELAY(-1,24NS,41NS),
+       TRN_Z$,         DELAY(-1,18NS,31NS),
+                       DELAY(-1,46NS,76NS)  ;DEFAULT
+     )
+   }
+
+ WIDTH:
+   NODE = DCBAR
+   MIN_LOW = 20NS
+
+ WIDTH:
+   NODE = SCBAR
+   MIN_LOW = 20NS
+
+ SETUP_HOLD:
+   DATA(8) = D0 D1 D2 D3 D4 D5 D6 D7
+   CLOCK LH = DCBAR
+   SETUPTIME = 19NS
+   HOLDTIME  = 5NS
+
+ SETUP_HOLD:
+   DATA(3) = S0 S1 S2
+   CLOCK LH = SCBAR
+   SETUPTIME = 19NS
+   HOLDTIME  = 5NS
*
.ENDS
*
*$
*--------------------------------------------------------------------------
* 74HC356 4-LINE TO 1-LINE DATA SELECTORS/MULTIPLEXERS/REGISTERS
*
* THE HIGH-SPEED CMOS LOGIC DATA BOOK, 1988, TI
* KN   8-26-92      REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
* rbh   11/11/92	Added bus I/O model
*
.SUBCKT 74HC356 G1BAR_I G2BAR_I G3_I SCBAR_I S0_I S1_I S2_I CLK_I
+ D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I Y_O W_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC356LOG LOGICEXP(30,20) DPWR DGND
+ G1BAR_I G2BAR_I G3_I SCBAR_I S0_I S1_I S2_I CLK_I
+  D0_I D1_I D2_I D3_I D4_I D5_I D6_I D7_I
+  QS2 QS2BAR QS1 QS1BAR QS0 QS0BAR Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ G1BAR G2BAR G3 SCBAR S0 S1 S2 CLK
+  D0 D1 D2 D3 D4 D5 D6 D7 Y W ENABLE13 SC
+ D0_GATE
+ IO_HC IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
*   BUFFER:
+   D0     = { D0_I }
+   D1     = { D1_I }
+   D2     = { D2_I }
+   D3     = { D3_I }
+   D4     = { D4_I }
+   D5     = { D5_I }
+   D6     = { D6_I }
+   D7     = { D7_I }
+   G1BAR  = { G1BAR_I }
+   G2BAR  = { G2BAR_I }
+   G3     = { G3_I }
+   SCBAR  = { SCBAR_I }
+   SC     = { ~SCBAR }
+   S0     = { S0_I }
+   S1     = { S1_I }
+   S2     = { S2_I }
+   CLK  = { CLK_I }
+
*   OUTPUT ASSIGNMENTS:
+   ENABLE13 = { ~G1BAR & ~G2BAR & G3 }
+   Y      = { (QS2BAR & QS1BAR & QS0BAR & Q0) |
+              (QS2BAR & QS1BAR & QS0    & Q1) |
+              (QS2BAR & QS1    & QS0BAR & Q2) |
+              (QS2BAR & QS1    & QS0    & Q3) |
+              (QS2    & QS1BAR & QS0BAR & Q4) |
+              (QS2    & QS1BAR & QS0    & Q5) |
+              (QS2    & QS1    & QS0BAR & Q6) |
+              (QS2    & QS1    & QS0    & Q7) }
+   W      = { ~Y }
*
U1 DFF(8) DPWR DGND $D_HI $D_HI CLK    ; EDGE TRIGGERED , LH
+ D0 D1 D2 D3 D4 D5 D6 D7
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_HC
*
U2 DLTCH(3) DPWR DGND $D_HI $D_HI SC   ; TRANSPARENT LATCHES
+ S0 S1 S2
+ QS0 QS1 QS2 QS0BAR QS1BAR QS2BAR
+ D0_GFF IO_HC
*
UHC356DLY PINDLY (2,1,16) DPWR DGND
+ Y W
+ ENABLE13
+ D0 D1 D2 D3 D4 D5 D6 D7 CLK S0 S1 S2 SCBAR G1BAR G2BAR G3
+ Y_O W_O
+ IO_HC_BUS  MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+  CLK_CHANGE = { CHANGED(CLK,0) }
+  SCBAR_CHANGE = { CHANGED(SCBAR,0) }
+  S_CHANGE   = { (CHANGED(S0,0) | CHANGED(S1,0) | CHANGED(S2,0)) & SCBAR!='1 }
+
+ TRISTATE:
+   ENABLE HI ENABLE13
+   Y_O  W_O = {
+     CASE(
+       TRN_Z$, DELAY(-1,18NS,31NS),
+       TRN_$Z, DELAY(-1,24NS,41NS),
+       SCBAR_CHANGE ,  DELAY(-1,45NS,75NS),
+       S_CHANGE,       DELAY(-1,42NS,71NS),
+       CLK_CHANGE ,    DELAY(-1,36NS,64NS),
+                       DELAY(-1,46NS,76NS)  ;DEFAULT
+     )
+   }
+
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 20NS
+   MIN_LO = 20NS
+
+ WIDTH:
+   NODE = SCBAR
+   MIN_LO = 20NS
+
+ SETUP_HOLD:
+   DATA(8) = D0 D1 D2 D3 D4 D5 D6 D7
+   CLOCK LH = CLK
+   SETUPTIME = 19NS
+   HOLDTIME  = 5NS
+
+ SETUP_HOLD:
+   DATA(3) = S0 S1 S2
+   CLOCK LH = SCBAR
+   SETUPTIME = 19NS
+   HOLDTIME  = 5NS
*
.ENDS
*
*$
*---------
* 74HC365  Hex Bus Drivers with 3-STATE Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	7/18/89		Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC365  A1 A2 A3 A4 A5 A6 G1BAR G2BAR Y1 Y2 Y3 Y4 Y5 Y6
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UA nor(2) DPWR DGND
+	G1BAR G2BAR   E 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U1 buf3a(6) DPWR DGND
+	A1	A2	A3	A4	A5	A6
+	E
+	Y1	Y2	Y3	Y4	Y5	Y6
+	D_HC365 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC365 utgate (
+	tplhty=12ns	tplhmx=24ns
+	tphlty=12ns	tphlmx=24ns
+	tpzhty=26ns	tpzhmx=48ns
+	tpzlty=26ns	tpzlmx=48ns
+	tphzty=21ns	tphzmx=48ns
+	tplzty=21ns	tplzmx=48ns
+	)
*$
*---------
* 74HC366  Hex Bus Drivers with 3-STATE Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	06/27/89	Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC366  A1 A2 A3 A4 A5 A6 G1BAR G2BAR Y1 Y2 Y3 Y4 Y5 Y6
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UA nor(2) DPWR DGND
+	G1BAR G2BAR   E 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U1 inv3a(6) DPWR DGND
+	A1	A2	A3	A4	A5	A6
+	E
+	Y1	Y2	Y3	Y4	Y5	Y6
+	D_HC366 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC366 utgate (
+	tplhty=12ns	tplhmx=24ns
+	tphlty=12ns	tphlmx=24ns
+	tpzhty=26ns	tpzhmx=48ns
+	tpzlty=26ns	tpzlmx=48ns
+	tphzty=21ns	tphzmx=48ns
+	tplzty=21ns	tplzmx=48ns
+	)
*$
*---------
* 74HC367  Hex Bus Drivers with 3-STATE Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	7/18/89		Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC367  1A1 1A2 1A3 1A4 2A1 2A2 G1BAR G2BAR 1Y1 1Y2 1Y3 1Y4 2Y1 2Y2
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UINV inva(2) DPWR DGND
+	G1BAR G2BAR   G1 G2 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U1 buf3a(4) DPWR DGND
+	1A1 1A2 1A3 1A4   G1   1Y1 1Y2 1Y3 1Y4 
+	D_HC367 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 buf3a(2) DPWR DGND
+	2A1 2A2   G2   2Y1 2Y2 
+	D_HC367 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC367 utgate (
+	tplhty=12ns	tplhmx=24ns
+	tphlty=12ns	tphlmx=24ns
+	tpzhty=26ns	tpzhmx=48ns
+	tpzlty=26ns	tpzlmx=48ns
+	tphzty=21ns	tphzmx=48ns
+	tplzty=21ns	tplzmx=48ns
+	)
*$
*---------
* 74HC368  Hex Bus Drivers with 3-STATE Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	7/18/89		Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC368  1A1 1A2 1A3 1A4 2A1 2A2 G1BAR G2BAR 1Y1 1Y2 1Y3 1Y4 2Y1 2Y2
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UINV inva(2) DPWR DGND
+	G1BAR G2BAR   G1 G2 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
UA inv DPWR DGND
+	G1BAR   G1 
+	D0_GATE IO_HC 
UB inv DPWR DGND
+	G2BAR   G2 
+	D0_GATE IO_HC 
U1 inv3a(4) DPWR DGND
+	1A1 1A2 1A3 1A4   G1   1Y1 1Y2 1Y3 1Y4 
+	D_HC368 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 inv3a(2) DPWR DGND
+	2A1 2A2   G2   2Y1 2Y2 
+	D_HC368 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC368 utgate (
+	tplhty=12ns	tplhmx=24ns
+	tphlty=12ns	tphlmx=24ns
+	tpzhty=26ns	tpzhmx=48ns
+	tpzlty=26ns	tpzlmx=48ns
+	tphzty=21ns	tphzmx=48ns
+	tplzty=21ns	tplzmx=48ns
+	)
*$
*---------
* 74HC373  Octal D-Type Transparent Latches with 3-STATE Outputs
*
* The TTL Data Book, Vol 2, 1985, TI
* atl 	9/26/89		Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC373  OCBAR C 1D 2D 3D 4D 5D 6D 7D 8D 1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UA inv DPWR DGND
+	OCBAR   OC 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U1 dltch(8) DPWR DGND
+	$D_HI	$D_HI	C
+	1D	2D	3D	4D	5D	6D	7D	8D
+	1QI	2QI	3QI	4QI	5QI	6QI	7QI	8QI
+	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC
+	D_HC373_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 buf3a(8) DPWR DGND
+	1QI	2QI	3QI	4QI	5QI	6QI	7QI	8QI
+	OC
+	1Q	2Q	3Q	4Q	5Q	6Q	7Q	8Q
+	D_HC373_2 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC373_1 ugff (
+	tpgqlhty=3ns	tpgqlhmx=1ps
+	tpgqhlty=3ns	tpgqhlmx=1ps
+	twghmn=20ns	tsudgmn=13ns
+	thdgmn=12ns
+	)
.model D_HC373_2 utgate (
+	tplhty=15ns	tplhmx=38ns
+	tphlty=15ns	tphlmx=38ns
+	tpzhty=17ns	tpzhmx=38ns
+	tpzlty=17ns	tpzlmx=38ns
+	tphzty=15ns	tphzmx=38ns
+	tplzty=15ns	tplzmx=38ns
+	)
*$
*---------
* 74HC374  Octal D-Type Edge-Triggered Flip-Flops with 3-STATE Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl     7/18/89    Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC374  OCBAR CLK D1 D2 D3 D4 D5 D6 D7 D8 Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UOC inv DPWR DGND
+	OCBAR   OC 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
UD dff(8) DPWR DGND
+	$D_HI	$D_HI	CLK
+	D1	D2	D3	D4	D5	D6	D7	D8
+	SQ1	SQ2	SQ3	SQ4	SQ5	SQ6	SQ7	SQ8
+	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC
+	D_HC374_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UQS buf3a(8) DPWR DGND
+	SQ1	SQ2	SQ3	SQ4	SQ5	SQ6	SQ7	SQ8
+	OC
+	Q1	Q2	Q3	Q4	Q5	Q6	Q7	Q8
+	D_HC374_2 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC374_1 ueff (
+	twclklmn=20ns	twclkhmn=20ns
+	tsudclkmn=25ns	thdclkmn=5ns
+	)
.model D_HC374_2 utgate (
+	tplhty=17ns	tplhmx=45ns
+	tphlty=17ns	tphlmx=45ns
+	tpzhty=16ns	tpzhmx=38ns
+	tpzlty=16ns	tpzlmx=38ns
+	tphzty=17ns	tphzmx=38ns
+	tplzty=17ns	tplzmx=38ns
+	)
*$
*-------------------------------------------------------------------------
* 74HC375  4-bit Bistable Latches
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	 9/26/89	Update interface and model names
*
*
.subckt 74HC375  1D 2D C 1Q 1QBAR 2Q 2QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
*	Note:  The 74HC375 are fuctionally are electrically identical to the
*	74HC75.
*
X1  1D 2D C 1Q 1QBAR 2Q 2QBAR  DPWR DGND  74HC75
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends
*
*$
*---------
* 74HC377  Octal D-TYPE Flip-Flops with Clock Enable
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	8/7/89		Update interface and model names
*
.subckt 74HC377  GBAR CLK 1D 2D 3D 4D 5D 6D 7D 8D 1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UBUF bufa(2) DPWR DGND
+	GBAR CLK   GBBUF CLKBUF 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
X1Q  GBBUF CLKBUF 1D 1Q  DPWR DGND  HC377DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
X2Q  GBBUF CLKBUF 2D 2Q  DPWR DGND  HC377DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
X3Q  GBBUF CLKBUF 3D 3Q  DPWR DGND  HC377DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
X4Q  GBBUF CLKBUF 4D 4Q  DPWR DGND  HC377DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
X5Q  GBBUF CLKBUF 5D 5Q  DPWR DGND  HC377DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
X6Q  GBBUF CLKBUF 6D 6Q  DPWR DGND  HC377DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
X7Q  GBBUF CLKBUF 7D 7Q  DPWR DGND  HC377DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
X8Q  GBBUF CLKBUF 8D 8Q  DPWR DGND  HC377DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends
*
.subckt HC377DAT  GB CLK D Q DPWR DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
USET inva(2) DPWR DGND
+	GB D   G2 DBAR 
+	D_HC377_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UNXOR nxor DPWR DGND
+	GB G2   EN 
+	D0_GATE IO_HC 
UIN buf3 DPWR DGND
+	$D_X   EN   IN 
+	D0_TGATE IO_HC 
UINV inva(2) DPWR DGND
+	GB DBAR   G DD 
+	D0_GATE IO_HC 
UAO ao(2,2) DPWR DGND
+	G DD GB QBUF   IN 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
UDFF dff(1) DPWR DGND
+	$D_HI $D_HI CLK   IN   QBUF $D_NC 
+	D_HC377_2 IO_HC MNTYMXDLY={MNTYMXDLY} 
UQOUT buf DPWR DGND
+	QBUF   Q 
+	D_HC377_3 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC377_1 ugate (
+	tplhmn=5ns	tphlmn=5ns
+	)
.model D_HC377_2 ueff (
+	twclklmn=25ns	twclkhmn=25ns
+	tsudclkmn=20ns	thdclkmn=5ns
+	)
.model D_HC377_3 ugate (
+	tplhty=15ns	tplhmx=40ns
+	tphlty=15ns	tphlmx=40ns
+	)
*$
*---------
* 74HC378  Octal D-TYPE Flip-Flops with Clock Enable
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	8/7/89		Update interface and model names
*
.subckt 74HC378  CLK GBAR 1D 2D 3D 4D 5D 6D 1Q 2Q 3Q 4Q 5Q 6Q
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UBUF bufa(2) DPWR DGND
+	GBAR CLK   GBBUF CLKBUF 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
X1Q  GBBUF CLKBUF 1D 1Q  DPWR DGND  HC378DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
X2Q  GBBUF CLKBUF 2D 2Q  DPWR DGND  HC378DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
X3Q  GBBUF CLKBUF 3D 3Q  DPWR DGND  HC378DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
X4Q  GBBUF CLKBUF 4D 4Q  DPWR DGND  HC378DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
X5Q  GBBUF CLKBUF 5D 5Q  DPWR DGND  HC378DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
X6Q  GBBUF CLKBUF 6D 6Q  DPWR DGND  HC378DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends
*
.subckt HC378DAT  GB CLK D Q DPWR DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
USET inva(2) DPWR DGND
+	GB D   G2 DBAR 
+	D_HC378_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UNXOR nxor DPWR DGND
+	GB G2   EN 
+	D0_GATE IO_HC 
UIN buf3 DPWR DGND
+	$D_X   EN   IN 
+	D0_TGATE IO_HC 
UINV inva(2) DPWR DGND
+	GB DBAR   G DD 
+	D0_GATE IO_HC 
UAO ao(2,2) DPWR DGND
+	G DD GB QBUF   IN 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
UDFF dff(1) DPWR DGND
+	$D_HI $D_HI CLK   IN   QBUF $D_NC 
+	D_HC378_2 IO_HC MNTYMXDLY={MNTYMXDLY} 
UQOUT buf DPWR DGND
+	QBUF   Q 
+	D_HC378_3 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC378_1 ugate (
+	tplhmn=5ns	tphlmn=5ns
+	)
.model D_HC378_2 ueff (
+	twclklmn=25ns	twclkhmn=25ns
+	tsudclkmn=20ns	thdclkmn=5ns
+	)
.model D_HC378_3 ugate (
+	tplhty=15ns	tplhmx=40ns
+	tphlty=15ns	tphlmx=40ns
+	)
*$
*---------
* 74HC379  Octal D-TYPE Flip-Flops with Clock Enable
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	8/7/89		Update interface and model names
*
.subckt 74HC379  CLK GBAR 1D 2D 3D 4D 1Q 1QBAR 2Q 2QBAR 3Q 3QBAR 4Q 4QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UBUF bufa(2) DPWR DGND
+	GBAR CLK   GBBUF CLKBUF 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
X1Q  GBBUF CLKBUF 1D 1Q 1QBAR  DPWR DGND  HC379DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
X2Q  GBBUF CLKBUF 2D 2Q 2QBAR  DPWR DGND  HC379DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
X3Q  GBBUF CLKBUF 3D 3Q 3QBAR  DPWR DGND  HC379DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
X4Q  GBBUF CLKBUF 4D 4Q 4QBAR  DPWR DGND  HC379DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends
*
.subckt HC379DAT  GB CLK D Q QB DPWR DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
USET inva(2) DPWR DGND
+	GB D   G2 DBAR 
+	D_HC379_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UNXOR nxor DPWR DGND
+	GB G2   EN 
+	D0_GATE IO_HC 
UIN buf3 DPWR DGND
+	$D_X   EN   IN 
+	D0_TGATE IO_HC 
UINV inva(2) DPWR DGND
+	GB DBAR   G DD 
+	D0_GATE IO_HC 
UAO ao(2,2) DPWR DGND
+	G DD GB QBUF   IN 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
UDFF dff(1) DPWR DGND
+	$D_HI $D_HI CLK   IN   QBUF QBBUF 
+	D_HC379_2 IO_HC MNTYMXDLY={MNTYMXDLY} 
UQOUT bufa(2) DPWR DGND
+	QBUF QBBUF   Q QB 
+	D_HC379_3 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC379_1 ugate (
+	tplhmn=5ns	tphlmn=5ns
+	)
.model D_HC379_2 ueff (
+	twclklmn=25ns	twclkhmn=25ns
+	tsudclkmn=20ns	thdclkmn=5ns
+	)
.model D_HC379_3 ugate (
+	tplhty=15ns	tplhmx=40ns
+	tphlty=15ns	tphlmx=40ns
+	)
*$
*-------------------------------------------------------------------------
* 74HC386  Quadruple 2-Input Exclusive-OR-Gates
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	9/26/89		Update interface and model names
*
.subckt 74HC386  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UY xor DPWR DGND
+	A B   Y 
+	D_HC386 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC386 ugate (
+	tplhty=12ns	tplhmx=25ns
+	tphlty=12ns	tphlmx=25ns
+	)
*$
*---------
* 74HC390  COUNTER DECADE 4-BIT, ASYNCHRONOUS
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   7-1-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74HC390   CKA_I CKB_I CLR_I   QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CKA      $D_HI $D_HI   QA $D_NC
+ D0_EFF IO_HC
U2 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CLOCK2   $D_HI $D_HI   QB QBBAR 
+ D0_EFF IO_HC
U3 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QB       $D_HI $D_HI   QC QCBAR 
+ D0_EFF IO_HC
U4 JKFF(1) DPWR DGND
+ $D_HI CLRBAR CLOCK4   $D_HI $D_HI   QD QDBAR 
+ D0_EFF IO_HC
UHC390LOG LOGICEXP (6,6) DPWR DGND
+ CKA_I CKB_I CLR_I    QBBAR QCBAR QDBAR
+ CKA   CKB   CLR   CLRBAR   CLOCK2 CLOCK4
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   CKA    = { CKA_I }
+   CKB    = { CKB_I }
+   CLR    = { CLR_I }
+   CLRBAR = { ~CLR }
+   CLOCK2 = { CKB & QDBAR }
+   CLOCK4 = { ~((QBBAR & QDBAR) | (QCBAR & QDBAR)) & CKB }
*
UHC390DLY PINDLY (4,0,3) DPWR DGND
+ QA QB QC QD
+ CKA CLR CKB
+ QA_O QB_O QC_O QD_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLOCKEDA = { CHANGED_HL(CKA,0) }
+   CLEARED  = { CHANGED_LH(CLR,0) }
+
+ PINDLY:
+   QA_O = {
+     CASE (
+       CLOCKEDA, DELAY(-1,16NS,35NS),
+       DELAY(-1,17NS,41NS)
+       )
+     }
+   QB_O QD_O = {
+     CASE (
+       CLEARED, DELAY(-1,17NS,41NS),
+       DELAY(-1,18NS,33NS)
+       )
+     }
+   QC_O = {
+     CASE (
+       CLEARED, DELAY(-1,17NS,41NS),
+       DELAY(-1,26NS,46NS)
+       )
+     }
+
+ FREQ:
+   NODE           = CKA
+   MAXFREQ        = 25MEGHZ
+ FREQ:
+   NODE           = CKB
+   MAXFREQ        = 25MEGHZ
+ WIDTH:
+   NODE           = CKA
+   MIN_LO         = 20NS
+   MIN_HI         = 20NS
+ WIDTH:
+   NODE           = CKB
+   MIN_LO         = 20NS
+   MIN_HI         = 20NS
+ WIDTH:
+   NODE           = CLR
+   MIN_HI         = 20NS
+ SETUP_HOLD:
+   DATA(1)        = CLR
+   CLOCK HL       = CKA
+   RELEASETIME_HL = 5NS
+ SETUP_HOLD:
+   DATA(1)        = CLR
+   CLOCK HL       = CKB
+   RELEASETIME_HL = 5NS
*
.ENDS
*
*$
*---------
* 74HC393  COUNTER BINARY 4-BIT, ASYNCHRONOUS
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   6-30-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74HC393   A_I CLR_I   QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(1) DPWR DGND
+ $D_HI CLRBAR A    $D_HI $D_HI     QA $D_NC
+ D0_EFF  IO_HC
U2 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QA   $D_HI $D_HI     QB $D_NC 
+ D0_EFF  IO_HC
U3 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QB   $D_HI $D_HI     QC $D_NC 
+ D0_EFF  IO_HC
U4 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QC   $D_HI $D_HI     QD $D_NC 
+ D0_EFF  IO_HC
U5 BUFA(2) DPWR DGND
+ A_I     CLR_I
+ A	  CLR
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U6 INV DPWR DGND
+ CLR   CLRBAR 
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
*
UHC393DLY PINDLY (4,0,2) DPWR DGND
+ QA QB QC QD
+ CLR A
+ QA_O QB_O QC_O QD_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLOCKED = { CHANGED_HL(A,0) }
+   CLEARED = { CHANGED_LH(CLR,0) }
+
+ PINDLY:
+   QA_O = {
+     CASE (
+       CLOCKED, DELAY(-1,15NS,30NS),
+       DELAY(-1,17NS,41NS)
+       )
+     }
+   QB_O = {
+     CASE (
+       CLEARED, DELAY(-1,17NS,41NS),
+       DELAY(-1,22NS,47NS)
+       )
+     }
+   QC_O = {
+     CASE (
+       CLEARED, DELAY(-1,17NS,41NS),
+       DELAY(-1,28NS,60NS)
+       )
+     }
+   QD_O = {
+     CASE (
+       CLEARED, DELAY(-1,17NS,41NS),
+       DELAY(-1,32NS,72NS)
+       )
+     }
+
+ FREQ:
+   NODE           = A
+   MAXFREQ        = 25MEGHZ
+ WIDTH:
+   NODE           = A
+   MIN_LO         = 20NS
+   MIN_HI         = 20NS
+ WIDTH:
+   NODE           = CLR
+   MIN_HI         = 20NS
+ SETUP_HOLD:
+   DATA(1)        = CLR
+   CLOCK HL       = A
+   RELEASETIME_HL = 5NS
*
.ENDS
*
*$
*---------
* 74HC490  COUNTER DECADE 4-BIT, ASYNCHRONOUS
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   7-2-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74HC490   CLR_I SET9_I CLK_I   QA_O QB_O QC_O QD_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(1) DPWR DGND
+ SET9BAR CLRBAR   CLK      $D_HI $D_HI    QA $D_NC
+ D0_EFF  IO_HC
U2 JKFF(1) DPWR DGND
+ $D_HI   CLRBAR23 CLOCK2   $D_HI $D_HI    QB QBBAR 
+ D0_EFF  IO_HC
U3 JKFF(1) DPWR DGND
+ $D_HI   CLRBAR23 QB       $D_HI $D_HI    QC QCBAR 
+ D0_EFF  IO_HC
U4 JKFF(1) DPWR DGND
+ SET9BAR CLRBAR   CLOCK4   $D_HI $D_HI    QD QDBAR 
+ D0_EFF  IO_HC
*
UHC490LOG LOGICEXP (7,8) DPWR DGND
+ CLR_I  SET9_I  CLK_I QA QBBAR QCBAR QDBAR
+ CLR    SET9    CLK   CLRBAR23 CLOCK2 CLOCK4 CLRBAR SET9BAR
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   CLR      = { CLR_I }
+   CLRBAR   = { ~CLR }
+   SET9     = { SET9_I }
+   SET9BAR  = { ~SET9 }
+   CLK      = { CLK_I }
+   CLRBAR23 = { CLRBAR & SET9BAR }
+   CLOCK2   = { QA & QDBAR }
+   CLOCK4   = { ~( (QBBAR & QDBAR) | (QCBAR & QDBAR) ) & QA }
*
UHC490DLY PINDLY (4,0,3) DPWR DGND
+ QA QB QC QD
+ CLR SET9 CLK
+ QA_O QB_O QC_O QD_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLOCKED = { CHANGED_HL(CLK,0) }
+   CLEARED = { CHANGED_LH(CLR,0) }
+   SETNINE = { CHANGED_LH(SET9,0) }
+
+ PINDLY:
+   QA_O = {
+     CASE (
+       CLOCKED, DELAY(-1,15NS,31NS),
+       CLEARED, DELAY(-1,17NS,33NS),
+       DELAY(-1,19NS,46NS)
+       )
+     }
+   QB_O = {
+     CASE (
+       CLEARED, DELAY(-1,17NS,33NS),
+       SETNINE, DELAY(-1,18NS,35NS),
+       DELAY(-1,23NS,46NS)
+       )
+     }
+   QC_O = {
+     CASE (
+       CLEARED, DELAY(-1,17NS,33NS),
+       SETNINE, DELAY(-1,18NS,35NS),
+       DELAY(-1,30NS,59NS)
+       )
+     }
+   QD_O = {
+     CASE (
+       CLEARED, DELAY(-1,17NS,33NS),
+       SETNINE, DELAY(-1,19NS,46NS),
+       DELAY(-1,23NS,46NS)
+       )
+     }
+
+ FREQ:
+   NODE           = CLK
+   MAXFREQ        = 25MEGHZ
+ WIDTH:
+   NODE           = CLK
+   MIN_LO         = 20NS
+   MIN_HI         = 20NS
+ WIDTH:
+   NODE           = CLR
+   MIN_HI         = 20NS
+   WHEN           = { SET9!='1 }
+ WIDTH:
+   NODE           = SET9
+   MIN_HI         = 20NS
+ SETUP_HOLD:
+   DATA(1)        = CLR
+   CLOCK HL       = CLK
+   RELEASETIME_HL = 5NS
+   WHEN           = { SET9!='1 }
+ SETUP_HOLD:
+   DATA(1)        = SET9
+   CLOCK HL       = CLK
+   RELEASETIME_HL = 5NS
*
.ENDS
*
*$
*---------
* 74HC533  Octal D-TYPE Transparent Latches with 3-STATE Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	 9/18/89	Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC533  OCBAR C 1D 2D 3D 4D 5D 6D 7D 8D 1QBAR 2QBAR 3QBAR 4QBAR 5QBAR
+	6QBAR 7QBAR 8QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UOC inv DPWR DGND
+	OCBAR   OC 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
UQI dltch(8) DPWR DGND
+	$D_HI	$D_HI	C
+	1D	2D	3D	4D	5D	6D	7D	8D
+	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC
+	1QI	2QI	3QI	4QI	5QI	6QI	7QI	8QI
+	D_HC533_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UQBAR buf3a(8) DPWR DGND
+	1QI	2QI	3QI	4QI	5QI	6QI	7QI	8QI
+	OC
+	1QBAR	2QBAR	3QBAR	4QBAR	5QBAR	6QBAR	7QBAR	8QBAR
+	D_HC533_2 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC533_1 ugff (
+	twghmn=20ns	tsudgmn=13ns
+	thdgmn=12ns	tpgqlhty=1ns
+	tpgqlhmx=6ns	tpgqhlty=1ns
+	tpgqhlmx=6ns
+	)
.model D_HC533_2 utgate (
+	tplhty=26ns	tplhmx=38ns
+	tphlty=26ns	tphlmx=38ns
+	tpzhty=24ns	tpzhmx=38ns
+	tpzlty=24ns	tpzlmx=38ns
+	tphzty=23ns	tphzmx=38ns
+	tplzty=23ns	tplzmx=38ns
+	)
*$
*---------
* 74HC534  Octal D-TYPE Edge-Triggered Flip-Flops with 3-STATE Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	7/19/89		Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC534  OCBAR CLK 1D 2D 3D 4D 5D 6D 7D 8D 1QBAR 2QBAR 3QBAR 4QBAR 5QBAR
+	6QBAR 7QBAR 8QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UOC inv DPWR DGND
+	OCBAR   OC 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
UDFF dff(8) DPWR DGND
+	$D_HI	$D_HI	CLK
+	1D	2D	3D	4D	5D	6D	7D	8D
+	1QQ	2QQ	3QQ	4QQ	5QQ	6QQ	7QQ	8QQ
+	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC
+	D_HC534_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UOCQ inv3a(8) DPWR DGND
+	1QQ	2QQ	3QQ	4QQ	5QQ	6QQ	7QQ	8QQ
+	OC
+	1QBAR	2QBAR	3QBAR	4QBAR	5QBAR	6QBAR	7QBAR	8QBAR
+	D_HC534_2 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC534_1 ueff (
+	twclklmn=20ns
+	twclkhmn=20ns
+	tsudclkmn=25ns
+	thdclkmn=5ns
+	)
.model D_HC534_2 utgate (
+	tplhty=28ns	tplhmx=45ns
+	tphlty=28ns	tphlmx=45ns
+	tpzhty=26ns	tpzhmx=38ns
+	tpzlty=26ns	tpzlmx=38ns
+	tphzty=25ns	tphzmx=38ns
+	tplzty=25ns	tplzmx=38ns
+	)
*$
*---------
* 74HC540  Octal Buffers and Line Drivers with 3-STATE Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	7/19/89		Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC540  A1 A2 A3 A4 A5 A6 A7 A8 G1BAR G2BAR Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UA nor(2) DPWR DGND
+	G1BAR G2BAR   E 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U1 inv3a(8) DPWR DGND
+	A1	A2	A3	A4	A5	A6	A7	A8
+	E
+	Y1	Y2	Y3	Y4	Y5	Y6	Y7	Y8
+	D_HC540 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC540 utgate (
+	tplhty=10ns	tplhmx=25ns
+	tphlty=10ns	tphlmx=25ns
+	tpzhty=15ns	tpzhmx=38ns
+	tpzlty=15ns	tpzlmx=38ns
+	tphzty=18ns	tphzmx=38ns
+	tplzty=18ns	tplzmx=38ns
+	)
*$
*---------
* 74HC541  Octal Buffers and Line Driver with 3-STATE Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	7/19/89		Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC541  A1 A2 A3 A4 A5 A6 A7 A8 G1BAR G2BAR Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UA nor(2) DPWR DGND
+	G1BAR G2BAR   E 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U1 buf3a(8) DPWR DGND
+	A1	A2	A3	A4	A5	A6	A7	A8
+	E
+	Y1	Y2	Y3	Y4	Y5	Y6	Y7	Y8
+	D_HC541 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC541 utgate (
+	tplhty=12ns	tplhmx=29ns
+	tphlty=12ns	tphlmx=29ns
+	tpzhty=17ns	tpzhmx=38ns
+	tpzlty=17ns	tpzlmx=38ns
+	tphzty=18ns	tphzmx=38ns
+	tplzty=18ns	tplzmx=38ns
+	)
*$
*---------
* 74HC563  Octal D-TYPE Transparent Latches with 3-STATE Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	8/16/89		Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC563  OCBAR C 1D 2D 3D 4D 5D 6D 7D 8D 1QBAR 2QBAR 3QBAR 4QBAR 5QBAR
+	6QBAR 7QBAR 8QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UINV inv DPWR DGND
+	OCBAR   OC 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
UQBUF dltch(8) DPWR DGND
+	$D_HI	$D_HI	C
+	1D	2D	3D	4D	5D	6D	7D	8D
+	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC
+	1QB	2QB	3QB	4QB	5QB	6QB	7QB	8QB
+	D_HC563_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UQOUT buf3a(8) DPWR DGND
+	1QB	2QB	3QB	4QB	5QB	6QB	7QB	8QB
+	OC
+	1QBAR	2QBAR	3QBAR	4QBAR	5QBAR	6QBAR	7QBAR	8QBAR
+	D_HC563_2 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC563_1 ugff (
+	twghmn=20ns	tsudgmn=13ns
+	thdgmn=5ns	tpgqlhty=1ns
+	tpgqlhmx=1ps	tpgqhlty=1ns
+	tpgqhlmx=1ps
+	)
.model D_HC563_2 utgate (
+	tplhty=26ns	tplhmx=44ns
+	tphlty=26ns	tphlmx=44ns
+	tpzhty=24ns	tpzhmx=38ns
+	tpzlty=24ns	tpzlmx=38ns
+	tphzty=23ns	tphzmx=38ns
+	tplzty=23ns	tplzmx=38ns
+	)
*$
*---------
* 74HC564  Octal D-TYPE Edge-Triggered Flip-Flops with 3-STATE Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	7/19/89		Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC564  OCBAR CLK 1D 2D 3D 4D 5D 6D 7D 8D 1QBAR 2QBAR 3QBAR 4QBAR 5QBAR
+	6QBAR 7QBAR 8QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UOC inv DPWR DGND
+	OCBAR   OC 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
UDFF dff(8) DPWR DGND
+	$D_HI	$D_HI	CLK
+	1D	2D	3D	4D	5D	6D	7D	8D
+	1QQ	2QQ	3QQ	4QQ	5QQ	6QQ	7QQ	8QQ
+	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC
+	D_HC564_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UOCQ inv3a(8) DPWR DGND
+	1QQ	2QQ	3QQ	4QQ	5QQ	6QQ	7QQ	8QQ
+	OC
+	1QBAR	2QBAR	3QBAR	4QBAR	5QBAR	6QBAR	7QBAR	8QBAR
+	D_HC564_2 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC564_1 ueff (
+	twclklmn=20ns
+	twclkhmn=20ns
+	tsudclkmn=25ns
+	thdclkmn=5ns
+	)
.model D_HC564_2 utgate (
+	tplhty=18ns	tplhmx=45ns
+	tphlty=18ns	tphlmx=45ns
+	tpzhty=15ns	tpzhmx=38ns
+	tpzlty=15ns	tpzlmx=38ns
+	tphzty=15ns	tphzmx=38ns
+	tplzty=15ns	tplzmx=38ns
+	)
*$
*---------
* 74HC573  Octal D-TYPE Transparent Latches with 3-STATE Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	 8/17/89	Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC573  OCBAR C 1D 2D 3D 4D 5D 6D 7D 8D 1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U0 inv DPWR DGND
+	OCBAR   OC 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U1 dltch(8) DPWR DGND
+	$D_HI	$D_HI	C
+	1D	2D	3D	4D	5D	6D	7D	8D
+	1QI	2QI	3QI	4QI	5QI	6QI	7QI	8QI
+	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC
+	D_HC573_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 buf3a(8) DPWR DGND
+	1QI	2QI	3QI	4QI	5QI	6QI	7QI	8QI
+	OC
+	1Q	2Q	3Q	4Q	5Q	6Q	7Q	8Q
+	D_HC573_2 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC573_1 ugff (
+	tpgqlhty=1ns	tpgqlhmx=1ps
+	tpgqhlty=1ns	tpgqhlmx=1ps
+	twghmn=20ns	tsudgmn=13ns
+	thdgmn=5ns
+	)
.model D_HC573_2 utgate (
+	tplhty=26ns	tplhmx=44ns
+	tphlty=26ns	tphlmx=44ns
+	tpzhty=24ns	tpzhmx=38ns
+	tpzlty=24ns	tpzlmx=38ns
+	tphzty=23ns	tphzmx=38ns
+	tplzty=23ns	tplzmx=38ns
+	)
*$
*---------
* 74HC574  Octal D-TYPE Edge-Triggered Flip-Flops with 3-STATE Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	7/20/89		Update interface and model names
* rbh   11/11/92	Added bus I/O model
*
.subckt 74HC574  OCBAR CLK 1D 2D 3D 4D 5D 6D 7D 8D 1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UOC inv DPWR DGND
+	OCBAR   OC 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
UD dff(8) DPWR DGND
+	$D_HI	$D_HI	CLK
+	1D	2D	3D	4D	5D	6D	7D	8D
+	SQ1	SQ2	SQ3	SQ4	SQ5	SQ6	SQ7	SQ8
+	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC	$D_NC
+	D_HC574_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UQS buf3a(8) DPWR DGND
+	SQ1	SQ2	SQ3	SQ4	SQ5	SQ6	SQ7	SQ8
+	OC
+	1Q	2Q	3Q	4Q	5Q	6Q	7Q	8Q
+	D_HC574_2 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC574_1 ueff (
+	twclklmn=20ns
+	twclkhmn=20ns
+	tsudclkmn=25ns
+	thdclkmn=5ns
+	)
.model D_HC574_2 utgate (
+	tplhty=28ns	tplhmx=45ns
+	tphlty=28ns	tphlmx=45ns
+	tpzhty=26ns	tpzhmx=38ns
+	tpzlty=26ns	tpzlmx=38ns
+	tphzty=24ns	tphzmx=38ns
+	tplzty=24ns	tplzmx=38ns
+	)
*$
*-------------------------------------------------------------------------
*  74HC590A  8-Bit Binary Counter with Output Registers
*
*  HIGH SPEED CMOS LOGIC DATA BOOK, 1989, TI
*  tc  07/20/92  Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices
*
.SUBCKT 74HC590A GBAR_I CCK_I RCK_I CCKENBAR_I CCLRBAR_I
+ QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O RCOBAR_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(1) DPWR DGND $D_HI CCLRBAR CNTA $D_HI $D_HI JA KA
+ D0_EFF IO_HC
U2 JKFF(1) DPWR DGND $D_HI CCLRBAR CNTB $D_HI $D_HI JB KB
+ D0_EFF IO_HC
U3 JKFF(1) DPWR DGND $D_HI CCLRBAR CNTC $D_HI $D_HI JC KC
+ D0_EFF IO_HC
U4 JKFF(1) DPWR DGND $D_HI CCLRBAR CNTD $D_HI $D_HI JD KD
+ D0_EFF IO_HC
U5 JKFF(1) DPWR DGND $D_HI CCLRBAR CNTE $D_HI $D_HI JE KE
+ D0_EFF IO_HC
U6 JKFF(1) DPWR DGND $D_HI CCLRBAR CNTF $D_HI $D_HI JF KF
+ D0_EFF IO_HC
U7 JKFF(1) DPWR DGND $D_HI CCLRBAR CNTG $D_HI $D_HI JG KG
+ D0_EFF IO_HC
U8 JKFF(1) DPWR DGND $D_HI CCLRBAR CNTH $D_HI $D_HI JH KH
+ D0_EFF IO_HC
U9 JKFF(8) DPWR DGND $D_HI $D_HI MCLK
+ JA JB JC JD JE JF JG JH KA KB KC KD KE KF KG KH
+ QA QB QC QD QE QF QG QH
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_HC
*
UHC590ALOG LOGICEXP(14,15) DPWR DGND
+ GBAR_I RCK_I CCKENBAR_I CCK_I CCLRBAR_I JA JB JC JD JE JF JG JH CNTA
+ GBAR RCK CCKENBAR CCK CCLRBAR CNTA CNTB CNTC CNTD CNTE CNTF CNTG CNTH
+  MCLK RCOBAR
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   GBAR = { GBAR_I }
+   RCK = { RCK_I }
+   CCKENBAR = { CCKENBAR_I }
+   CCK = { CCK_I }
+   CCLRBAR = { CCLRBAR_I }
+   CNTA = { ~((~(CNTA & CCKENBAR) & CCK) & CCK) }
+   CNTB = { JA & CNTA }
+   CNTC = { JB & CNTB }
+   CNTD = { JC & CNTC }
+   CNTE = { JD & CNTD }
+   CNTF = { JE & CNTE }
+   CNTG = { JF & CNTF }
+   CNTH = { JG & CNTG }
+   MCLK = { ~RCK }
+   RCOBAR = { ~(JH & JG & JF & JE & JD & JC & JB & JA) }
*
UHC590ADLY PINDLY (9,1,6) DPWR DGND
+ QA QB QC QD QE QF QG QH RCOBAR
+ GBAR
+ GBAR RCK CCK CCLRBAR CCLRBAR CCKENBAR
+ QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O RCOBAR_O
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+   RCOBAR_O = {
+     CASE(
+       CHANGED_HL(CCLRBAR,0) & TRN_LH, DELAY(-1,18NS,33NS),
+       DELAY(-1,20NS,38NS)
+       )
+     }
+ TRISTATE:
+   ENABLE LO GBAR
+   QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O = {
+     CASE(
+       CHANGED(GBAR,0), DELAY(-1,20NS,31NS),
+       DELAY(-1,18NS,35NS)
+       )
+     }
+ FREQ:
+   NODE = CCK
+   MAXFREQ = 16MEG
+ FREQ:
+   NODE = RCK
+   MAXFREQ = 16MEG
+ WIDTH:
+   NODE = CCK
+   MIN_LO = 31NS
+   MIN_HI = 31NS
+   WHEN = { CCKENBAR!='1 }
+ WIDTH:
+   NODE = RCK
+   MIN_LO = 31NS
+   MIN_HI = 31NS
+ WIDTH:
+   NODE = CCLRBAR
+   MIN_LO = 25NS
+ SETUP_HOLD:
+   DATA(1) = CCKENBAR
+   CLOCK LH = CCK
+   SETUPTIME_LO = 25NS
+   HOLDTIME_LO = 12NS
+   WHEN = { CCLRBAR!='0 }
+ SETUP_HOLD:
+   DATA(1) = CCLRBAR
+   CLOCK LH = CCK
+   RELEASETIME_LH = 25NS
+ SETUP_HOLD:
+   DATA(1) = CCK
+   CLOCK LH = RCK
+   SETUPTIME = 25NS
+   WHEN = { CCKENBAR!='1 }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74HC594  8-BIT SHIFT REGISTERS WITH INPUT LATCHES
*
* THE HIGH-SPEED CMOS LOGIC DATA BOOK, 1989, TI
* KN   7-9-92  REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74HC594  SRCK_I RCK_I SRCLRBAR_I  RCLRBAR_I SER_I
+ QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O QHP_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 BUFA(5) DPWR DGND
+ SRCK_I RCK_I SRCLRBAR_I RCLRBAR_I SER_I
+ SRCK   RCK   SRCLRBAR   RCLRBAR   SER
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
*
U2 DFF(8) DPWR DGND $D_HI SRCLRBAR  SRCK
+ SER    Q1A      Q1B      Q1C      Q1D      Q1E      Q1F      Q1G
+ Q1A    Q1B      Q1C      Q1D      Q1E      Q1F      Q1G      QHP
+ $D_NC  $D_NC    $D_NC    $D_NC    $D_NC    $D_NC    $D_NC    $D_NC
+ D0_EFF IO_HC
*
U3 DFF(8) DPWR DGND $D_HI RCLRBAR  RCK
+ Q1A     Q1B     Q1C     Q1D     Q1E     Q1F     Q1G    QHP
+ QA      QB      QC      QD      QE      QF      QG     QH
+ $D_NC   $D_NC   $D_NC   $D_NC   $D_NC   $D_NC   $D_NC  $D_NC
+ D0_EFF IO_HC
*
UHC594DLY PINDLY (9,0,13) DPWR DGND
+ QA QB QC QD QE QF QG QH QHP
+ SRCK RCLRBAR SRCLRBAR RCK SER Q1A Q1B Q1C Q1D Q1E Q1F Q1G QHP
+ QA_O  QB_O  QC_O  QD_O  QE_O  QF_O  QG_O  QH_O  QHP_O
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   QHP_O = {
+     CASE(
+       CHANGED_HL(SRCLRBAR,0) & TRN_HL,   DELAY(-1,20NS,37NS),
+       CHANGED_LH(SRCK,0)             ,   DELAY(-1,20NS,37NS),
+                                          DELAY(-1,21NS,38NS)  ;DEFAULT
+       )
+     }
+   QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O = {
+     CASE(
+       CHANGED_HL(RCLRBAR,0) & TRN_HL,  DELAY(-1,20NS,31NS),
+       CHANGED_LH(RCK,0)             ,  DELAY(-1,20NS,37NS),
+                                        DELAY(-1,21NS,38NS)  ;DEFAULT
+       )
+     }
+
+ FREQ:
+   NODE = SRCK
+   MAXFREQ = 20MEG
+
+ WIDTH:
+   NODE = SRCK
+   MIN_HIGH = 25NS
+   MIN_LOW  = 25NS
+
+ FREQ:
+   NODE = RCK
+   MAXFREQ = 20MEG
+
+ WIDTH:
+   NODE = RCK
+   MIN_HIGH = 25NS
+   MIN_LOW = 25NS
+
+ WIDTH:
+   NODE = SRCLRBAR
+   MIN_LOW = 25NS
+
+ WIDTH:
+   NODE = RCLRBAR
+   MIN_LOW = 25NS
+
+ SETUP_HOLD:
+   DATA(1) = SER
+   CLOCK LH = SRCK
+   SETUPTIME = 22NS
+   HOLDTIME  = 5NS
+   WHEN = { SRCLRBAR!='0 }
+
+ SETUP_HOLD:              ; SRCK RISE BEFORE RCK RISE SETUP TIME
+   DATA(8) = Q1A Q1B Q1C Q1D Q1E Q1F Q1G QHP
+   CLOCK LH = RCK
+   SETUPTIME_HI = 22NS
+   MESSAGE = "SETUPTIME VIOLATION OF SRCK BEFORE SRCK"
+
+ SETUP_HOLD:              ; SRCLRBAR FALL BEFORE RCK RISE SETUP TIME
+   DATA(1) = SRCLRBAR
+   CLOCK LH = RCK
+   SETUPTIME_LO = 13NS
+   WHEN = { RCLRBAR!='0 }
+
+ SETUP_HOLD:
+   DATA(1) = SRCLRBAR
+   CLOCK LH = SRCK
+   RELEASETIME_LH = 10NS
+
+ SETUP_HOLD:              ; RCLRBAR RISE BEFORE SRCK RISE SETUP TIME
+   DATA(1) = RCLRBAR
+   CLOCK LH = SRCK
+   SETUPTIME_HI = 5NS
+   WHEN = { SRCLRBAR!='0 }
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74HC595  8-BIT SHIFT REGISTERS WITH 3-STATE OUTPUT REGISTERS
*
* THE HIGH-SPEED CMOS LOGIC DATA BOOK, 1989, TI
* KN   7-10-92      REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74HC595  GBAR_I SRCK_I RCK_I SRCLRBAR_I  SER_I
+ QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O QHP_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 BUFA(5) DPWR DGND
+ SRCK_I  RCK_I  SRCLRBAR_I  GBAR_I  SER_I
+ SRCK    RCK    SRCLRBAR    GBAR    SER
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
*
U2 DFF(8) DPWR DGND $D_HI SRCLRBAR  SRCK
+ SER   Q1A      Q1B      Q1C      Q1D      Q1E      Q1F      Q1G
+ Q1A   Q1B      Q1C      Q1D      Q1E      Q1F      Q1G      QHP
+ $D_NC  $D_NC     $D_NC    $D_NC    $D_NC    $D_NC    $D_NC    $D_NC
+ D0_EFF IO_HC
*
U3 DFF(8) DPWR DGND $D_HI $D_HI  RCK
+ Q1A    Q1B    Q1C    Q1D    Q1E    Q1F    Q1G    QHP
+ QA     QB     QC     QD     QE     QF     QG     QH
+ $D_NC  $D_NC  $D_NC  $D_NC  $D_NC  $D_NC  $D_NC  $D_NC
+ D0_EFF IO_HC
*
UHC595DLY PINDLY (9,1,15) DPWR DGND
+ QA QB QC QD QE QF QG QH QHP
+ GBAR
+ GBAR SRCK RCLRBAR SRCLRBAR RCK RCK SER Q1A Q1B Q1C Q1D Q1E Q1F Q1G QHP
+
+ QA_O  QB_O  QC_O  QD_O  QE_O  QF_O  QG_O  QH_O  QHP_O
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ PINDLY:
+   QHP_O = {
+     CASE(
+       CHANGED_LH(SRCK,0), DELAY(-1,17NS,40NS),
+       CHANGED_HL(SRCLRBAR,0) & TRN_HL, DELAY(-1,18NS,44NS),
+       DELAY(-1,19NS,45NS)  ;DEFAULT
+       )
+     }
+
+   TRISTATE:
+   ENABLE LO GBAR
+   QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O = {
+     CASE(
+       TRN_ZH, DELAY(-1,15NS,37NS),
+       CHANGED_LH(RCK,0), DELAY(-1,17NS,37NS),
+       TRN_ZL, DELAY(-1,15NS,37NS),
+       TRN_HZ, DELAY(-1,23NS,50NS),
+       TRN_LZ, DELAY(-1,23NS,50NS),
+       DELAY(-1,24NS,51NS)  ;DEFAULT
+       )
+     }
+
+
+ FREQ:
+   NODE = SRCK
+   MAXFREQ = 25MEG
+
+ WIDTH:
+   NODE = SRCK
+   MIN_HIGH = 20NS
+   MIN_LOW  = 20NS
+
+ WIDTH:
+   NODE = RCK
+   MIN_HIGH = 20NS
+   MIN_LOW  = 20NS
+
+ WIDTH:
+   NODE = SRCLRBAR
+   MIN_LOW  = 20NS
+
+ SETUP_HOLD:
+   DATA(1) = SRCLRBAR
+   CLOCK LH = SRCK
+   RELEASETIME_LH = 12NS
+
+ SETUP_HOLD:
+   DATA(1) = SER
+   CLOCK LH = SRCK
+   SETUPTIME = 25NS
+   WHEN = { SRCLRBAR!='0 }
+
+ SETUP_HOLD:              ; SRCK RISE BEFORE RCK RISE SETUP TIME
+   DATA(8) = Q1A Q1B Q1C Q1D Q1E Q1F Q1G QHP
+   CLOCK LH = RCK
+   SETUPTIME = 19NS
+   MESSAGE = "SETUPTIME VIOLATION OF SRCK BEFORE RCK"
+
+ SETUP_HOLD:              ; SRCLRBAR FALL BEFORE RCK RISE SETUP TIME
+   DATA(1) = SRCLRBAR
+   CLOCK LH = RCK
+   SETUPTIME_LO = 13NS
+
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74HC604  Octal 2-Input Multiplexed Latches with 3-STATE Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	 8/24/89	Update interface and model names
*
.subckt 74HC604  A/BBAR CLK A1 B1 A2 B2 A3 B3 A4 B4 A5 B5 A6 B6 A7 B7 A8 B8
+	Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UBUF bufa(2) DPWR DGND
+	A/BBAR CLK   A/BB CK 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
UAB/B inv DPWR DGND
+	A/BB   AB/B 
+	D0_GATE IO_HC 
XY1  A/BB AB/B CK A1 B1 Y1  DPWR DGND  HC604DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
XY2  A/BB AB/B CK A2 B2 Y2  DPWR DGND  HC604DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
XY3  A/BB AB/B CK A3 B3 Y3  DPWR DGND  HC604DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
XY4  A/BB AB/B CK A4 B4 Y4  DPWR DGND  HC604DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
XY5  A/BB AB/B CK A5 B5 Y5  DPWR DGND  HC604DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
XY6  A/BB AB/B CK A6 B6 Y6  DPWR DGND  HC604DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
XY7  A/BB AB/B CK A7 B7 Y7  DPWR DGND  HC604DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
XY8  A/BB AB/B CK A8 B8 Y8  DPWR DGND  HC604DAT
+	params: MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ends
*
.subckt HC604DAT  A/BB AB/B CK D1 D2 Y DPWR DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
UAB dff(2) DPWR DGND
+	$D_HI $D_HI CK   D1 D2   A B $D_NC $D_NC 
+	D_HC604_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UYI ao(2,2) DPWR DGND
+	A/BB A AB/B B   YI 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
UY buf3 DPWR DGND
+	YI   CK   Y 
+	D_HC604_2 IO_HC MNTYMXDLY={MNTYMXDLY} 
.ends
*
.model D_HC604_1 ueff (
+	twclklmn=25ns	twclkhmn=25ns
+	tsudclkmn=19ns
+	)
.model D_HC604_2 utgate (
+	tplhty=23ns	tplhmx=43ns
+	tphlty=23ns	tphlmx=43ns
+	tpzhty=25ns	tpzhmx=49ns
+	tpzlty=25ns	tpzlmx=49ns
+	tphzty=30ns	tphzmx=50ns
+	tplzty=30ns	tplzmx=50ns
+	)
*$
*----------
* 74HC620  OCTAL BUS TRANSCEIVERS WITH 3-STATE OUTPUTS
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   9-3-92   UPDATE TIMING
*
.SUBCKT 74HC620  GBABAR_I GAB_I
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 BUF DPWR DGND
+ GAB_I   GAB
+ D0_GATE   IO_HC   IO_LEVEL={IO_LEVEL}
U2 INV DPWR DGND
+ GBABAR_I   GBA
+ D0_GATE   IO_HC   IO_LEVEL={IO_LEVEL}
*
U3 INV3A(8) DPWR DGND
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B
+ GAB
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ D_HC620   IO_HC
+ MNTYMXDLY={MNTYMXDLY}   IO_LEVEL={IO_LEVEL}
U4 INV3A(8) DPWR DGND
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ GBA
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B
+ D_HC620   IO_HC
+ MNTYMXDLY={MNTYMXDLY}   IO_LEVEL={IO_LEVEL}
*
.MODEL D_HC620 UTGATE (
+ TPLHTY=10NS		TPLHMX=26NS
+ TPHLTY=10NS		TPHLMX=26NS
+ TPZHTY=27NS		TPZHMX=53NS
+ TPZLTY=27NS		TPZLMX=53NS
+ TPHZTY=18NS		TPHZMX=38NS
+ TPLZTY=18NS		TPLZMX=38NS
+ )
*
.ENDS
*
*$
*----------
* 74HC623  OCTAL BUS TRANSCEIVERS WITH 3-STATE OUTPUTS
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   9-3-92   UPDATE TIMING
*
.SUBCKT 74HC623  GBABAR_I GAB_I
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 BUF DPWR DGND
+ GAB_I   GAB
+ D0_GATE   IO_HC   IO_LEVEL={IO_LEVEL}
U2 INV DPWR DGND
+ GBABAR_I   GBA
+ D0_GATE   IO_HC   IO_LEVEL={IO_LEVEL}
*
U3 BUF3A(8) DPWR DGND
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B
+ GAB
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ D_HC623   IO_HC
+ MNTYMXDLY={MNTYMXDLY}   IO_LEVEL={IO_LEVEL}
U4 BUF3A(8) DPWR DGND
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ GBA
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B
+ D_HC623   IO_HC
+ MNTYMXDLY={MNTYMXDLY}   IO_LEVEL={IO_LEVEL}
*
.MODEL D_HC623 UTGATE (
+ TPLHTY=10NS		TPLHMX=26NS
+ TPHLTY=10NS		TPHLMX=26NS
+ TPZHTY=27NS		TPZHMX=53NS
+ TPZLTY=27NS		TPZLMX=53NS
+ TPHZTY=18NS		TPHZMX=38NS
+ TPLZTY=18NS		TPLZMX=38NS
+ )
*
.ENDS
*
*$
*----------
* 74HC640  OCTAL BUS TRANSCEIVERS WITH 3-STATE OUTPUTS
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   9-3-92   UPDATE TIMING
* rbh   11/11/92	Added bus I/O model
*
.SUBCKT 74HC640  GBAR_I DIR_I
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 BUFA(2) DPWR DGND
+ GBAR_I DIR_I
+ GBAR   DIR
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
U2 INV DPWR DGND
+ DIR   DIRBAR
+ D0_GATE IO_HC
U3 NORA(2,2) DPWR DGND
+ DIRBAR GBAR DIR GBAR
+ ENABLEAB    ENABLEBA
+ D0_GATE IO_HC
*
U4 INV3A(8) DPWR DGND
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B
+ ENABLEAB
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ D_HC640 IO_HC_BUS
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U5 INV3A(8) DPWR DGND
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ ENABLEBA
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B
+ D_HC640 IO_HC_BUS
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
*
.MODEL D_HC640 UTGATE (
+ TPLHTY=10NS		TPLHMX=26NS
+ TPHLTY=10NS		TPHLMX=26NS
+ TPZHTY=27NS		TPZHMX=58NS
+ TPZLTY=27NS		TPZLMX=58NS
+ TPHZTY=18NS		TPHZMX=38NS
+ TPLZTY=18NS		TPLZMX=38NS
+ )
*
.ENDS
*
*$
*---------
* 74HC643  OCTAL BUS TRANSCEIVERS WITH 3-STATE OUTPUTS
*
* THE HIGH-SPEED CMOS LOGIC DATA BOOK, 1988, TI
* ATL    9/8/89    UPDATE INTERFACE AND MODEL NAMES
* KC     9/1/92	   Updated Timing
* rbh   11/11/92   Added bus I/O model
*
.SUBCKT 74HC643  GBAR DIR A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
UBUF BUF DPWR DGND
+ DIR DR
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
UINV INVA(2) DPWR DGND
+ DR GBAR DRB G
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
UEN ANDA(2,2) DPWR DGND
+ DR G DRB G EAB EBA
+ D0_GATE IO_HC
UA BUF3A(8) DPWR DGND
+ B1 B2 B3 B4 B5 B6 B7 B8
+ EBA
+ A1 A2 A3 A4 A5 A6 A7 A8
+ D_HC643 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
UB INV3A(8) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8
+ EAB
+ B1 B2 B3 B4 B5 B6 B7 B8
+ D_HC643 IO_HC_BUS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ENDS
*
.MODEL D_HC643 UTGATE (
+ TPLHTY=10NS TPLHMX=28NS
+ TPHLTY=10NS TPHLMX=28NS
+ TPZHTY=27NS TPZHMX=58NS
+ TPZLTY=27NS TPZLMX=58NS
+ TPHZTY=18NS TPHZMX=38NS
+ TPLZTY=18NS TPLZMX=38NS
+ )
*
*$
*---------
* 74HC645  OCTAL BUS TRANSCEIVERS
*
* THE HIGH-SPEED CMOS LOGIC DATA BOOK, 1988, TI
* ATL   7/24/89         UPDATE INTERFACE AND MODEL NAMES
*
.SUBCKT 74HC645  GBAR DIR A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UBUFF BUFA(2) DPWR DGND
+ GBAR DIR   GBAR_BUF DIR_BUF
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
UA NOR(2) DPWR DGND
+ GBAR_BUF DIR_BUF   T1
+ D0_GATE IO_HC
UB INV DPWR DGND
+ GBAR_BUF   RE1
+ D0_GATE IO_HC
UC AND(2) DPWR DGND
+ RE1 DIR_BUF   T2
+ D0_GATE IO_HC
U1 BUF3A(8) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8
+ T2
+ B1 B2 B3 B4 B5 B6 B7 B8
+ D_HC645 IO_HC_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
U2 BUF3A(8) DPWR DGND
+ B1 B2 B3 B4 B5 B6 B7 B8
+ T1
+ A1 A2 A3 A4 A5 A6 A7 A8
+ D_HC645 IO_HC_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
.ENDS
*
.MODEL D_HC645 UTGATE (
+ TPLHTY=15NS TPLHMX=26NS
+ TPHLTY=15NS TPHLMX=26NS
+ TPZHTY=23NS TPZHMX=58NS
+ TPZLTY=23NS TPZLMX=58NS
+ TPHZTY=25NS TPHZMX=50NS
+ TPLZTY=25NS TPLZMX=50NS
+ )
*
*$
*---------
* 74HC646  OCTAL BUS TRANSCEIVER/REGISTER WITH 3-STATE OUTPUTS
*
* High-Speed CMOS Logic Data Book, 1989, TI
* JSW   8/31/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
* rbh   11/11/92	Added bus I/O model
*
.SUBCKT 74HC646 GBAR_I DIR_I CBA_I SBA_I CAB_I SAB_I 
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B 
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B 
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC646LOG1 LOGICEXP(38,40) DPWR DGND
+ GBAR_I DIR_I CBA_I SBA_I CAB_I SAB_I 
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B 
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B 
+ QA1 QA2 QA3 QA4 QA5 QA6 QA7 QA8 
+ QB1 QB2 QB3 QB4 QB5 QB6 QB7 QB8 
+ GBAR DIR CBA SBA CAB SAB
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8 
+ A1_OUT A2_OUT A3_OUT A4_OUT A5_OUT A6_OUT A7_OUT A8_OUT 
+ B1_OUT B2_OUT B3_OUT B4_OUT B5_OUT B6_OUT B7_OUT B8_OUT
+ ENA ENB  
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   GBAR = { GBAR_I }
+   DIR = { DIR_I }
+   CBA = { CBA_I }
+   SBA = { SBA_I }
+   SBABAR = { ~SBA }
+   CAB = { CAB_I }
+   SAB = { SAB_I }
+   SABBAR = { ~SAB }
+   ENA = { ~DIR & ~GBAR }
+   ENB = {  DIR & ~GBAR }
+   A1 = { A1_B }
+   B1 = { B1_B }
+   A2 = { A2_B }
+   B2 = { B2_B }
+   A3 = { A3_B }
+   B3 = { B3_B }
+   A4 = { A4_B }
+   B4 = { B4_B }
+   A5 = { A5_B }
+   B5 = { B5_B }
+   A6 = { A6_B }
+   B6 = { B6_B }
+   A7 = { A7_B }
+   B7 = { B7_B }
+   A8 = { A8_B }
+   B8 = { B8_B }
+   A1_OUT = { ~((~B1 & SBABAR) | (SBA & QB1)) }
+   B1_OUT = { ~((~A1 & SABBAR) | (SAB & QA1)) }
+   A2_OUT = { ~((~B2 & SBABAR) | (SBA & QB2)) }
+   B2_OUT = { ~((~A2 & SABBAR) | (SAB & QA2)) }
+   A3_OUT = { ~((~B3 & SBABAR) | (SBA & QB3)) }
+   B3_OUT = { ~((~A3 & SABBAR) | (SAB & QA3)) }
+   A4_OUT = { ~((~B4 & SBABAR) | (SBA & QB4)) }
+   B4_OUT = { ~((~A4 & SABBAR) | (SAB & QA4)) }
+   A5_OUT = { ~((~B5 & SBABAR) | (SBA & QB5)) }
+   B5_OUT = { ~((~A5 & SABBAR) | (SAB & QA5)) }
+   A6_OUT = { ~((~B6 & SBABAR) | (SBA & QB6)) }
+   B6_OUT = { ~((~A6 & SABBAR) | (SAB & QA6)) }
+   A7_OUT = { ~((~B7 & SBABAR) | (SBA & QB7)) }
+   B7_OUT = { ~((~A7 & SABBAR) | (SAB & QA7)) }
+   A8_OUT = { ~((~B8 & SBABAR) | (SBA & QB8)) }
+   B8_OUT = { ~((~A8 & SABBAR) | (SAB & QA8)) }
*
UAREG DFF(8) DPWR DGND $D_HI $D_HI CAB 
+ A1 A2 A3 A4 A5 A6 A7 A8
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ QA1 QA2 QA3 QA4 QA5 QA6 QA7 QA8
+ D0_EFF IO_HC
*
UBREG DFF(8) DPWR DGND $D_HI $D_HI CBA 
+ B1 B2 B3 B4 B5 B6 B7 B8
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ QB1 QB2 QB3 QB4 QB5 QB6 QB7 QB8
+ D0_EFF IO_HC
*
UHC646DLY PINDLY (16,2,23) DPWR DGND
+ A1_OUT A2_OUT A3_OUT A4_OUT A5_OUT A6_OUT A7_OUT A8_OUT B1_OUT B2_OUT B3_OUT B4_OUT B5_OUT B6_OUT B7_OUT B8_OUT
+ ENA ENB
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8 CAB CBA SAB SBA GBAR DIR DIR
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ IO_HC_BUS 
+ MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+ BOOLEAN:
+   BUSA = { CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0) | CHANGED(A4,0) 
+          | CHANGED(A5,0) | CHANGED(A6,0) | CHANGED(A7,0) | CHANGED(A8,0) }
+   BUSB = { CHANGED(B1,0) | CHANGED(B2,0) | CHANGED(B3,0) | CHANGED(B4,0) 
+          | CHANGED(B5,0) | CHANGED(B6,0) | CHANGED(B7,0) | CHANGED(B8,0) }
+   
+ TRISTATE:
+   ENABLE HI ENA
+   A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B = { 
+     CASE(
+       CHANGED(CBA,0) & SBA=='1, DELAY(-1,18NS,45NS),
+       BUSB & SBA!='1, DELAY(-1,14NS,34NS),
+       CHANGED(SBA,0), DELAY(-1,20NS,48NS),
+       CHANGED(GBAR,0), DELAY(-1,25NS,61NS),
+       CHANGED(DIR,0), DELAY(-1,25NS,61NS),
+       DELAY(-1,26NS,62NS)
+       )
+     }
+ TRISTATE:
+   ENABLE HI ENB
+   B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B = { 
+     CASE(
+       CHANGED(CAB,0) & SAB=='1, DELAY(-1,18NS,45NS),
+       BUSA & SAB!='1, DELAY(-1,14NS,34NS),
+       CHANGED(SAB,0), DELAY(-1,20NS,48NS),
+       CHANGED(GBAR,0), DELAY(-1,25NS,61NS),
+       CHANGED(DIR,0), DELAY(-1,25NS,61NS),
+       DELAY(-1,26NS,62NS)
+       )
+     }
+ FREQ:
+   NODE = CAB
+   MAXFREQ = 27MEG
+ FREQ:
+   NODE = CBA
+   MAXFREQ = 27MEG
+ WIDTH:
+   NODE = CAB
+   MIN_HI = 19NS
+   MIN_LO = 19NS
+ WIDTH:
+   NODE = CBA
+   MIN_HI = 19NS
+   MIN_LO = 19NS
+ SETUP_HOLD:
+   DATA(8) = A1 A2 A3 A4 A5 A6 A7 A8 
+   CLOCK LH = CAB
+   SETUPTIME = 25NS
+   HOLDTIME = 5NS
+   WHEN = { DIR!='0 }
+ SETUP_HOLD:
+   DATA(8) = B1 B2 B3 B4 B5 B6 B7 B8
+   CLOCK LH = CBA
+   SETUPTIME = 25NS
+   HOLDTIME = 5NS
+   WHEN = { DIR!='1 }
*
.ENDS
*
*$
*---------
* 74HC648  OCTAL BUS TRANSCEIVER/REGISTER WITH 3-STATE OUTPUTS
*
* High-Speed CMOS Logic Data Book, 1989, TI
* JSW   9/7/92   Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices  
* rbh   11/11/92	Added bus I/O model
*
.SUBCKT 74HC648 GBAR_I DIR_I CBA_I SBA_I CAB_I SAB_I 
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B 
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B 
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC648LOG1 LOGICEXP(38,40) DPWR DGND
+ GBAR_I DIR_I CBA_I SBA_I CAB_I SAB_I 
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B 
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B 
+ QA1 QA2 QA3 QA4 QA5 QA6 QA7 QA8 
+ QB1 QB2 QB3 QB4 QB5 QB6 QB7 QB8 
+ GBAR DIR CBA SBA CAB SAB
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8 
+ A1_OUT A2_OUT A3_OUT A4_OUT A5_OUT A6_OUT A7_OUT A8_OUT 
+ B1_OUT B2_OUT B3_OUT B4_OUT B5_OUT B6_OUT B7_OUT B8_OUT
+ ENA ENB  
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   GBAR = { GBAR_I }
+   DIR = { DIR_I }
+   CBA = { CBA_I }
+   SBA = { SBA_I }
+   SBABAR = { ~SBA }
+   CAB = { CAB_I }
+   SAB = { SAB_I }
+   SABBAR = { ~SAB }
+   ENA = { ~DIR & ~GBAR }
+   ENB = {  DIR & ~GBAR }
+   A1 = { A1_B }
+   B1 = { B1_B }
+   A2 = { A2_B }
+   B2 = { B2_B }
+   A3 = { A3_B }
+   B3 = { B3_B }
+   A4 = { A4_B }
+   B4 = { B4_B }
+   A5 = { A5_B }
+   B5 = { B5_B }
+   A6 = { A6_B }
+   B6 = { B6_B }
+   A7 = { A7_B }
+   B7 = { B7_B }
+   A8 = { A8_B }
+   B8 = { B8_B }
+   A1_OUT = { ~((B1 & SBABAR) | (SBA & QB1)) }
+   B1_OUT = { ~((A1 & SABBAR) | (SAB & QA1)) }
+   A2_OUT = { ~((B2 & SBABAR) | (SBA & QB2)) }
+   B2_OUT = { ~((A2 & SABBAR) | (SAB & QA2)) }
+   A3_OUT = { ~((B3 & SBABAR) | (SBA & QB3)) }
+   B3_OUT = { ~((A3 & SABBAR) | (SAB & QA3)) }
+   A4_OUT = { ~((B4 & SBABAR) | (SBA & QB4)) }
+   B4_OUT = { ~((A4 & SABBAR) | (SAB & QA4)) }
+   A5_OUT = { ~((B5 & SBABAR) | (SBA & QB5)) }
+   B5_OUT = { ~((A5 & SABBAR) | (SAB & QA5)) }
+   A6_OUT = { ~((B6 & SBABAR) | (SBA & QB6)) }
+   B6_OUT = { ~((A6 & SABBAR) | (SAB & QA6)) }
+   A7_OUT = { ~((B7 & SBABAR) | (SBA & QB7)) }
+   B7_OUT = { ~((A7 & SABBAR) | (SAB & QA7)) }
+   A8_OUT = { ~((B8 & SBABAR) | (SBA & QB8)) }
+   B8_OUT = { ~((A8 & SABBAR) | (SAB & QA8)) }
*
UAREG DFF(8) DPWR DGND $D_HI $D_HI CAB 
+ A1 A2 A3 A4 A5 A6 A7 A8
+ QA1 QA2 QA3 QA4 QA5 QA6 QA7 QA8 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ D0_EFF IO_HC
*
UBREG DFF(8) DPWR DGND $D_HI $D_HI CBA 
+ B1 B2 B3 B4 B5 B6 B7 B8
+ QB1 QB2 QB3 QB4 QB5 QB6 QB7 QB8 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ D0_EFF IO_HC
*
UHC648DLY PINDLY (16,2,23) DPWR DGND
+ A1_OUT A2_OUT A3_OUT A4_OUT A5_OUT A6_OUT A7_OUT A8_OUT B1_OUT B2_OUT B3_OUT B4_OUT B5_OUT B6_OUT B7_OUT B8_OUT
+ ENA ENB
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8 CAB CBA SAB SBA GBAR DIR DIR
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ IO_HC_BUS
+ MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+ BOOLEAN:
+   BUSA = { CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0) | CHANGED(A4,0) 
+          | CHANGED(A5,0) | CHANGED(A6,0) | CHANGED(A7,0) | CHANGED(A8,0) }
+   BUSB = { CHANGED(B1,0) | CHANGED(B2,0) | CHANGED(B3,0) | CHANGED(B4,0) 
+          | CHANGED(B5,0) | CHANGED(B6,0) | CHANGED(B7,0) | CHANGED(B8,0) }
+   
+ TRISTATE:
+   ENABLE HI ENA
+   A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B = { 
+     CASE(
+       CHANGED(CBA,0) & SBA=='1, DELAY(-1,18NS,45NS),
+       BUSB & SBA!='1, DELAY(-1,14NS,34NS),
+       CHANGED(SBA,0), DELAY(-1,20NS,48NS),
+       CHANGED(GBAR,0), DELAY(-1,25NS,61NS),
+       CHANGED(DIR,0), DELAY(-1,25NS,61NS),
+       DELAY(-1,26NS,62NS)
+       )
+     }
+ TRISTATE:
+   ENABLE HI ENB
+   B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B = { 
+     CASE(
+       CHANGED(CAB,0) & SAB=='1, DELAY(-1,18NS,45NS),
+       BUSA & SAB!='1, DELAY(-1,14NS,34NS),
+       CHANGED(SAB,0), DELAY(-1,20NS,48NS),
+       CHANGED(GBAR,0), DELAY(-1,25NS,61NS),
+       CHANGED(DIR,0), DELAY(-1,25NS,61NS),
+       DELAY(-1,26NS,62NS)
+       )
+     }
+ FREQ:
+   NODE = CAB
+   MAXFREQ = 27MEG
+ FREQ:
+   NODE = CBA
+   MAXFREQ = 27MEG
+ WIDTH:
+   NODE = CAB
+   MIN_HI = 19NS
+   MIN_LO = 19NS
+ WIDTH:
+   NODE = CBA
+   MIN_HI = 19NS
+   MIN_LO = 19NS
+ SETUP_HOLD:
+   DATA(8) = A1 A2 A3 A4 A5 A6 A7 A8 
+   CLOCK LH = CAB
+   SETUPTIME = 25NS
+   HOLDTIME = 5NS
+   WHEN = { DIR!='0 }
+ SETUP_HOLD:
+   DATA(8) = B1 B2 B3 B4 B5 B6 B7 B8
+   CLOCK LH = CBA
+   SETUPTIME = 25NS
+   HOLDTIME = 5NS
+   WHEN = { DIR!='1 }
*
.ENDS
*
*$
*---------
* 74HC651  OCTAL BUS TRANSCEIVERS AND REGISTERS WITH INVERTED 3-STATE OUTPUTS
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, 1989, TI
* JSW  09/10/92  REMODELED USING LOGICEXP, PINDLY, & CONSTRAINT DEVICES
*
* NOTE: THE LOGIC FROM 74ALS651 IS USED TO MODEL THIS DEVICE.
*       ADDITIONAL LOGIC WAS ADDED TO MODEL THE BIDIRECTIONAL PINS OF THIS
*       DEVICE.
*
.SUBCKT 74HC651 GBABAR_I GAB_I CBA_I SBA_I CAB_I SAB_I A1_B A2_B A3_B A4_B
+ A5_B A6_B A7_B A8_B B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 DFF(8) DPWR DGND $D_HI $D_HI CAB
+ A1_IO A2_IO A3_IO A4_IO A5_IO A6_IO A7_IO A8_IO 
+ QB1 QB2 QB3 QB4 QB5 QB6 QB7 QB8
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ D0_EFF IO_HC
*
U2 DFF(8) DPWR DGND $D_HI $D_HI CBA
+ B1_IO B2_IO B3_IO B4_IO B5_IO B6_IO B7_IO B8_IO 
+ QA1 QA2 QA3 QA4 QA5 QA6 QA7 QA8
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ D0_EFF IO_HC
*
U3 BUF3A(8) DPWR DGND
+ A1_O A2_O A3_O A4_O A5_O A6_O A7_O A8_O IGBABAR
+ A1_IO A2_IO A3_IO A4_IO A5_IO A6_IO A7_IO A8_IO
+ D0_TGATE IO_HC
*
U4 BUF3A(8) DPWR DGND
+ B1_O B2_O B3_O B4_O B5_O B6_O B7_O B8_O GAB
+ B1_IO B2_IO B3_IO B4_IO B5_IO B6_IO B7_IO B8_IO
+ D0_TGATE IO_HC
*
U5 BUF3A(8) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8 GBABAR
+ A1_IO A2_IO A3_IO A4_IO A5_IO A6_IO A7_IO A8_IO
+ D0_TGATE IO_HC
*
U6 BUF3A(8) DPWR DGND
+ B1 B2 B3 B4 B5 B6 B7 B8 IGAB
+ B1_IO B2_IO B3_IO B4_IO B5_IO B6_IO B7_IO B8_IO
+ D0_TGATE IO_HC
*
UHC651LOG LOGICEXP(38,40) DPWR DGND
+ GBABAR_I GAB_I CBA_I SBA_I CAB_I SAB_I A1_B A2_B A3_B A4_B A5_B A6_B
+ A7_B A8_B B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B QA1 QA2 QA3
+ QA4 QA5 QA6 QA7 QA8 QB1 QB2 QB3 QB4 QB5
+ QB6 QB7 QB8
+ GBABAR GAB CBA SBA CAB SAB A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ A1_O A2_O A3_O A4_O A5_O A6_O A7_O A8_O B1_O B2_O B3_O B4_O B5_O B6_O
+ B7_O B8_O IGAB IGBABAR
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   GBABAR = { GBABAR_I }
+   GAB = { GAB_I }
+   CBA = { CBA_I }
+   SBA = { SBA_I }
+   CAB = { CAB_I }
+   SAB = { SAB_I }
+   A1 = { A1_B }
+   A2 = { A2_B }
+   A3 = { A3_B }
+   A4 = { A4_B }
+   A5 = { A5_B }
+   A6 = { A6_B }
+   A7 = { A7_B }
+   A8 = { A8_B }
+   B1 = { B1_B }
+   B2 = { B2_B }
+   B3 = { B3_B }
+   B4 = { B4_B }
+   B5 = { B5_B }
+   B6 = { B6_B }
+   B7 = { B7_B }
+   B8 = { B8_B }
+   ISAB = { ~SAB }
+   ISBA = { ~SBA }
+   IGAB = { ~GAB }
+   IGBABAR = { ~GBABAR }
+   A1_O = { ~((SBA & QA1) | (ISBA & B1)) }
+   A2_O = { ~((SBA & QA2) | (ISBA & B2)) }
+   A3_O = { ~((SBA & QA3) | (ISBA & B3)) }
+   A4_O = { ~((SBA & QA4) | (ISBA & B4)) }
+   A5_O = { ~((SBA & QA5) | (ISBA & B5)) }
+   A6_O = { ~((SBA & QA6) | (ISBA & B6)) }
+   A7_O = { ~((SBA & QA7) | (ISBA & B7)) }
+   A8_O = { ~((SBA & QA8) | (ISBA & B8)) }
+   B1_O = { ~((SAB & QB1) | (ISAB & A1)) }
+   B2_O = { ~((SAB & QB2) | (ISAB & A2)) }
+   B3_O = { ~((SAB & QB3) | (ISAB & A3)) }
+   B4_O = { ~((SAB & QB4) | (ISAB & A4)) }
+   B5_O = { ~((SAB & QB5) | (ISAB & A5)) }
+   B6_O = { ~((SAB & QB6) | (ISAB & A6)) }
+   B7_O = { ~((SAB & QB7) | (ISAB & A7)) }
+   B8_O = { ~((SAB & QB8) | (ISAB & A8)) }
*
UHC651DLY PINDLY (16,2,22) DPWR DGND
+ A1_IO A2_IO A3_IO A4_IO A5_IO A6_IO A7_IO A8_IO B1_IO B2_IO B3_IO B4_IO B5_IO B6_IO B7_IO B8_IO
+ GBABAR GAB
+ CBA SBA CAB SAB A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8 B7 B8
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   BUS_A = { CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0) | CHANGED(A4,0) |
+     CHANGED(A5,0) | CHANGED(A6,0) | CHANGED(A7,0) | CHANGED(A8,0) }
+   BUS_B = { CHANGED(B1,0) | CHANGED(B2,0) | CHANGED(B3,0) | CHANGED(B4,0) |
+     CHANGED(B5,0) | CHANGED(B6,0) | CHANGED(B7,0) | CHANGED(B8,0) }
+ TRISTATE:
+   ENABLE LO GBABAR
+   A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B = {
+     CASE(
+       BUS_B, DELAY(-1,14NS,34NS),
+       CHANGED_LH(CBA,0), DELAY(-1,18NS,45NS),
+       CHANGED(SBA,0), DELAY(-1,20NS,48NS),
+       TRN_$Z, DELAY(-1,23NS,61NS),
+       TRN_Z$, DELAY(-1,25NS,61NS),
+       DELAY(-1,26NS,62NS)
+       )
+     }
+ TRISTATE:
+   ENABLE HI GAB
+   B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B = {
+     CASE(
+       BUS_A, DELAY(-1,14NS,34NS),
+       CHANGED_LH(CAB,0), DELAY(-1,18NS,45NS),
+       CHANGED(SAB,0), DELAY(-1,20NS,48NS),
+       TRN_$Z, DELAY(-1,23NS,61NS),
+       TRN_Z$, DELAY(-1,25NS,61NS),
+       DELAY(-1,26NS,62NS)
+       )
+     }
+ FREQ:
+   NODE = CBA
+   MAXFREQ = 27MEG
+ FREQ:
+   NODE = CAB
+   MAXFREQ = 27MEG
+ WIDTH:
+   NODE = CBA
+   MIN_LO = 19NS
+   MIN_HI = 19NS   
+ WIDTH:
+   NODE = CAB
+   MIN_LO = 19NS
+   MIN_HI = 19NS
+ SETUP_HOLD:
+   DATA(8) = A1 A2 A3 A4 A5 A6 A7 A8
+   CLOCK LH = CAB
+   SETUPTIME = 25NS
+   HOLDTIME = 5NS   
+ SETUP_HOLD:
+   DATA(8) = B1 B2 B3 B4 B5 B6 B7 B8
+   CLOCK LH = CBA
+   SETUPTIME = 25NS
+   HOLDTIME = 5NS   
*
.ENDS
*
*$
*---------
* 74HC652  BUS TRANSCEIVERS AND REGISTERS OCTAL WITH 3-STATE OUTPUTS
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, 1989, TI
* TC  09/04/92  REMODELED USING LOGICEXP, PINDLY, & CONSTRAINT DEVICES
*
* NOTE: THE LOGIC FROM 74ALS652 IS USED TO MODEL THIS DEVICE.
*       ADDITIONAL LOGIC WAS ADDED TO MODEL THE BIDIRECTIONAL PINS OF THIS
*       DEVICE.
*
.SUBCKT 74HC652 GBABAR_I GAB_I CBA_I SBA_I CAB_I SAB_I
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 DFF(8) DPWR DGND $D_HI $D_HI CAB
+ A1_IO A2_IO A3_IO A4_IO A5_IO A6_IO A7_IO A8_IO
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ QB1BAR QB2BAR QB3BAR QB4BAR QB5BAR QB6BAR QB7BAR QB8BAR
+ D0_EFF IO_HC
*
U2 DFF(8) DPWR DGND $D_HI $D_HI CBA
+ B1_IO B2_IO B3_IO B4_IO B5_IO B6_IO B7_IO B8_IO
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ QA1BAR QA2BAR QA3BAR QA4BAR QA5BAR QA6BAR QA7BAR QA8BAR
+ D0_EFF IO_HC
*
U3 BUF3A(8) DPWR DGND
+ A1_O A2_O A3_O A4_O A5_O A6_O A7_O A8_O IGBABAR
+ A1_IO A2_IO A3_IO A4_IO A5_IO A6_IO A7_IO A8_IO
+ D0_TGATE IO_HC
*
U4 BUF3A(8) DPWR DGND
+ B1_O B2_O B3_O B4_O B5_O B6_O B7_O B8_O GAB
+ B1_IO B2_IO B3_IO B4_IO B5_IO B6_IO B7_IO B8_IO
+ D0_TGATE IO_HC
*
U5 BUF3A(8) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8 GBABAR
+ A1_IO A2_IO A3_IO A4_IO A5_IO A6_IO A7_IO A8_IO
+ D0_TGATE IO_HC
*
U6 BUF3A(8) DPWR DGND
+ B1 B2 B3 B4 B5 B6 B7 B8 IGAB
+ B1_IO B2_IO B3_IO B4_IO B5_IO B6_IO B7_IO B8_IO
+ D0_TGATE IO_HC
*
UHC652LOG LOGICEXP(38,40) DPWR DGND
+ GBABAR_I GAB_I CBA_I SBA_I CAB_I SAB_I
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ QA1BAR QA2BAR QA3BAR QA4BAR QA5BAR QA6BAR QA7BAR QA8BAR
+ QB1BAR QB2BAR QB3BAR QB4BAR QB5BAR QB6BAR QB7BAR QB8BAR
+ GBABAR GAB CBA SBA CAB SAB A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ A1_O A2_O A3_O A4_O A5_O A6_O A7_O A8_O
+ B1_O B2_O B3_O B4_O B5_O B6_O B7_O B8_O IGAB IGBABAR
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   GBABAR = { GBABAR_I }
+   GAB = { GAB_I }
+   CBA = { CBA_I }
+   SBA = { SBA_I }
+   CAB = { CAB_I }
+   SAB = { SAB_I }
+   A1 = { A1_B }
+   A2 = { A2_B }
+   A3 = { A3_B }
+   A4 = { A4_B }
+   A5 = { A5_B }
+   A6 = { A6_B }
+   A7 = { A7_B }
+   A8 = { A8_B }
+   B1 = { B1_B }
+   B2 = { B2_B }
+   B3 = { B3_B }
+   B4 = { B4_B }
+   B5 = { B5_B }
+   B6 = { B6_B }
+   B7 = { B7_B }
+   B8 = { B8_B }
+   ISAB = { ~SAB }
+   ISBA = { ~SBA }
+   IGAB = { ~GAB }
+   IGBABAR = { ~GBABAR }
+   A1_O = { ~((SBA & QA1BAR) | (ISBA & ~B1)) }
+   A2_O = { ~((SBA & QA2BAR) | (ISBA & ~B2)) }
+   A3_O = { ~((SBA & QA3BAR) | (ISBA & ~B3)) }
+   A4_O = { ~((SBA & QA4BAR) | (ISBA & ~B4)) }
+   A5_O = { ~((SBA & QA5BAR) | (ISBA & ~B5)) }
+   A6_O = { ~((SBA & QA6BAR) | (ISBA & ~B6)) }
+   A7_O = { ~((SBA & QA7BAR) | (ISBA & ~B7)) }
+   A8_O = { ~((SBA & QA8BAR) | (ISBA & ~B8)) }
+   B1_O = { ~((SAB & QB1BAR) | (ISAB & ~A1)) }
+   B2_O = { ~((SAB & QB2BAR) | (ISAB & ~A2)) }
+   B3_O = { ~((SAB & QB3BAR) | (ISAB & ~A3)) }
+   B4_O = { ~((SAB & QB4BAR) | (ISAB & ~A4)) }
+   B5_O = { ~((SAB & QB5BAR) | (ISAB & ~A5)) }
+   B6_O = { ~((SAB & QB6BAR) | (ISAB & ~A6)) }
+   B7_O = { ~((SAB & QB7BAR) | (ISAB & ~A7)) }
+   B8_O = { ~((SAB & QB8BAR) | (ISAB & ~A8)) }
*
UHC652DLY PINDLY (16,2,22) DPWR DGND
+ A1_IO A2_IO A3_IO A4_IO A5_IO A6_IO A7_IO A8_IO B1_IO B2_IO B3_IO B4_IO B5_IO B6_IO B7_IO B8_IO
+ GBABAR GAB
+ CBA SBA CAB SAB A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8 B7 B8
+ A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B
+ B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   BUS_A = { CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0) | CHANGED(A4,0) |
+             CHANGED(A5,0) | CHANGED(A6,0) | CHANGED(A7,0) | CHANGED(A8,0) }
+   BUS_B = { CHANGED(B1,0) | CHANGED(B2,0) | CHANGED(B3,0) | CHANGED(B4,0) |
+             CHANGED(B5,0) | CHANGED(B6,0) | CHANGED(B7,0) | CHANGED(B8,0) }
+ TRISTATE:
+   ENABLE LO GBABAR
+   A1_B A2_B A3_B A4_B A5_B A6_B A7_B A8_B = {
+     CASE(
+       CHANGED(SBA,0), DELAY(-1,20NS,48NS),
+       CHANGED_LH(CBA,0), DELAY(-1,18NS,45NS),
+       BUS_B, DELAY(-1,14NS,34NS),
+       TRN_Z$, DELAY(-1,25NS,61NS),
+       TRN_$Z, DELAY(-1,23NS,61NS),
+       DELAY(-1,26NS,62NS)
+       )
+     }
+ TRISTATE:
+   ENABLE HI GAB
+   B1_B B2_B B3_B B4_B B5_B B6_B B7_B B8_B = {
+     CASE(
+       CHANGED(SAB,0), DELAY(-1,20NS,48NS),
+       CHANGED_LH(CAB,0), DELAY(-1,18NS,45NS),
+       BUS_A, DELAY(-1,14NS,34NS),
+       TRN_$Z, DELAY(-1,23NS,61NS),
+       TRN_Z$, DELAY(-1,25NS,61NS),
+       DELAY(-1,26NS,62NS)
+       )
+     }
+ FREQ:
+   NODE = CBA
+   MAXFREQ = 27MEG
+ FREQ:
+   NODE = CAB
+   MAXFREQ = 27MEG
+ WIDTH:
+   NODE = CBA
+   MIN_LO = 19NS
+   MIN_HI = 19NS   
+ WIDTH:
+   NODE = CAB
+   MIN_LO = 19NS
+   MIN_HI = 19NS
+ SETUP_HOLD:
+   DATA(8) = A1 A2 A3 A4 A5 A6 A7 A8
+   CLOCK LH = CAB
+   SETUPTIME = 25NS
+   HOLDTIME = 5NS   
+ SETUP_HOLD:
+   DATA(8) = B1 B2 B3 B4 B5 B6 B7 B8
+   CLOCK LH = CBA
+   SETUPTIME = 25NS
+   HOLDTIME = 5NS   
*
.ENDS
*
*$
*---------
* 74HC670  REGISTER FILES 4X4 WITH 3-STATE OUTPUTS
*
* HIGH SPEED CMOS LOGIC FAMILY BOOK, 1991, PHILIPS SEMICONDUCTORS
* JLS   7-14-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
* rbh   11/11/92	Added bus I/O model
*
.SUBCKT 74HC670   WEBAR_I REBAR_I WA_I WB_I RA_I RB_I D0_I D1_I D2_I D3_I
+ Q0_O Q1_O Q2_O Q3_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UA DLTCH(4) DPWR DGND
+ $D_HI $D_HI GATEA
+    D0    D1    D2    D3
+   AQ0   AQ1   AQ2   AQ3
+ $D_NC $D_NC $D_NC $D_NC
+ D0_GFF  IO_HC
UB DLTCH(4) DPWR DGND
+ $D_HI $D_HI GATEB
+    D0    D1    D2    D3
+   BQ0   BQ1   BQ2   BQ3
+ $D_NC $D_NC $D_NC $D_NC
+ D0_GFF  IO_HC
UC DLTCH(4) DPWR DGND
+ $D_HI $D_HI GATEC
+    D0    D1    D2    D3
+   CQ0   CQ1   CQ2   CQ3
+ $D_NC $D_NC $D_NC $D_NC
+ D0_GFF  IO_HC
UD DLTCH(4) DPWR DGND
+ $D_HI $D_HI GATED
+    D0    D1    D2    D3
+   DQ0   DQ1   DQ2   DQ3
+ $D_NC $D_NC $D_NC $D_NC
+ D0_GFF  IO_HC
*
UHC670LOG LOGICEXP (26,18) DPWR DGND
+ WEBAR_I REBAR_I WA_I WB_I RA_I RB_I D0_I D1_I D2_I D3_I
+ AQ0 AQ1 AQ2 AQ3   BQ0 BQ1 BQ2 BQ3   CQ0 CQ1 CQ2 CQ3   DQ0 DQ1 DQ2 DQ3
+ WEBAR   REBAR   WA   WB   RA   RB   D0   D1   D2   D3
+ GATEA GATEB GATEC GATED Q0 Q1 Q2 Q3
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   WEBAR   = { WEBAR_I }
+   REBAR   = { REBAR_I }
+   WA      = { WA_I }
+   WB      = { WB_I }
+   RA      = { RA_I }
+   RB      = { RB_I }
+   D0      = { D0_I }
+   D1      = { D1_I }
+   D2      = { D2_I }
+   D3      = { D3_I }
+   ENABLE2 = { ~(WEBAR | WB) }
+   ENABLE1 = { ~(WEBAR | ENABLE2) }
+   GATEA   = { ENABLE2 & ~WA }
+   GATEB   = { ENABLE2 &  WA }
+   GATEC   = { ENABLE1 & ~WA }
+   GATED   = { ENABLE1 &  WA }
+   Q0      = { (AQ0 & ~RA & ~RB) |
+               (BQ0 &  RA & ~RB) |
+               (CQ0 & ~RA &  RB) |
+               (DQ0 &  RA &  RB)
+             }
+   Q1      = { (AQ1 & ~RA & ~RB) |
+               (BQ1 &  RA & ~RB) |
+               (CQ1 & ~RA &  RB) |
+               (DQ1 &  RA &  RB)
+             }
+   Q2      = { (AQ2 & ~RA & ~RB) |
+               (BQ2 &  RA & ~RB) |
+               (CQ2 & ~RA &  RB) |
+               (DQ2 &  RA &  RB)
+             }
+   Q3      = { (AQ3 & ~RA & ~RB) |
+               (BQ3 &  RA & ~RB) |
+               (CQ3 & ~RA &  RB) |
+               (DQ3 &  RA &  RB)
+             }
*
UHC670DLY PINDLY (4,1,9) DPWR DGND
+ Q0 Q1 Q2 Q3
+ REBAR
+ WEBAR RA RB D0 D1 D2 D3 WA WB
+ Q0_O Q1_O Q2_O Q3_O
+ IO_HC_BUS
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   WRITEEN = { CHANGED(WEBAR,0) }
+   READ    = { CHANGED(RA,0) | CHANGED(RB,0) }
+   DATA    = { CHANGED(D0,0) | CHANGED(D1,0) |
+               CHANGED(D2,0) | CHANGED(D3,0) }
+
+ TRISTATE:
+   ENABLE LO REBAR
+   Q0_O Q1_O Q2_O Q3_O = {
+     CASE (
+        TRN_Z$, DELAY(-1,14NS,38NS),
+        TRN_$Z, DELAY(-1,17NS,38NS),
+       READ   , DELAY(-1,21NS,49NS),
+       DATA   , DELAY(-1,27NS,63NS),
+       WRITEEN, DELAY(-1,28NS,63NS),
+       DELAY(-1,28NS,63NS)
+       )
+     }
+
+ WIDTH:
+   NODE      = WEBAR
+   MIN_LO    = 20NS
+ SETUP_HOLD:
+   DATA(4)   = D0 D1 D2 D3
+   CLOCK LH  = WEBAR
+   SETUPTIME = 15NS
+   HOLDTIME  =  5NS
+ SETUP_HOLD:
+   DATA(2)   = WA WB
+   CLOCK HL  = WEBAR
+   SETUPTIME = 15NS
+   HOLDTIME  = .1NS 	   	;WA,WB MUST BE STABLE WHILE WEBAR IS LOW
+ SETUP_HOLD:
+   DATA(2)   = WA WB
+   CLOCK LH  = WEBAR
+   SETUPTIME = .1NS		    ;WA,WB MUST BE STABLE WHILE WEBAR IS LOW
+   HOLDTIME  = 5NS
+ GENERAL:
+   WHEN      = { WEBAR!='1 & (CHANGED(WA,0NS) | CHANGED(WB,0NS)) }
+   MESSAGE   = "WA AND WB MUST BE STABLE WHILE WEBAR IS LOW"
*
.ENDS
*
*$
*---------
* 74HC677 12-BIT ADDRESS COMPARATORS
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, 1989, TI
* NH 8/19/92        REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74HC677 A1_I A2_I A3_I A4_I A5_I A6_I A7_I A8_I A9_I A10_I A11_I A12_I
+ A13_I A14_I A15_I A16_I GBAR_I P3_I P2_I P1_I P0_I Y_O
+ OPTIONAL: DPWR = $G_DPWR DGND = $G_DGND
+ PARAMS: MNTYMXDLY = 0 IO_LEVEL = 0
*
UHC677LOG LOGICEXP(21,22) DPWR DGND
+ A1_I A2_I A3_I A4_I A5_I A6_I A7_I A8_I A9_I A10_I A11_I A12_I A13_I A14_I
+  A15_I A16_I P0_I P1_I P2_I P3_I GBAR_I
+ A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15 A16 P0 P1 P2 P3 GBAR Y
+ D0_GATE IO_HC IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
+   A1   = { A1_I }
+   A2   = { A2_I }
+   A3   = { A3_I }
+   A4   = { A4_I }
+   A5   = { A5_I }
+   A6   = { A6_I }
+   A7   = { A7_I }
+   A8   = { A8_I }
+   A9   = { A9_I }
+   A10  = { A10_I }
+   A11  = { A11_I }
+   A12  = { A12_I }
+   A13  = { A13_I }
+   A14  = { A14_I }
+   A15  = { A15_I }
+   A16  = { A16_I }
+   P0   = { P0_I }
+   P1   = { P1_I }
+   P2   = { P2_I }
+   P3   = { P3_I }
+   GBAR = { GBAR_I }
+
* INTERMEDIATE TERMS
+   P0BAR = { ~P0 }
+   P1BAR = { ~P1 }
+   P2BAR = { ~P2 }
+   P3BAR = { ~P3 }
+   ZERO  = { P2BAR & P1BAR & P0BAR }
+   ONE   = { P2BAR & P1BAR & P0 }
+   TWO   = { P2BAR & P1 & P0BAR }
+   THREE = { P2BAR & P1 & P0 }
+   FOUR  = { P2 & P1BAR & P0BAR }
+   FIVE  = { P2 & P1BAR & P0 }
+   SIX   = { P2 & P1 & P0BAR }
+   SEVEN = { P2 & P1 & P0 }
+   OUT1  = { ~(P3BAR & ZERO) }
+   OUT2  = { ~(P3BAR & ONE) & OUT1 }
+   OUT3  = { ~(P3BAR & TWO) & OUT2 }
+   OUT4  = { ~(P3BAR & THREE) & OUT3 }
+   OUT5  = { ~(P3BAR & FOUR) & OUT4 }
+   OUT6  = { ~(P3BAR & FIVE) & OUT5 }
+   OUT7  = { ~(P3BAR & SIX) & OUT6 }
+   OUT8  = { ~(P3BAR & SEVEN) & OUT7 }
+   OUT9  = { ~(P3 & ZERO) & P3 & OUT8 }
+   OUT10 = { ~(P3 & ONE) & OUT9 }
+   OUT11 = { ~(P3 & TWO) & OUT10 }
+   OUT12 = { ~(P3 & THREE) & OUT11 }
+   OUT13 = { ~(P3 & FOUR) & OUT12 }
+   OUT14 = { ~(P3 & FIVE) & OUT13 }
+   OUT15 = { ~(P3 & SIX) & OUT14 }
+   AND1_2   = { ~GBAR & (OUT1 ^ A1) & (OUT2 ^ A2) }
+   AND3_5   = { (OUT3 ^ A3) & (OUT4 ^ A4) & (OUT5 ^ A5) }
+   AND6_8   = { (OUT6 ^ A6) & (OUT7 ^ A7) & (OUT8 ^ A8) }
+   AND9_11  = { (OUT9 ^ A9) & (OUT10 ^ A10) & (OUT11 ^ A11) }
+   AND12_14 = { (OUT12 ^ A12) & (OUT13 ^ A13) & (OUT14 ^ A14) }
+   AND15_16 = { (OUT15 ^ A15) & A16 }
+
* OUTPUT
+   Y = { ~(AND1_2 & AND3_5 & AND6_8 & AND9_11 & AND12_14 & AND15_16) }
*
UHC677DLY PINDLY (1,0,21) DPWR DGND
+ Y
+ A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15 A16 P0 P1 P2 P3 GBAR
+ Y_O
+ IO_HC
+ MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+
+ BOOLEAN:
+   ANY_CH_A = { CHANGED(A1,0)  | CHANGED(A2,0)  | CHANGED(A3,0)  |
+                CHANGED(A4,0)  | CHANGED(A5,0)  | CHANGED(A6,0)  |
+                CHANGED(A7,0)  | CHANGED(A8,0)  | CHANGED(A9,0)  |
+                CHANGED(A10,0) | CHANGED(A11,0) | CHANGED(A12,0) |
+                CHANGED(A13,0) | CHANGED(A14,0) | CHANGED(A15,0) |
+                CHANGED(A16,0) }
+   ANY_CH_P = { CHANGED(P0,0) | CHANGED(P1,0) | CHANGED(P2,0) | CHANGED(P3,0) }
+   ENABLE = { GBAR!='1 }
+
+ PINDLY:
+   Y_O = {
+     CASE (
+       ANY_CH_P & ENABLE , DELAY(-1,50NS,156NS),
+       ANY_CH_A & ENABLE , DELAY(-1,18NS,37NS),
+       CHANGED(GBAR,0) , DELAY(-1,14NS,31NS),
+       DELAY(-1,51NS,157NS)                    ;DEFAULT
+       )
+     }
*
.ENDS
*
*$
*---------
* 74HC678 12-BIT ADDRESS COMPARATORS
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, 1989, TI
* NH 8/19/92        REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74HC678 A1_I A2_I A3_I A4_I A5_I A6_I A7_I A8_I A9_I A10_I A11_I A12_I
+ A13_I A14_I A15_I A16_I C_I P3_I P2_I P1_I P0_I Y_O
+ OPTIONAL: DPWR = $G_DPWR DGND = $G_DGND
+ PARAMS: MNTYMXDLY = 0 IO_LEVEL = 0
*
UHC678LOG LOGICEXP(21,22) DPWR DGND
+ A1_I A2_I A3_I A4_I A5_I A6_I A7_I A8_I A9_I A10_I A11_I A12_I A13_I A14_I
+  A15_I A16_I P0_I P1_I P2_I P3_I C_I
+ A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15 A16 P0 P1 P2 P3 C DY
+ D0_GATE IO_HC IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
+   A1   = { A1_I }
+   A2   = { A2_I }
+   A3   = { A3_I }
+   A4   = { A4_I }
+   A5   = { A5_I }
+   A6   = { A6_I }
+   A7   = { A7_I }
+   A8   = { A8_I }
+   A9   = { A9_I }
+   A10  = { A10_I }
+   A11  = { A11_I }
+   A12  = { A12_I }
+   A13  = { A13_I }
+   A14  = { A14_I }
+   A15  = { A15_I }
+   A16  = { A16_I }
+   P0   = { P0_I }
+   P1   = { P1_I }
+   P2   = { P2_I }
+   P3   = { P3_I }
+   C = { C_I }
+
* INTERMEDIATE TERMS
+   P0BAR = { ~P0 }
+   P1BAR = { ~P1 }
+   P2BAR = { ~P2 }
+   P3BAR = { ~P3 }
+   ZERO  = { P2BAR & P1BAR & P0BAR }
+   ONE   = { P2BAR & P1BAR & P0 }
+   TWO   = { P2BAR & P1 & P0BAR }
+   THREE = { P2BAR & P1 & P0 }
+   FOUR  = { P2 & P1BAR & P0BAR }
+   FIVE  = { P2 & P1BAR & P0 }
+   SIX   = { P2 & P1 & P0BAR }
+   SEVEN = { P2 & P1 & P0 }
+   OUT1  = { ~(P3BAR & ZERO) }
+   OUT2  = { ~(P3BAR & ONE) & OUT1 }
+   OUT3  = { ~(P3BAR & TWO) & OUT2 }
+   OUT4  = { ~(P3BAR & THREE) & OUT3 }
+   OUT5  = { ~(P3BAR & FOUR) & OUT4 }
+   OUT6  = { ~(P3BAR & FIVE) & OUT5 }
+   OUT7  = { ~(P3BAR & SIX) & OUT6 }
+   OUT8  = { ~(P3BAR & SEVEN) & OUT7 }
+   OUT9  = { ~(P3 & ZERO) & P3 & OUT8 }
+   OUT10 = { ~(P3 & ONE) & OUT9 }
+   OUT11 = { ~(P3 & TWO) & OUT10 }
+   OUT12 = { ~(P3 & THREE) & OUT11 }
+   OUT13 = { ~(P3 & FOUR) & OUT12 }
+   OUT14 = { ~(P3 & FIVE) & OUT13 }
+   OUT15 = { ~(P3 & SIX) & OUT14 }
+   AND1_2   = { (OUT1 ^ A1) & (OUT2 ^ A2) }
+   AND3_5   = { (OUT3 ^ A3) & (OUT4 ^ A4) & (OUT5 ^ A5) }
+   AND6_8   = { (OUT6 ^ A6) & (OUT7 ^ A7) & (OUT8 ^ A8) }
+   AND9_11  = { (OUT9 ^ A9) & (OUT10 ^ A10) & (OUT11 ^ A11) }
+   AND12_14 = { (OUT12 ^ A12) & (OUT13 ^ A13) & (OUT14 ^ A14) }
+   AND15_16 = { (OUT15 ^ A15) & A16 }
+
* OUTPUT
+   DY = { (AND1_2 & AND3_5 & AND6_8 & AND9_11 & AND12_14 & AND15_16) }
*
U1 DLTCH(1) DPWR DGND $D_HI $D_HI C DY $D_NC Y D0_GFF IO_HC
*
UHC678DLY PINDLY (1,0,21) DPWR DGND
+ Y
+ A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15 A16 P0 P1 P2 P3 C
+ Y_O
+ IO_HC
+ MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+
+ BOOLEAN:
+   ANY_CH_A = { CHANGED(A1,0)  | CHANGED(A2,0)  | CHANGED(A3,0)  |
+                CHANGED(A4,0)  | CHANGED(A5,0)  | CHANGED(A6,0)  |
+                CHANGED(A7,0)  | CHANGED(A8,0)  | CHANGED(A9,0)  |
+                CHANGED(A10,0) | CHANGED(A11,0) | CHANGED(A12,0) |
+                CHANGED(A13,0) | CHANGED(A14,0) | CHANGED(A15,0) |
+                CHANGED(A16,0) }
+   ANY_CH_P = { CHANGED(P0,0) | CHANGED(P1,0) | CHANGED(P2,0) | CHANGED(P3,0) }
+   ENABLE = { C!='0 }
+
+ PINDLY:
+   Y_O = {
+     CASE (
+       ANY_CH_P & ENABLE , DELAY(-1,50NS,156NS),
+       ANY_CH_A & ENABLE , DELAY(-1,23NS,44NS),
+       CHANGED(C,0) , DELAY(-1,19NS,37NS),
+       DELAY(-1,51NS,157NS)                    ;DEFAULT
+       )
+     }
+
+ WIDTH:
+   NODE = C
+   MIN_HI = 19NS
+
+ SETUP_HOLD:
+   DATA(16) = A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15 A16
+   CLOCK HL = C
+   SETUPTIME = 25NS
+   HOLDTIME = 5NS
+
+ SETUP_HOLD:
+   DATA(4) = P0 P1 P2 P3
+   CLOCK HL = C
+   SETUPTIME = 125NS
+   HOLDTIME = 5NS
*
.ENDS
*
*$
*---------
* 74HC679 12-BIT ADDRESS COMPARATORS
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, 1989, TI
* NH 8/11/92        REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74HC679 A1_I A2_I A3_I A4_I A5_I A6_I A7_I A8_I A9_I A10_I A11_I A12_I
+               P0_I P1_I P2_I P3_I GBAR_I Y_O
+ OPTIONAL:  DPWR = $G_DPWR   DGND = $G_DGND
+ PARAMS:    MNTYMXDLY = 0    IO_LEVEL = 0
*
UHC679LOG LOGICEXP(17,18) DPWR DGND
+ A1_I A2_I A3_I A4_I A5_I A6_I A7_I A8_I A9_I A10_I A11_I A12_I P0_I P1_I
+  P2_I P3_I GBAR_I
+ A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 P0 P1 P2 P3 GBAR Y
+ D0_GATE IO_HC IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
+   A1   = { A1_I }
+   A2   = { A2_I }
+   A3   = { A3_I }
+   A4   = { A4_I }
+   A5   = { A5_I }
+   A6   = { A6_I }
+   A7   = { A7_I }
+   A8   = { A8_I }
+   A9   = { A9_I }
+   A10  = { A10_I }
+   A11  = { A11_I }
+   A12  = { A12_I }
+   P0   = { P0_I }
+   P1   = { P1_I }
+   P2   = { P2_I }
+   P3   = { P3_I }
+   GBAR = { GBAR_I }
+
* INTERMEDIATE TERMS
+   P0BAR = { ~P0 }
+   P1BAR = { ~P1 }
+   P2BAR = { ~P2 }
+   P3BAR = { ~P3 }
+   ZERO  = { P2BAR & P1BAR & P0BAR }
+   ONE   = { P2BAR & P1BAR & P0 }
+   TWO   = { P2BAR & P1 & P0BAR }
+   THREE = { P2BAR & P1 & P0 }
+   FOUR  = { P2 & P1BAR & P0BAR }
+   FIVE  = { P2 & P1BAR & P0 }
+   SIX   = { P2 & P1 & P0BAR }
+   SEVEN = { P2 & P1 & P0 }
+   OUT1  = { ~(P3BAR & ZERO) }
+   OUT2  = { ~(P3BAR & ONE) & OUT1 }
+   OUT3  = { ~(P3BAR & TWO) & OUT2 }
+   OUT4  = { ~(P3BAR & THREE) & OUT3 }
+   OUT5  = { ~(P3BAR & FOUR) & OUT4 }
+   OUT6  = { ~(P3BAR & FIVE) & OUT5 }
+   OUT7  = { ~(P3BAR & SIX) & OUT6 }
+   OUT8  = { ~(P3BAR & SEVEN) & OUT7 }
+   OUT9  = { ~(P3 & ZERO) & P3 & OUT8 }
+   OUT10 = { ~(P3 & ONE) & OUT9 }
+   OUT11 = { ~(P3 & TWO) & OUT10 }
+   OUT12 = { ~(P3 & THREE) & OUT11 }
+   OUT13 = { ~(P3 & FOUR) & OUT12 }
+   OUT14 = { ~(P3 & FIVE) & OUT13 }
+   OUT15 = { ~(P3 & SIX) & OUT14 }
+   OUT16 = { ~(P3 & SEVEN) }
+   AND1_2  = { ~GBAR & (OUT1 ^ A1) & (OUT2 ^ A2) }
+   AND3_5  = { (OUT3 ^ A3) & (OUT4 ^ A4) & (OUT5 ^ A5) }
+   AND6_8  = { (OUT6 ^ A6) & (OUT7 ^ A7) & (OUT8 ^ A8) }
+   AND9_11 = { (OUT9 ^ A9) & (OUT10 ^ A10) & (OUT11 ^ A11) }
+   AND12   = { (OUT12 ^ A12) & (OUT13 ^ OUT16) & (OUT14 ^ OUT16) }
+
* OUTPUT
+   Y = { ~( (AND1_2 & AND3_5 & AND6_8) & (AND9_11 & AND12 & (OUT15 ^ OUT16)) ) }
*
UHC679DLY PINDLY (1,0,17) DPWR DGND
+ Y
+ A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 P0 P1 P2 P3 GBAR
+ Y_O
+ IO_HC
+ MNTYMXDLY = {MNTYMXDLY}   IO_LEVEL = {IO_LEVEL}
+
+ BOOLEAN:
+   ANY_CH_A = { CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0) | CHANGED(A4,0) |
+                CHANGED(A5,0) | CHANGED(A6,0) | CHANGED(A7,0) | CHANGED(A8,0) |
+                CHANGED(A9,0) | CHANGED(A10,0)| CHANGED(A11,0)| CHANGED(A12,0)}
+   ANY_CH_P = { CHANGED(P0,0) | CHANGED(P1,0) | CHANGED(P2,0) | CHANGED(P3,0) }
+   ENABLE = { GBAR!='1 }
+
+ PINDLY:
+   Y_O = {
+     CASE (
+       ANY_CH_P & ENABLE , DELAY(-1,37NS,75NS),
+       ANY_CH_A & ENABLE , DELAY(-1,21NS,40NS),
+       CHANGED(GBAR,0) , DELAY(-1,15NS,31NS),
+       DELAY(-1,38NS,76NS)                    ;DEFAULT
+       )
+     }
*
.ENDS
*
*$
*---------
* 74HC680 12-BIT ADDRESS COMPARATORS
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, 1989, TI
* NH 8/18/92        REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74HC680 A1_I A2_I A3_I A4_I A5_I A6_I A7_I A8_I A9_I A10_I A11_I A12_I
+               P0_I P1_I P2_I P3_I C_I Y_O
+ OPTIONAL:  DPWR = $G_DPWR DGND = $G_DGND
+ PARAMS:    MNTYMXDLY = 0 IO_LEVEL = 0
*
UHC680LOG LOGICEXP(17,18) DPWR DGND
+ A1_I A2_I A3_I A4_I A5_I A6_I A7_I A8_I A9_I A10_I A11_I A12_I P0_I P1_I
+  P2_I P3_I C_I
+ A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 P0 P1 P2 P3 C DY
+ D0_GATE IO_HC IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
+   A1   = { A1_I }
+   A2   = { A2_I }
+   A3   = { A3_I }
+   A4   = { A4_I }
+   A5   = { A5_I }
+   A6   = { A6_I }
+   A7   = { A7_I }
+   A8   = { A8_I }
+   A9   = { A9_I }
+   A10  = { A10_I }
+   A11  = { A11_I }
+   A12  = { A12_I }
+   P0   = { P0_I }
+   P1   = { P1_I }
+   P2   = { P2_I }
+   P3   = { P3_I }
+   C = { C_I }
+
* INTERMEDIATE TERMS
+   P0BAR = { ~P0 }
+   P1BAR = { ~P1 }
+   P2BAR = { ~P2 }
+   P3BAR = { ~P3 }
+   ZERO  = { P2BAR & P1BAR & P0BAR }
+   ONE   = { P2BAR & P1BAR & P0 }
+   TWO   = { P2BAR & P1 & P0BAR }
+   THREE = { P2BAR & P1 & P0 }
+   FOUR  = { P2 & P1BAR & P0BAR }
+   FIVE  = { P2 & P1BAR & P0 }
+   SIX   = { P2 & P1 & P0BAR }
+   SEVEN = { P2 & P1 & P0 }
+   OUT1  = { ~(P3BAR & ZERO) }
+   OUT2  = { ~(P3BAR & ONE) & OUT1 }
+   OUT3  = { ~(P3BAR & TWO) & OUT2 }
+   OUT4  = { ~(P3BAR & THREE) & OUT3 }
+   OUT5  = { ~(P3BAR & FOUR) & OUT4 }
+   OUT6  = { ~(P3BAR & FIVE) & OUT5 }
+   OUT7  = { ~(P3BAR & SIX) & OUT6 }
+   OUT8  = { ~(P3BAR & SEVEN) & OUT7 }
+   OUT9  = { ~(P3 & ZERO) & P3 & OUT8 }
+   OUT10 = { ~(P3 & ONE) & OUT9 }
+   OUT11 = { ~(P3 & TWO) & OUT10 }
+   OUT12 = { ~(P3 & THREE) & OUT11 }
+   OUT13 = { ~(P3 & FOUR) & OUT12 }
+   OUT14 = { ~(P3 & FIVE) & OUT13 }
+   OUT15 = { ~(P3 & SIX) & OUT14 }
+   OUT16 = { ~(P3 & SEVEN) }
+   AND1_2  = { (OUT1 ^ A1) & (OUT2 ^ A2) }
+   AND3_5  = { (OUT3 ^ A3) & (OUT4 ^ A4) & (OUT5 ^ A5) }
+   AND6_8  = { (OUT6 ^ A6) & (OUT7 ^ A7) & (OUT8 ^ A8) }
+   AND9_11 = { (OUT9 ^ A9) & (OUT10 ^ A10) & (OUT11 ^ A11) }
+   AND12   = { (OUT12 ^ A12) & (OUT13 ^ OUT16) & (OUT14 ^ OUT16) }
+
* OUTPUT
+   DY = { ((AND1_2 & AND3_5 & AND6_8) & (AND9_11 & AND12 & (OUT15 ^ OUT16))) }
*
U1 DLTCH(1) DPWR DGND $D_HI $D_HI C DY $D_NC Y D0_GFF IO_HC
*
UHC680DLY PINDLY (1,0,17) DPWR DGND
+ Y
+ A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 P0 P1 P2 P3 C
+ Y_O
+ IO_HC
+ MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+
+ BOOLEAN:
+   ANY_CH_A = { CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0) | CHANGED(A4,0) |
+                CHANGED(A5,0) | CHANGED(A6,0) | CHANGED(A7,0) | CHANGED(A8,0) |
+                CHANGED(A9,0) | CHANGED(A10,0)| CHANGED(A11,0)| CHANGED(A12,0)}
+   ANY_CH_P = { CHANGED(P0,0) | CHANGED(P1,0) | CHANGED(P2,0) | CHANGED(P3,0) }
+   ENABLE = { C!='0 }
+
+ PINDLY:
+   Y_O = {
+     CASE (
+       ANY_CH_P & ENABLE , DELAY(-1,37NS,75NS),
+       ANY_CH_A & ENABLE , DELAY(-1,21NS,40NS),
+       CHANGED_LH(C,0) , DELAY(-1,15NS,31NS),
+       DELAY(-1,38NS,76NS)                    ;DEFAULT
+       )
+     }
 
+
+ WIDTH:
+   NODE = C
+   MIN_HI = 19NS
+
+ SETUP_HOLD:
+   DATA(12) A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12
+   CLOCK HL = C
+   SETUPTIME = 25NS
+   HOLDTIME = 5NS
+
+ SETUP_HOLD:
+   DATA(4) P0 P1 P2 P3
+   CLOCK HL = C
+   SETUPTIME = 124NS
+   HOLDTIME = 5NS
*
.ENDS
*
*$
*------------------------------------------------------------------------
* 74HC684 8-BIT MAGNITUDE COMPARATORS
*
* THE HIGH-SPEED CMOS LOGIC DATA BOOK, 1988, TI
* KN   8-20-92      REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74HC684 P7_I P6_I P5_I P4_I P3_I P2_I P1_I P0_I
+ Q7_I Q6_I Q5_I Q4_I Q3_I Q2_I Q1_I Q0_I  PEQBAR_O PGQBAR_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
UHC684LOG LOGICEXP(16,18) DPWR DGND
+ P7_I P6_I P5_I P4_I P3_I P2_I P1_I P0_I
+ Q7_I Q6_I Q5_I Q4_I Q3_I Q2_I Q1_I Q0_I
+ P7 P6 P5 P4 P3 P2 P1 P0  Q7 Q6 Q5 Q4 Q3 Q2 Q1 Q0  PEQBAR PGQBAR
+ D0_GATE
+ IO_HC IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
*   BUFFER:
+   P7 = { P7_I }
+   P6 = { P6_I }
+   P5 = { P5_I }
+   P4 = { P4_I }
+   P3 = { P3_I }
+   P2 = { P2_I }
+   P1 = { P1_I }
+   P0 = { P0_I }
+   Q7 = { Q7_I }
+   Q6 = { Q6_I }
+   Q5 = { Q5_I }
+   Q4 = { Q4_I }
+   Q3 = { Q3_I }
+   Q2 = { Q2_I }
+   Q1 = { Q1_I }
+   Q0 = { Q0_I }
+
*   INTERMEDIATE TERMS:
+   PQ7    = { ~(P7 ^ Q7) }
+   PQ6    = { ~(P6 ^ Q6) }
+   PQ5    = { ~(P5 ^ Q5) }
+   PQ4    = { ~(P4 ^ Q4) }
+   PQ3    = { ~(P3 ^ Q3) }
+   PQ2    = { ~(P2 ^ Q2) }
+   PQ1    = { ~(P1 ^ Q1) }
+   PQ0    = { ~(P0 ^ Q0) }
+   PQ67   = { PQ6 & PQ7  }
+   PQ57   = { PQ5 & PQ67 }
+   PQ47   = { PQ4 & PQ57 }
+   PQ37   = { PQ3 & PQ47 }
+   PQ27   = { PQ2 & PQ37 }
+   PQ17   = { PQ1 & PQ27 }
+
*   OUTPUT ASSIGNMENTS:
+   PEQBAR = { ~(PQ7 & PQ6 & PQ5 & PQ4 & PQ3 & PQ2 & PQ1 & PQ0) }
+   PGQBAR = { ~((PQ17 & ~Q0 & P0) | (PQ27 & ~Q1 & P1) | (PQ37 & ~Q2 & P2) |
+                (PQ47 & ~Q3 & P3) | (PQ57 & ~Q4 & P4) | (PQ67 & ~Q5 & P5) |
+                (PQ7 & ~Q6 & P6)  | (~Q7 & P7)) }
*
UHC684DLY PINDLY (2,0,16) DPWR DGND
+ PEQBAR PGQBAR
+ P7 P6 P5 P4 P3 P2 P1 P0 Q7 Q6 Q5 Q4 Q3 Q2 Q1 Q0
+ PEQBAR_O PGQBAR_O
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+  DATA_CHANGE = { CHANGED(P7,0) | CHANGED(P6,0) | CHANGED(P5,0) | CHANGED(P4,0)
+             | CHANGED(P3,0) | CHANGED(P2,0) | CHANGED(P1,0) | CHANGED(P0,0)
+             | CHANGED(Q7,0) | CHANGED(Q6,0) | CHANGED(Q5,0) | CHANGED(Q4,0)
+             | CHANGED(Q3,0) | CHANGED(Q2,0) | CHANGED(Q1,0) | CHANGED(Q0,0) }
+
+ PINDLY:
+   PEQBAR_O PGQBAR_O =  {
+     CASE(
+       DATA_CHANGE, DELAY(-1,26NS,69NS),
+                    DELAY(-1,27NS,70NS)  ;DEFAULT
+     )
+   }
*
.ENDS
*
*$
*---------
* 74HC688 8-BIT IDENTITY COMPARATORS
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, 1989, TI
* NH 8/21/92          REMODELED USING LOGICEXP, PINDLY, CONSTRAINT DEVICES
*
.SUBCKT 74HC688 P7_I P6_I P5_I P4_I P3_I P2_I P1_I P0_I Q7_I Q6_I Q5_I Q4_I
+ Q3_I Q2_I Q1_I Q0_I GBAR_I PEQBAR_O
+ OPTIONAL: DPWR =  $G_DPWR DGND = $G_DGND
+ PARAMS: MNTYMXDLY = 0 IO_LEVEL = 0
*
UHC688LOG LOGICEXP(17,18) DPWR DGND
+ P7_I P6_I P5_I P4_I P3_I P2_I P1_I P0_I
+   Q7_I Q6_I Q5_I Q4_I Q3_I Q2_I Q1_I Q0_I GBAR_I
+ P7 P6 P5 P4 P3 P2 P1 P0 Q7 Q6 Q5 Q4 Q3 Q2 Q1 Q0 GBAR PEQBAR
+ D0_GATE IO_HC IO_LEVEL = {IO_LEVEL}
+
+ LOGIC:
+   P7 = { P7_I }
+   P6 = { P6_I }
+   P5 = { P5_I }
+   P4 = { P4_I }
+   P3 = { P3_I }
+   P2 = { P2_I }
+   P1 = { P1_I }
+   P0 = { P0_I }
+   Q7 = { Q7_I }
+   Q6 = { Q6_I }
+   Q5 = { Q5_I }
+   Q4 = { Q4_I }
+   Q3 = { Q3_I }
+   Q2 = { Q2_I }
+   Q1 = { Q1_I }
+   Q0 = { Q0_I }
+   GBAR = { GBAR_I }
+
+   PEQ7 = { ~(P7 ^ Q7) }
+   PEQ6 = { ~(P6 ^ Q6) }
+   PEQ5 = { ~(P5 ^ Q5) }
+   PEQ4 = { ~(P4 ^ Q4) }
+   PEQ3 = { ~(P3 ^ Q3) }
+   PEQ2 = { ~(P2 ^ Q2) }
+   PEQ1 = { ~(P1 ^ Q1) }
+   PEQ0 = { ~(P0 ^ Q0) }
+   AND0_2 = { PEQ0 & PEQ1 & PEQ2 }
+   AND3_5 = { PEQ3 & PEQ4 & PEQ5 }
+   AND6_7 = { PEQ6 & PEQ7 }
+
+   PEQBAR = { ~(AND0_2 & AND3_5 & AND6_7 & ~GBAR) }
*
UHC688DLY PINDLY (1,0,17) DPWR DGND
+ PEQBAR
+ GBAR P7 P6 P5 P4 P3 P2 P1 P0 Q7 Q6 Q5 Q4 Q3 Q2 Q1 Q0
+ PEQBAR_O
+ IO_HC MNTYMXDLY = {MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+
+ BOOLEAN:
+   ANY_CH_P = { CHANGED(P7,0) | CHANGED(P6,0) | CHANGED(P5,0) | CHANGED(P4,0) |
+                CHANGED(P3,0) | CHANGED(P2,0) | CHANGED(P1,0) | CHANGED(P0,0) }
+   ANY_CH_Q = { CHANGED(Q7,0) | CHANGED(Q6,0) | CHANGED(Q5,0) | CHANGED(Q4,0) |
+                CHANGED(Q3,0) | CHANGED(Q2,0) | CHANGED(Q1,0) | CHANGED(Q0,0) }
+   ENABLE = { GBAR!='1 }
+
+ PINDLY:
+   PEQBAR_O = {
+     CASE(
+       (ANY_CH_P | ANY_CH_Q) & ENABLE, DELAY(-1,30NS,53NS),
+       CHANGED(GBAR,0), DELAY(-1,16NS,30NS),
+       DELAY(-1,31NS,54NS)
+       )
+     }
*
.ENDS
*
*$
*---------
* 74HC804  Hex 2-Input NAND Drivers
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	7/27/89 	Update interface and model names
*
.subckt 74HC804  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nand(2) DPWR DGND
+	A B   Y 
+	D_HC804 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC804 ugate (
+	tplhmn=12ns	tplhmx=25ns
+	tphlmn=12ns	tphlmx=25ns
+	)
*$
*---------
* 74HC805  Hex 2-Input NOR Drivers
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	7/27/89 	Update interface and model names
*
.subckt 74HC805  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nor(2) DPWR DGND
+	A B   Y 
+	D_HC805 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC805 ugate (
+	tplhmn=10ns	tplhmx=24ns
+	tphlmn=10ns	tphlmx=24ns
+	)
*$
*---------
* 74HC808  Hex 2-Input AND Drivers
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	7/27/89 	Update interface and model names
*
.subckt 74HC808  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 and(2) DPWR DGND
+	A B   Y 
+	D_HC808 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC808 ugate (
+	tplhmn=10ns	tplhmx=25ns
+	tphlmn=10ns	tphlmx=25ns
+	)
*$
*---------
* 74HC832  Hex 2-Input OR Drivers
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* atl 	7/28/89 	Update interface and model names
*
.subckt 74HC832  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 or(2) DPWR DGND
+	A B   Y 
+	D_HC832 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC832 ugate (
+	tplhmn=10ns	tplhmx=25ns
+	tphlmn=10ns	tphlmx=25ns
+	)
*$
*-------------------------------------------------------------------------
* 74HC4002 Dual 4-Input Positive-Nor Gate
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	09/14/89	Update interface and model names
*
.subckt 74HC4002  A B C D Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nor(4) DPWR DGND
+	A B C D   Y 
+	D_HC4002 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC4002 ugate (
+	tphlty=12ns	tphlmx=28ns
+	tplhty=12ns	tplhmx=28ns
+	)
*$
*---------
* 74HC4020  COUNTER BINARY 14-BIT, ASYNCHRONOUS
*
* HIGH SPEED CMOS LOGIC FAMILY BOOK, 1991, PHILIPS SEMICONDUCTORS
* JLS   7-6-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74HC4020   CLR_I CLK_I
+ QA_O QD_O QE_O QF_O QG_O QH_O QI_O QJ_O QK_O QL_O QM_O QN_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1  JKFF(1) DPWR DGND
+ $D_HI CLRBAR CLK   $D_HI $D_HI   QA $D_NC
+ D0_EFF  IO_HC
U2  JKFF(1) DPWR DGND
+ $D_HI CLRBAR QA    $D_HI $D_HI   QB $D_NC
+ D0_EFF  IO_HC
U3  JKFF(1) DPWR DGND
+ $D_HI CLRBAR QB    $D_HI $D_HI   QC $D_NC
+ D0_EFF  IO_HC
U4  JKFF(1) DPWR DGND
+ $D_HI CLRBAR QC    $D_HI $D_HI   QD $D_NC
+ D0_EFF  IO_HC
U5  JKFF(1) DPWR DGND
+ $D_HI CLRBAR QD    $D_HI $D_HI   QE $D_NC
+ D0_EFF  IO_HC
U6  JKFF(1) DPWR DGND
+ $D_HI CLRBAR QE    $D_HI $D_HI   QF $D_NC
+ D0_EFF  IO_HC
U7  JKFF(1) DPWR DGND
+ $D_HI CLRBAR QF    $D_HI $D_HI   QG $D_NC
+ D0_EFF  IO_HC
U8  JKFF(1) DPWR DGND
+ $D_HI CLRBAR QG    $D_HI $D_HI   QH $D_NC
+ D0_EFF  IO_HC
U9  JKFF(1) DPWR DGND
+ $D_HI CLRBAR QH    $D_HI $D_HI   QI $D_NC
+ D0_EFF  IO_HC
U10 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QI    $D_HI $D_HI   QJ $D_NC
+ D0_EFF  IO_HC
U11 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QJ    $D_HI $D_HI   QK $D_NC
+ D0_EFF  IO_HC
U12 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QK    $D_HI $D_HI   QL $D_NC
+ D0_EFF  IO_HC
U13 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QL    $D_HI $D_HI   QM $D_NC
+ D0_EFF  IO_HC
U14 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QM    $D_HI $D_HI   QN $D_NC
+ D0_EFF  IO_HC
U15 BUFA(2) DPWR DGND
+ CLK_I CLR_I
+ CLK   CLR
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
U16 INV     DPWR DGND
+ CLR CLRBAR
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
*
UHC4020DLY PINDLY (12,0,2) DPWR DGND
+ QA QD QE QF QG QH QI QJ QK QL QM QN
+ CLR CLK
+ QA_O QD_O QE_O QF_O QG_O QH_O QI_O QJ_O QK_O QL_O QM_O QN_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLOCKED = { CHANGED_HL(CLK,0) }
+   CLEARED = { CHANGED_LH(CLR,0) }
+
+ PINDLY:
+   QA_O = {
+     CASE (
+       CLOCKED, DELAY(-1,14NS,35NS),
+       DELAY(-1,20NS,43NS)
+       )
+     }
+   QD_O = {
+     CASE (
+       CLEARED, DELAY(-1,20NS,43NS),
+       DELAY(-1,38NS,92NS)
+       )
+     }
+   QE_O = {
+     CASE (
+       CLEARED, DELAY(-1,20NS,43NS),
+       DELAY(-1,46NS,111NS)
+       )
+     }
+   QF_O = {
+     CASE (
+       CLEARED, DELAY(-1,20NS,43NS),
+       DELAY(-1,54NS,130NS)
+       )
+     }
+   QG_O = {
+     CASE (
+       CLEARED, DELAY(-1,20NS,43NS),
+       DELAY(-1,62NS,149NS)
+       )
+     }
+   QH_O = {
+     CASE (
+       CLEARED, DELAY(-1,20NS,43NS),
+       DELAY(-1,70NS,168NS)
+       )
+     }
+   QI_O = {
+     CASE (
+       CLEARED, DELAY(-1,20NS,43NS),
+       DELAY(-1,78NS,187NS)
+       )
+     }
+   QJ_O = {
+     CASE (
+       CLEARED, DELAY(-1,20NS,43NS),
+       DELAY(-1,86NS,206NS)
+       )
+     }
+   QK_O = {
+     CASE (
+       CLEARED, DELAY(-1,20NS,43NS),
+       DELAY(-1,94NS,225NS)
+       )
+     }
+   QL_O = {
+     CASE (
+       CLEARED, DELAY(-1,20NS,43NS),
+       DELAY(-1,102NS,244NS)
+       )
+     }
+   QM_O = {
+     CASE (
+       CLEARED, DELAY(-1,20NS,43NS),
+       DELAY(-1,110NS,263NS)
+       )
+     }
+   QN_O = {
+     CASE (
+       CLEARED, DELAY(-1,20NS,43NS),
+       DELAY(-1,118NS,282NS)
+       )
+     }
+
+ FREQ:
+   NODE           = CLK
+   MAXFREQ        = 24MEGHZ
+ WIDTH:
+   NODE           = CLK
+   MIN_LO         = 20NS
+   MIN_HI         = 20NS
+ WIDTH:
+   NODE           = CLR
+   MIN_LO         = 20NS
+ SETUP_HOLD:
+   DATA(1)        = CLR
+   CLOCK HL       = CLK
+   RELEASETIME_LH = 13NS
*
.ENDS
*
*$
*-------------------------------------------------------------------------
*  74HC4024  Asynchronous 7-Bit Binary Counter
*
*  HIGH SPEED CMOS LOGIC DATA BOOK, 1989, TI
*  tc  07/15/92  Remodeled using LOGICEXP, PINDLY, & CONSTRAINT devices
*
.SUBCKT 74HC4024 CLR_I CLK_I QA_O QB_O QC_O QD_O QE_O QF_O QG_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 JKFF(1) DPWR DGND $D_HI MR TA $D_HI $D_HI QA $D_NC
+ D0_EFF IO_HC
U2 JKFF(1) DPWR DGND $D_HI MR QA $D_HI $D_HI QB $D_NC
+ D0_EFF IO_HC
U3 JKFF(1) DPWR DGND $D_HI MR QB $D_HI $D_HI QC $D_NC
+ D0_EFF IO_HC
U4 JKFF(1) DPWR DGND $D_HI MR QC $D_HI $D_HI QD $D_NC
+ D0_EFF IO_HC
U5 JKFF(1) DPWR DGND $D_HI MR QD $D_HI $D_HI QE $D_NC
+ D0_EFF IO_HC
U6 JKFF(1) DPWR DGND $D_HI MR QE $D_HI $D_HI QF $D_NC
+ D0_EFF IO_HC
U7 JKFF(1) DPWR DGND $D_HI MR QF $D_HI $D_HI QG $D_NC
+ D0_EFF IO_HC
*
UHC4024LOG LOGICEXP(2,4) DPWR DGND
+ CLR_I CLK_I
+ CLR CLK MR TA
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLR = { CLR_I }
+   CLK = { CLK_I }
+   MR = { ~CLR }
+   TA = { MR & CLK }
*
* NOTE: Qn to Qn+1 delay is estimated to be 10ns typ. & 20ns max.
*
UHC4024DLY PINDLY (7,0,2) DPWR DGND
+ QA QB QC QD QE QF QG
+ CLR CLK
+ QA_O QB_O QC_O QD_O QE_O QF_O QG_O
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLEAR = { CHANGED_LH(CLR,0) }
+ PINDLY:
+   QA_O = {
+     CASE(
+       CHANGED_HL(CLK,0), DELAY(-1,16NS,30NS),
+       DELAY(-1,17NS,32NS)
+       )
+     }
+   QB_O = {
+     CASE(
+       CLEAR, DELAY(-1,17NS,32NS),
+       DELAY(-1,26NS,50NS)
+       )
+     }
+   QC_O = {
+     CASE(
+       CLEAR, DELAY(-1,17NS,32NS),
+       DELAY(-1,36NS,70NS)
+       )
+     }
+   QD_O = {
+     CASE(
+       CLEAR, DELAY(-1,17NS,32NS),
+       DELAY(-1,46NS,90NS)
+       )
+     }
+   QE_O = {
+     CASE(
+       CLEAR, DELAY(-1,17NS,32NS),
+       DELAY(-1,56NS,110NS)
+       )
+     }
+   QF_O = {
+     CASE(
+       CLEAR, DELAY(-1,17NS,32NS),
+       DELAY(-1,66NS,130NS)
+       )
+     }
+   QG_O = {
+     CASE(
+       CLEAR, DELAY(-1,17NS,32NS),
+       DELAY(-1,76NS,150NS)
+       )
+     }
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 22MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 23NS
+   MIN_HI = 23NS
+ WIDTH:
+   NODE = CLR
+   MIN_HI = 20NS
+ SETUP_HOLD:
+   DATA(1) = CLR
+   CLOCK HL = CLK
+   RELEASETIME_HL = 20NS
*
.ENDS
*
*$
*---------
* 74HC4040  COUNTER BINARY 12-BIT, ASYNCHRONOUS
*
* HIGH SPEED CMOS LOGIC FAMILY BOOK, 1991, PHILIPS SEMICONDUCTORS
* JLS   7-6-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74HC4040   CLR_I CLK_I
+ QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O QI_O QJ_O QK_O QL_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1  JKFF(1) DPWR DGND
+ $D_HI CLRBAR CLK   $D_HI $D_HI   QA $D_NC
+ D0_EFF  IO_HC
U2  JKFF(1) DPWR DGND
+ $D_HI CLRBAR QA    $D_HI $D_HI   QB $D_NC
+ D0_EFF  IO_HC
U3  JKFF(1) DPWR DGND
+ $D_HI CLRBAR QB    $D_HI $D_HI   QC $D_NC
+ D0_EFF  IO_HC
U4  JKFF(1) DPWR DGND
+ $D_HI CLRBAR QC    $D_HI $D_HI   QD $D_NC
+ D0_EFF  IO_HC
U5  JKFF(1) DPWR DGND
+ $D_HI CLRBAR QD    $D_HI $D_HI   QE $D_NC
+ D0_EFF  IO_HC
U6  JKFF(1) DPWR DGND
+ $D_HI CLRBAR QE    $D_HI $D_HI   QF $D_NC
+ D0_EFF  IO_HC
U7  JKFF(1) DPWR DGND
+ $D_HI CLRBAR QF    $D_HI $D_HI   QG $D_NC
+ D0_EFF  IO_HC
U8  JKFF(1) DPWR DGND
+ $D_HI CLRBAR QG    $D_HI $D_HI   QH $D_NC
+ D0_EFF  IO_HC
U9  JKFF(1) DPWR DGND
+ $D_HI CLRBAR QH    $D_HI $D_HI   QI $D_NC
+ D0_EFF  IO_HC
U10 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QI    $D_HI $D_HI   QJ $D_NC
+ D0_EFF  IO_HC
U11 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QJ    $D_HI $D_HI   QK $D_NC
+ D0_EFF  IO_HC
U12 JKFF(1) DPWR DGND
+ $D_HI CLRBAR QK    $D_HI $D_HI   QL $D_NC
+ D0_EFF  IO_HC
U13 BUFA(2) DPWR DGND
+ CLK_I CLR_I
+ CLK   CLR
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
U14 INV     DPWR DGND
+ CLR CLRBAR
+ D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
*
UHC4040DLY PINDLY (12,0,2) DPWR DGND
+ QA QB QC QD QE QF QG QH QI QJ QK QL
+ CLR CLK
+ QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O QI_O QJ_O QK_O QL_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   CLOCKED = { CHANGED_HL(CLK,0) }
+   CLEARED = { CHANGED_LH(CLR,0) }
+
+ PINDLY:
+   QA_O = {
+     CASE (
+       CLOCKED, DELAY(-1,17NS,38NS),
+       DELAY(-1,22NS,46NS)
+       )
+     }
+   QB_O = {
+     CASE (
+       CLEARED, DELAY(-1,22NS,46NS),
+       DELAY(-1,27NS,63NS)
+       )
+     }
+   QC_O = {
+     CASE (
+       CLEARED, DELAY(-1,22NS,46NS),
+       DELAY(-1,37NS,88NS)
+       )
+     }
+   QD_O = {
+     CASE (
+       CLEARED, DELAY(-1,22NS,46NS),
+       DELAY(-1,47NS,113NS)
+       )
+     }
+   QE_O = {
+     CASE (
+       CLEARED, DELAY(-1,22NS,46NS),
+       DELAY(-1,57NS,138NS)
+       )
+     }
+   QF_O = {
+     CASE (
+       CLEARED, DELAY(-1,22NS,46NS),
+       DELAY(-1,67NS,163NS)
+       )
+     }
+   QG_O = {
+     CASE (
+       CLEARED, DELAY(-1,22NS,46NS),
+       DELAY(-1,77NS,188NS)
+       )
+     }
+   QH_O = {
+     CASE (
+       CLEARED, DELAY(-1,22NS,46NS),
+       DELAY(-1,87NS,213NS)
+       )
+     }
+   QI_O = {
+     CASE (
+       CLEARED, DELAY(-1,22NS,46NS),
+       DELAY(-1,97NS,238NS)
+       )
+     }
+   QJ_O = {
+     CASE (
+       CLEARED, DELAY(-1,22NS,46NS),
+       DELAY(-1,107NS,263NS)
+       )
+     }
+   QK_O = {
+     CASE (
+       CLEARED, DELAY(-1,22NS,46NS),
+       DELAY(-1,117NS,288NS)
+       )
+     }
+   QL_O = {
+     CASE (
+       CLEARED, DELAY(-1,22NS,46NS),
+       DELAY(-1,127NS,313NS)
+       )
+     }
+
+ FREQ:
+   NODE           = CLK
+   MAXFREQ        = 24MEGHZ
+ WIDTH:
+   NODE           = CLK
+   MIN_LO         = 20NS
+   MIN_HI         = 20NS
+ WIDTH:
+   NODE           = CLR
+   MIN_LO         = 20NS
+ SETUP_HOLD:
+   DATA(1)        = CLR
+   CLOCK HL       = CLK
+   RELEASETIME_LH = 13NS
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74HC4075 Triple 3-input Or Gate
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	09/14/89	Update interface and model names
*
.subckt 74HC4075  A B C Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 or(3) DPWR DGND
+	A B C   Y 
+	D_HC4075 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC4075 ugate (
+	tphlty=11ns	tphlmx=25ns
+	tplhty=11ns	tplhmx=25ns
+	)
*$
*-------------------------------------------------------------------------
* 74HC4078A  8-input Or/Nor Gate
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	09/14/89	Update interface and model names
*
.subckt 74HC4078A  A B C D E F G H Y W
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 or(8) DPWR DGND
+	A B C D E F G H   Y1 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U2 buf DPWR DGND
+	Y1   Y 
+	D_HC4078A IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U3 inv DPWR DGND
+	Y1   W 
+	D_HC4078A IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC4078A ugate (
+	tphlty=12ns	tphlmx=33ns
+	tplhty=12ns	tplhmx=33ns
+	)
*
*$
*---------
* 74HC4514  DECODER/DEMULTIPLEXER 4-16 LINE WITH ADDRESS LATCHES
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, AUG 1989, TI
* JLS   8-6-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*    
.SUBCKT 74HC4514   LE_I GBAR_I A_I B_I C_I D_I
+ Y0_O  Y1_O  Y2_O  Y3_O  Y4_O  Y5_O Y6_O Y7_O Y8_O Y9_O
+ Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 DLTCH(4) DPWR DGND
+ $D_HI $D_HI LE
+  A     B     C     D
+ QA    QB    QC    QD
+ QABAR QBBAR QCBAR QDBAR
+ D0_GFF  IO_HC
*
UHC4514LOG LOGICEXP (14,22) DPWR DGND
+ LE_I GBAR_I A_I B_I C_I D_I QA QB QC QD QABAR QBBAR QCBAR QDBAR
+ LE   GBAR   A   B   C   D
+ Y0  Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   LE      = { LE_I }
+   GBAR    = { GBAR_I }
+   G       = { ~GBAR }
+   A       = { A_I }
+   B       = { B_I }
+   C       = { C_I }
+   D       = { D_I }
+   Y0      = { G & QDBAR & QCBAR & QBBAR & QABAR }
+   Y1      = { G & QDBAR & QCBAR & QBBAR & QA    }
+   Y2      = { G & QDBAR & QCBAR & QB    & QABAR }
+   Y3      = { G & QDBAR & QCBAR & QB    & QA    }
+   Y4      = { G & QDBAR & QC    & QBBAR & QABAR }
+   Y5      = { G & QDBAR & QC    & QBBAR & QA    }
+   Y6      = { G & QDBAR & QC    & QB    & QABAR }
+   Y7      = { G & QDBAR & QC    & QB    & QA    }
+   Y8      = { G & QD    & QCBAR & QBBAR & QABAR }
+   Y9      = { G & QD    & QCBAR & QBBAR & QA    }
+   Y10     = { G & QD    & QCBAR & QB    & QABAR }
+   Y11     = { G & QD    & QCBAR & QB    & QA    }
+   Y12     = { G & QD    & QC    & QBBAR & QABAR }
+   Y13     = { G & QD    & QC    & QBBAR & QA    }
+   Y14     = { G & QD    & QC    & QB    & QABAR }
+   Y15     = { G & QD    & QC    & QB    & QA    }
*
UHC4514DLY PINDLY (16,0,6) DPWR DGND
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15
+ GBAR LE A B C D
+ Y0_O  Y1_O  Y2_O  Y3_O  Y4_O  Y5_O Y6_O Y7_O Y8_O Y9_O
+ Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ABLE  = { CHANGED(GBAR,0) }
+
+ PINDLY:
+   Y0_O  Y1_O  Y2_O  Y3_O  Y4_O  Y5_O Y6_O Y7_O Y8_O Y9_O
+   Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O = {
+     CASE (
+       ABLE , DELAY(-1,18NS,44NS),
+       DELAY(-1,23NS,58NS)
+       )
+     }
+
+ WIDTH:
+   NODE      = LE
+   MIN_HI    = 20NS
+ SETUP_HOLD:
+   DATA(4)   = A B C D
+   CLOCK HL  = LE
+   SETUPTIME = 25NS
+   HOLDTIME  =  5NS
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74HC4515  DECODER/DEMULTIPLEXER 4-16 LINE WITH ADDRESS LATCHES
*
* HIGH-SPEED CMOS LOGIC DATA BOOK, 1988, TI
* JLS   8-24-92   REMODELED USING LOGICEXP, PINDLY, AND CONSTRAINT DEVICES
*
.SUBCKT 74HC4515   LE_I GBAR_I A_I B_I C_I D_I
+  Y0_O  Y1_O  Y2_O  Y3_O  Y4_O  Y5_O Y6_O Y7_O Y8_O Y9_O
+ Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0
*
U1 DLTCH(4) DPWR DGND
+ $D_HI $D_HI LE
+  A     B     C     D
+ QA    QB    QC    QD
+ QABAR QBBAR QCBAR QDBAR
+ D0_GFF  IO_HC
*
UHC4515LOG LOGICEXP (14,22) DPWR DGND
+ LE_I GBAR_I A_I B_I C_I D_I QA QB QC QD QABAR QBBAR QCBAR QDBAR
+ LE   GBAR   A   B   C   D
+ Y0  Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15
+ D0_GATE IO_HC
+ IO_LEVEL={IO_LEVEL}
+
+ LOGIC:
+   LE      = { LE_I }
+   GBAR    = { GBAR_I }
+   A       = { A_I }
+   B       = { B_I }
+   C       = { C_I }
+   D       = { D_I }
+
+   G       = { ~GBAR }
+   Y0      = { ~(G & QDBAR & QCBAR & QBBAR & QABAR) }
+   Y1      = { ~(G & QDBAR & QCBAR & QBBAR & QA   ) }
+   Y2      = { ~(G & QDBAR & QCBAR & QB    & QABAR) }
+   Y3      = { ~(G & QDBAR & QCBAR & QB    & QA   ) }
+   Y4      = { ~(G & QDBAR & QC    & QBBAR & QABAR) }
+   Y5      = { ~(G & QDBAR & QC    & QBBAR & QA   ) }
+   Y6      = { ~(G & QDBAR & QC    & QB    & QABAR) }
+   Y7      = { ~(G & QDBAR & QC    & QB    & QA   ) }
+   Y8      = { ~(G & QD    & QCBAR & QBBAR & QABAR) }
+   Y9      = { ~(G & QD    & QCBAR & QBBAR & QA   ) }
+   Y10     = { ~(G & QD    & QCBAR & QB    & QABAR) }
+   Y11     = { ~(G & QD    & QCBAR & QB    & QA   ) }
+   Y12     = { ~(G & QD    & QC    & QBBAR & QABAR) }
+   Y13     = { ~(G & QD    & QC    & QBBAR & QA   ) }
+   Y14     = { ~(G & QD    & QC    & QB    & QABAR) }
+   Y15     = { ~(G & QD    & QC    & QB    & QA   ) }
*
UHC4515DLY PINDLY (16,0,6) DPWR DGND
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15
+ LE GBAR A B C D
+  Y0_O  Y1_O  Y2_O  Y3_O  Y4_O  Y5_O Y6_O Y7_O Y8_O Y9_O
+ Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O
+ IO_HC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   ABLE  = { CHANGED(GBAR,0) }
+   ABLEL = { CHANGED(LE,0) }
+   ADDR  = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+ PINDLY:
+    Y0_O  Y1_O  Y2_O  Y3_O  Y4_O  Y5_O Y6_O Y7_O Y8_O Y9_O
+   Y10_O Y11_O Y12_O Y13_O Y14_O Y15_O = {
+     CASE (
+       ABLE , DELAY(-1,18NS,44NS),
+       ADDR , DELAY(-1,23NS,58NS),
+       ABLEL, DELAY(-1,23NS,58NS),
+       DELAY(-1,23NS,58NS)
+       )
+     }
+
+ WIDTH:
+   NODE      = LE
+   MIN_HI    = 20NS
+ SETUP_HOLD:
+   DATA(4)   = A B C D
+   CLOCK HL  = LE
+   SETUPTIME = 25NS
+   HOLDTIME  =  5NS
*
.ENDS
*
*$
*-------------------------------------------------------------------------
* 74HC4724 8-bit  Addressable Latches
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	09/21/89	Update interface and model names
*
.subckt 74HC4724  GBAR CLR S0 S1 S2 D Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U10 bufa(6) DPWR DGND
+	GBAR	CLR	S0	S1	S2	D
+	GB	CLRD	S0D	S1D	S2D	DD
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U11 anda(3,9) DPWR DGND
+	ED0	G	CLRD
+	ED1	G	CLRD
+	ED2	G	CLRD
+	ED3	G	CLRD
+	ED4	G	CLRD
+	ED5	G	CLRD
+	ED6	G	CLRD
+	ED7	G	CLRD
+	GB	CLRDD	$D_HI
+	CE0	CE1	CE2	CE3	CE4	CE5	CE6	CE7	XXEN
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U12 ora(2,8) DPWR DGND
+	CE0	CLRB
+	CE1	CLRB
+	CE2	CLRB
+	CE3	CLRB
+	CE4	CLRB
+	CE5	CLRB
+	CE6	CLRB
+	CE7	CLRB
+	CLR0	CLR1	CLR2	CLR3	CLR4	CLR5	CLR6	CLR7
+	D_HC4734_1 IO_HC MNTYMXDLY={MNTYMXDLY} 
U13 buf DPWR DGND
+	CLRD   CLRDD 
+	D_HC4734_2 IO_HC MNTYMXDLY={MNTYMXDLY} 
UD1 inva(6) DPWR DGND
+	GB	CLRD	S0D	S1D	S2D	XXEN
+	G	CLRB	S0B	S1B	S2B	XEN
+	D0_GATE IO_HC 
UD2 anda(3,8) DPWR DGND
+	S2B	S1B	S0B
+	S2B	S1B	S0D
+	S2B	S1D	S0B
+	S2B	S1D	S0D
+	S2D	S1B	S0B
+	S2D	S1B	S0D
+	S2D	S1D	S0B
+	S2D	S1D	S0D
+	E0	E1	E2	E3	E4	E5	E6	E7
+	D_HC4734_3 IO_HC MNTYMXDLY={MNTYMXDLY} 
UD3 anda(2,8) DPWR DGND
+	E0	G
+	E1	G
+	E2	G
+	E3	G
+	E4	G
+	E5	G
+	E6	G
+	E7	G
+	EN0	EN1	EN2	EN3	EN4	EN5	EN6	EN7
+	D_HC4734_4 IO_HC MNTYMXDLY={MNTYMXDLY} 
UD4 bufa(8) DPWR DGND
+	E0	E1	E2	E3	E4	E5	E6	E7
+	ED0	ED1	ED2	ED3	ED4	ED5	ED6	ED7
+	D_HC4734_5 IO_HC MNTYMXDLY={MNTYMXDLY} 
UL0 dltch(1) DPWR DGND
+	PREB CLR0 EN0   DD   Q0 $D_NC 
+	D_HC4734_6 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UL1 dltch(1) DPWR DGND
+	PREB CLR1 EN1   DD   Q1 $D_NC 
+	D_HC4734_6 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UL2 dltch(1) DPWR DGND
+	PREB CLR2 EN2   DD   Q2 $D_NC 
+	D_HC4734_6 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UL3 dltch(1) DPWR DGND
+	PREB CLR3 EN3   DD   Q3 $D_NC 
+	D_HC4734_6 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UL4 dltch(1) DPWR DGND
+	PREB CLR4 EN4   DD   Q4 $D_NC 
+	D_HC4734_6 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UL5 dltch(1) DPWR DGND
+	PREB CLR5 EN5   DD   Q5 $D_NC 
+	D_HC4734_6 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UL6 dltch(1) DPWR DGND
+	PREB CLR6 EN6   DD   Q6 $D_NC 
+	D_HC4734_6 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UL7 dltch(1) DPWR DGND
+	PREB CLR7 EN7   DD   Q7 $D_NC 
+	D_HC4734_6 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
UL8 buf DPWR DGND
+	$D_HI   PREB 
+	D0_GATE IO_HC 
UL9 bufa(3) DPWR DGND
+	G G1 G2   GD G2 G3 
+	D_HC4734_7 IO_HC MNTYMXDLY={MNTYMXDLY} 
UL10 and(2) DPWR DGND
+	GBAR GD   G1 
+	D0_GATE IO_HC 
UL11 or(2) DPWR DGND
+	G1 G3   CLK 
+	D0_GATE IO_HC 
UL12 suhdck(3) DPWR DGND
+	CLK
+	S0D	S1D	S2D
+	SU0	SU1	SU2	HD0	HD1	HD2
+	D_HC4734_8 IO_HC MNTYMXDLY={MNTYMXDLY} 
UL13 or(6) DPWR DGND
+	SU0 SU1 SU2 HD0 HD1 HD2   ENX 
+	D0_GATE IO_HC 
UL14 and(2) DPWR DGND
+	XEN ENX   ENCX 
+	D0_GATE IO_HC 
UL15 buf3a(9) DPWR DGND
+	$D_X	$D_X	$D_X	$D_X	$D_X	$D_X	$D_X	$D_X	$D_X
+	ENCX
+	PREB	CLR0	CLR1	CLR2	CLR3	CLR4	CLR5	CLR6	CLR7
+	D0_TGATE IO_HC 
.ends
*
.model D_HC4734_1 ugate (
+	tphlty=1ns	tphlmx=5ns
+	tplhty=1ns	tplhmx=5ns
+	)
.model D_HC4734_2 ugate (
+	tplhmn=1ns
+	)
.model D_HC4734_3 ugate (
+	tphlty=1ns	tphlmx=7ns
+	tplhty=1ns	tplhmx=7ns
+	)
.model D_HC4734_4 ugate (
+	tphlty=3ns	tphlmx=10ns
+	tplhty=3ns	tplhmx=10ns
+	)
.model D_HC4734_5 ugate (
+	tphlty=2ns	tphlmx=5ns
+	tplhty=2ns	tplhmx=5ns
+	)
.model D_HC4734_6 ugff (
+	twghmn=20ns	twpclmn=20ns
+	tsudgmn=16ns	thdgmn=8ns
+	tpdqhlty=17ns	tpdqhlmx=33ns
+	tpdqlhty=17ns	tpdqlhmx=33ns
+	tpgqhlty=17ns	tpgqhlmx=33ns
+	tpgqlhty=17ns	tpgqlhmx=33ns
+	tppcqhlty=17ns	tppcqhlmx=33ns
+	tppcqlhty=17ns	tppcqlhmx=33ns
+	)
.model D_HC4734_7 ugate (
+	tphlmn=10ns	tplhmn=10ns
+	)
.model D_HC4734_8 usuhd (
+	tsumn=19ns	thdmn=5ns
+	)
*$
*-------------------------------------------------------------------------
* 74HC7074 6-Section Multifunction (Nand, Invert, Nor, Flip-Flop) Circuits
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	09/14/89	Update interface and model names
*
.subckt 74HC7074  1A 2A 3A 3B 6A 6B 1Y 2Y 3Y 6Y 4CLK 4PREBAR 4CLRBAR 4D 4Q 4QBAR
+	5CLK 5PREBAR 5CLRBAR 5D 5Q 5QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U0 bufa(4) DPWR DGND
+	4PREBAR 4CLRBAR 5PREBAR 5CLRBAR   4PREB 4CLRB 5PREB 5CLRB 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U1 inva(2) DPWR DGND
+	1A 2A   1Y 2Y 
+	D_HC7074_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U2 nand(2) DPWR DGND
+	3A 3B   3Y 
+	D_HC7074_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U3 nor(2) DPWR DGND
+	6A 6B   6Y 
+	D_HC7074_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U4 dff(1) DPWR DGND
+	4PREB 4CLRB 4CLK   4D   4Q 4QBAR 
+	D_HC7074_2 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U5 dff(1) DPWR DGND
+	5PREB 5CLRB 5CLK   5D   5Q 5QBAR 
+	D_HC7074_2 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC7074_1 ugate (
+	tphlty=9ns	tphlmx=23ns
+	tplhty=9ns	tplhmx=23ns
+	)
.model D_HC7074_2 ueff (
+	twclklmn=23ns	twclkhmn=23ns
+	twpclmn=25ns	tsupcclkhmn=6ns
+	tsudclkmn=25ns	thdclkmn=5ns
+	tpclkqhlty=15ns	tpclkqhlmx=44ns
+	tpclkqlhty=15ns	tpclkqlhmx=44ns
+	tppcqhlty=15ns	tppcqhlmx=58ns
+	tppcqlhty=15ns	tppcqlhmx=58ns
+	)
*$
*-------------------------------------------------------------------------
* 74HC7075 6-Section Multifunction (Nand, Invert, Flip-Flop) Circuits
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	09/14/89	Update interface and model names
*
.subckt 74HC7075  1A 2A 3A 3B 6A 6B 1Y 2Y 3Y 6Y 4CLK 4PREBAR 4CLRBAR 4D 4Q 4QBAR
+	5CLK 5PREBAR 5CLRBAR 5D 5Q 5QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 bufa(4) DPWR DGND
+	4PREBAR 4CLRBAR 5PREBAR 5CLRBAR   4PREB 4CLRB 5PREB 5CLRB 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U2 inva(2) DPWR DGND
+	1A 2A   1Y 2Y 
+	D_HC7075_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U3 nanda(2,2) DPWR DGND
+	3A 3B 6A 6B   3Y 6Y 
+	D_HC7075_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U4 dff(1) DPWR DGND
+	4PREB 4CLRB 4CLK   4D   4Q 4QBAR 
+	D_HC7075_2 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U5 dff(1) DPWR DGND
+	5PREB 5CLRB 5CLK   5D   5Q 5QBAR 
+	D_HC7075_2 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC7075_1 ugate (
+	tphlty=9ns	tphlmx=23ns
+	tplhty=9ns	tplhmx=23ns
+	)
.model D_HC7075_2 ueff (
+	twclklmn=23ns	twclkhmn=23ns
+	twpclmn=25ns	tsupcclkhmn=6ns
+	tsudclkmn=25ns	thdclkmn=5ns
+	tpclkqhlty=15ns	tpclkqhlmx=44ns
+	tpclkqlhty=15ns	tpclkqlhmx=44ns
+	tppcqhlty=15ns	tppcqhlmx=58ns
+	tppcqlhty=15ns	tppcqlhmx=58ns
+	)
*$
*-------------------------------------------------------------------------
* 74HC7076 6-Section Multifunction (Invert, Nor, Flip-Flop) Circuits
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	09/14/89	Update interface and model names
*
.subckt 74HC7076  1A 2A 3A 3B 6A 6B 1Y 2Y 3Y 6Y 4CLK 4PREBAR 4CLRBAR 4D 4Q 4QBAR
+	5CLK 5PREBAR 5CLRBAR 5D 5Q 5QBAR
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 bufa(4) DPWR DGND
+	4PREBAR 4CLRBAR 5PREBAR 5CLRBAR   4PREB 4CLRB 5PREB 5CLRB 
+	D0_GATE IO_HC IO_LEVEL={IO_LEVEL} 
U2 inva(2) DPWR DGND
+	1A 2A   1Y 2Y 
+	D_HC7076_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U3 nora(2,2) DPWR DGND
+	3A 3B 6A 6B   3Y 6Y 
+	D_HC7076_1 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U4 dff(1) DPWR DGND
+	4PREB 4CLRB 4CLK   4D   4Q 4QBAR 
+	D_HC7076_2 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
U5 dff(1) DPWR DGND
+	5PREB 5CLRB 5CLK   5D   5Q 5QBAR 
+	D_HC7076_2 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC7076_1 ugate (
+	tphlty=9ns	tphlmx=23ns
+	tplhty=9ns	tplhmx=23ns
+	)
.model D_HC7076_2 ueff (
+	twclklmn=23ns	twclkhmn=23ns
+	twpclmn=25ns	tsupcclkhmn=6ns
+	tsudclkmn=25ns	thdclkmn=5ns
+	tpclkqhlty=15ns	tpclkqhlmx=44ns
+	tpclkqlhty=15ns	tpclkqlhmx=44ns
+	tppcqhlty=15ns	tppcqhlmx=58ns
+	tppcqlhty=15ns	tppcqlhmx=58ns
+	)
*$
*-------------------------------------------------------------------------
* 74HC7266 Quadruple 2-Input Exclusive-Nor Gates w/ Totem-Pole Outputs
*
* The High-Speed CMOS Logic Data Book, 1988, TI
* tdn	09/14/89	Update interface and model names
*
.subckt 74HC7266  A B Y
+	optional: DPWR=$G_DPWR DGND=$G_DGND
+	params: MNTYMXDLY=0 IO_LEVEL=0
U1 nxor DPWR DGND
+	A B   Y 
+	D_HC7266 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
.ends
*
.model D_HC7266 ugate (
+	tphlty=12ns	tphlmx=25ns
+	tplhty=12ns	tplhmx=25ns
+	)
*$
