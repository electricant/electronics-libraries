* -------------------------------------------------------------------------
*    Spectrum Software, all rights reserved, copywrite 1994,
*    Micro-Cap V Digital Library
*
*    Parts in this library are modeled at ambient room temperature (TA=25øC)
*    unless otherwise noted. Delays were taken from tables specifying a load
*    capacitance of 50pF.  (CL = 50pF unless otherwise stated.)
*
*    The CMOS Logic library contains parts found in the National CMOS
*    Logic Databook, 1988, and Motorola CMOS Logic Data book, 1991, DL131.
*
*    Note that the constraint data from the Motorola book listed above had
*    the min and max values reversed.  In this library, they are transposed
*    so that min constraint times represent best case scenarios (as in 
*    min delay times), and max constraint times represent worst case
*    scenarios.  This is then consistent with the National data book.

* ----------------------------------------------------------- CD4000----
*
*  Dual 3-Input NOR Gate plus Inverter
*
*  The CMOS Logic Data Book, 1988, National Pages 5-3 to 5-5
*  bss    2/14/95
*
.SUBCKT CD4000 A B C D E F G H K L
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
U1 nora(3,2) VDD VSS
+    A B C D E F H K
+    DLY_4000 IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 inv VDD VSS
+   G L
+   DLY_4000 IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_4000 ugate (TPLHMN=-1 TPLHTY=50ns TPLHMX=120ns
+                     TPHLMN=-1 TPHLTY=40ns TPHLMX=80ns)

.ENDS CD4000
*
*
* ----------------------------------------------------------- CD4000UB----
*
*  Dual 3-Input NOR Gate plus Inverter
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-2 to 6-4
*  jds    6/6/94
*  This part is shown in the data book as MC14000UB
*
.SUBCKT CD4000UB IN1A IN2A IN3A OUTA IN1B IN2B IN3B OUTB IN1C OUTC
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 nora(3,2) VDD VSS
+    IN1A IN2A IN3A IN1B IN2B IN3B OUTA OUTB
+    DLY_MOD IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

uf1 inv VDD VSS
+   IN1C OUTC
+   DLY_MOD IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=115ns TPLHMX=230ns
+                     TPHLMN=-1 TPHLTY=115ns TPHLMX=230ns)

.ENDS CD4000UB
*
*
* ----------------------------------------------------------- CD4001B----
*
*  Quad 2-Input NOR Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-5 to 6-14
*  jds    6/6/94
*  This part is shown in the data book as MC14001B
*
.SUBCKT CD4001B IN1A IN2A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 nor(2) VDD VSS
+   IN1A IN2A OUTA
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=125ns TPLHMX=250ns
+                     TPHLMN=-1 TPHLTY=125ns TPHLMX=250ns)

.ENDS CD4001B
*
*
* ----------------------------------------------------------- CD4001UB----
*
*  Quad 2-Input NOR Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-14 to 6-18
*  jds    6/6/94
*  This part is shown in the data book as MC14001UB
*
.SUBCKT CD4001UB IN1A IN2A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 nor(2) VDD VSS
+   IN1A IN2A OUTA
+   DLY_MOD IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=90ns TPLHMX=180ns
+                     TPHLMN=-1 TPHLTY=90ns TPHLMX=180ns)

.ENDS CD4001UB
*
*
* ----------------------------------------------------------- CD4002B----
*
*  Dual 4-Input NOR Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-5 to 6-14
*  jds    6/6/94
*  This part is shown in the data book as MC14002B
*
.SUBCKT CD4002B IN1A IN2A IN3A IN4A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 nor(4) VDD VSS
+   IN1A IN2A IN3A IN4A OUTA
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=160ns TPLHMX=300ns
+                     TPHLMN=-1 TPHLTY=160ns TPHLMX=300ns)

.ENDS CD4002B
*
*
* ----------------------------------------------------------- CD4002UB----
*
*  Dual 4-Input NOR Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-14 to 6-18
*  jds    6/6/94
*  This part is shown in the data book as MC14002UB
*
.SUBCKT CD4002UB IN1A IN2A IN3A IN4A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 nor(4) VDD VSS
+   IN1A IN2A IN3A IN4A OUTA
+   DLY_MOD IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=90ns TPLHMX=180ns
+                     TPHLMN=-1 TPHLTY=90ns TPHLMX=180ns)

.ENDS CD4002UB
*
*
*------------------------------------------------------------CD4006B-----

* 18-Bit Static Shift Register
* National CMOS Logic Databook, 1988, pages 5-242 to 5-25
* jat 8/29/95

.SUBCKT CD4006B
+ CLK D1 D2 D3 D4 OUT4D1 OUT4D2 OUT5D2 OUT4D3 OUT4D4 OUT5D4
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 INV VDD VSS
+ CLK CLKBAR
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 DFF(18) VDD VSS
+ $D_HI $D_HI CLKBAR
+ D1 Q1 Q2 Q3 D2 Q5 Q6 Q7 Q8 D3 Q10 Q11 Q12 D4 Q14 Q15 Q16 Q17
+ Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12 Q13 Q14 Q15 Q16 Q17 Q18
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ DLY_DFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_DFF UEFF(TWCLKLMN=-1 TWCLKLTY=100NS TWCLKLMX=200NS
+                   TWCLKLMN=-1 TWCLKLTY=100NS TWCLKLMX=200NS)

U3 PINDLY(6,0,0) VDD VSS
+ Q4 Q8 Q9 Q13 Q17 Q18
+ OUT4D1 OUT4D2 OUT5D2 OUT4D3 OUT4D4 OUT5D4
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+         OUT4D1 OUT4D2 OUT5D2 OUT4D3 OUT4D4 OUT5D4 = {
+            CASE(
+              (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+              DELAY(-1,201NS,401NS))}

U4 CONSTRAINT(5) VDD VSS
+ CLK D1 D2 D3 D4
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+    CLOCK HL = CLK
+    DATA(4) = D1 D2 D3 D4
+    SETUPTIME = 50NS
+    HOLDTIME = 55NS
+ FREQ:
+    NODE = CLK
+    MAXFREQ = 5MEG

.ENDS CD4006B

*------------------------------------------------------------CD4008B-----

* 4 Bit Full Adder
* Motorola CMOS Logic Data, 1991, pages 6-27 to 6-32
* jat 8/29/95
* This part is shown in the data book as MC14008B

.SUBCKT CD4008B
+ A1 A2 A3 A4 B1 B2 B3 B4 CIN COUT S1 S2 S3 S4
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(9,5) VDD VSS
+ A1 A2 A3 A4 B1 B2 B3 B4 CIN
+ S_1 S_2 S_3 S_4 C_OUT
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   NAND1 = {~(A1 & B1)}
+   NOR1  = {~(A1 | B1)}
+   NAND2 = {~(A2 & B2)}
+   NOR2  = {~(A2 | B2)}
+   NAND3 = {~(A3 & B3)}
+   NOR3  = {~(A3 | B3)}
+   NAND4 = {~(A4 & B4)}
+   NOR4  = {~(A4 | B4)}
+   NORS1 = {~((~NAND1) | (NOR1))}
+   NORS2 = {~((~NAND2) | (NOR2))}
+   NORS3 = {~((~NAND3) | (NOR3))}
+   NORS4 = {~((~NAND4) | (NOR4))}
+   S_1 = {CIN ^ NORS1}
+   INS2 = {(~NAND1) | ((~NOR1) & (CIN))}
+   INS3 = {(~NAND2) | ((~NOR2) & (INS2))}
+   INS4 = {(~NAND3) | ((~NOR3) & (INS3))}
+   S_2 = {INS2 ^ NORS2}
+   S_3 = {INS3 ^ NORS3}
+   S_4 = {INS4 ^ NORS4}
+   ANDCOUT = {(~NOR4) & (~NOR3) & (~NOR2) & (~NOR1)}
+   ANDORCOUT4 = {~NAND4}
+   ANDORCOUT3 = {(~NOR4) & (~NAND3)}
+   ANDORCOUT2 = {(~NOR4) & (~NOR3) & (~NAND2)}
+   ANDORCOUT1 = {(~NOR4) & (~NOR3) & (~NOR2) & (~NAND1)}
+   ORCOUT = {ANDORCOUT4 | ANDORCOUT3 | ANDORCOUT2 | ANDORCOUT1}
+   C_OUT = {((CIN) & (ANDCOUT)) | ORCOUT}

U2 PINDLY(5,0,9) VDD VSS
+ S_1 S_2 S_3 S_4 C_OUT
+ A1 A2 A3 A4 B1 B2 B3 B4 CIN
+ S1 S2 S3 S4 COUT
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+         SUMIN = {CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0) |
+                  CHANGED(A4,0) | CHANGED(B1,0) | CHANGED(B2,0) |
+                  CHANGED(B3,0) | CHANGED(B4,0)}
+         CARRYIN = {CHANGED(CIN,0)}  
+ PINDLY:
+         S1 S2 S3 S4 = {
+           CASE(
+                 SUMIN & (TRN_LH | TRN_HL), DELAY(-1,400NS,800NS),
+                 CARRYIN & (TRN_LH | TRN_HL), DELAY(-1,375NS,750NS),
+                 DELAY(-1,401NS,801NS))}
+         COUT = {
+           CASE(
+                 SUMIN & (TRN_LH | TRN_HL), DELAY(-1,305NS,610NS),
+                 CARRYIN & (TRN_LH | TRN_HL), DELAY(-1,170NS,340NS),
+                 DELAY(-1,306NS,611NS))}

.ENDS CD4008B

*-------------------------------------------------------------CD4009UB----

* CMOS Hex Buffer/Converter
* jat 12/13/95
* Harris AnswerFax, document # 940

.SUBCKT CD4009UB A ABAR
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 INV VDD VSS
+ A ABARO
+ D0_GATE IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(1,0,0) VDD VSS
+ ABARO ABAR
+ IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+   ABAR = {
+     CASE(
+        TRN_LH, DELAY(-1,70NS,140NS),
+        TRN_HL, DELAY(-1,30NS,60NS),
+        DELAY(-1,71NS,141NS))}

.ENDS CD4009UB

*-------------------------------------------------------------CD4010B----

* CMOS Hex Buffer/Converter
* jat 12/13/95
* Harris AnswerFax, document # 940

.SUBCKT CD4010B A G
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 PINDLY(1,0,0) VDD VSS
+ A G
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+   G = {
+     CASE(
+        TRN_LH, DELAY(-1,100NS,200NS),
+        TRN_HL, DELAY(-1,65NS,130NS),
+        DELAY(-1,101NS,201NS))}

.ENDS CD4010B

* ----------------------------------------------------------- CD4011B----
*
*  Quad 2-Input NAND Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-5 to 6-14
*  jds    6/6/94
*  This part is shown in the data book as MC14011B
*
.SUBCKT CD4011B IN1A IN2A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 nand(2) VDD VSS
+   IN1A IN2A OUTA
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=125ns TPLHMX=250ns
+                     TPHLMN=-1 TPHLTY=125ns TPHLMX=250ns)

.ENDS CD4011B
*
*
* ----------------------------------------------------------- CD4011UB----
*
*  Quad 2-Input NAND Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-14 to 6-18
*  jds    6/6/94
*  This part is shown in the data book as MC14011UB
*
.SUBCKT CD4011UB IN1A IN2A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 nand(2) VDD VSS
+   IN1A IN2A OUTA
+   DLY_MOD IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=90ns TPLHMX=180ns
+                     TPHLMN=-1 TPHLTY=90ns TPHLMX=180ns)

.ENDS CD4011UB
*
*
* ----------------------------------------------------------- CD4012B----
*
*  Dual 4-Input NAND Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-5 to 6-14
*  jds    6/6/94
*  This part is shown in the data book as MC14012B
*
.SUBCKT CD4012B IN1A IN2A IN3A IN4A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 nand(4) VDD VSS
+   IN1A IN2A IN3A IN4A OUTA
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=160ns TPLHMX=300ns
+                     TPHLMN=-1 TPHLTY=160ns TPHLMX=300ns)

.ENDS CD4012B
*
*
* ----------------------------------------------------------- CD4012UB----
*
*  Dual 4-Input NAND Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-14 to 6-18
*  jds    6/6/94
*  This part is shown in the data book as MC14012UB
*
.SUBCKT CD4012UB IN1A IN2A IN3A IN4A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 nand(4) VDD VSS
+   IN1A IN2A IN3A IN4A OUTA
+   DLY_MOD IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=90ns TPLHMX=180ns
+                     TPHLMN=-1 TPHLTY=90ns TPHLMX=180ns)

.ENDS CD4012UB
*
*
* ----------------------------------------------------------- CD4013B----
*
*  Dual Type D Flip-Flop
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-33 to 6-36
*  jds    6/6/94
*  This part is shown in the data book as MC14013B
*
.SUBCKT CD4013B SA RA CA DA QA QABAR
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 inva(2) VDD VSS
+   SA RA prebar clrbar
+   D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf1 dff(1) VDD VSS
+   prebar clrbar CA DA Q_A Q_ABAR
+   DFF4013B IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DFF4013B UEFF(TWPCLMN=250NS TWPCLTY=125NS TWPCLMX=-1
+                    TWCLKLMN=250NS TWCLKLTY=125NS TWCLKLMX=-1
+                    TWCLKHMN=250NS TWCLKHTY=125NS TWCLKHMX=-1
+                    TSUDCLKMN=-1NS TSUDCLKTY=250NS TSUDCLKMX=-1
+                    THDCLKMN=40NS THDCLKTY=20NS THDCLKMX=-1)

U3 PINDLY(2,0,3) VDD VSS
+ Q_A Q_ABAR
+ CA SA RA
+ QA QABAR
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          EDGE = {CHANGED_LH(CA,0)}
+          SET = {CHANGED_LH(SA,0)}
+          CLEAR = {CHANGED_LH(RA,0)}
+ PINDLY:
+          QA QABAR = {
+            CASE(
+               SET, DELAY(-1,175NS,350NS),
+               CLEAR, DELAY(-1,225NS,450NS),
+               EDGE & (TRN_LH | TRN_HL), DELAY(-1,175NS,350NS),
+               DELAY(-1,226NS,451NS))}
  
U4 CONSTRAINT(3) VDD VSS
+ CA SA RA
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ FREQ:
+        NODE = CA
+        MAXFREQ = 2MEG
+ SETUP_HOLD:
+             CLOCK LH = CA
+             DATA(2) = SA RA
+             SETUPTIME_LO = 80NS
+             HOLDTIME_LO = 50NS

.ENDS CD4013B
*
*------------------------------------------------------------CD4014B-----

* CD4014B 8 Stage Static Shift Register
* National Semiconductor, CMOS Logic Databook, 1988, pages 5-41 to 5-44
* jat 8/18/95

.SUBCKT CD4014B
+ DS P1 P2 P3 P4 P5 P6 P7 P8 CLK P/S Q6 Q7 Q8
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(18,8) VDD VSS
+ P/S P1 P2 P3 P4 P5 P6 P7 P8 DS Q_1 Q_2 Q_3 Q_4 Q_5 Q_6 Q_7 Q_8
+ D1 D2 D3 D4 D5 D6 D7 D8
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+       D1 = {(P/S & P1) | ((~P/S) & DS)}
+       D2 = {(P/S & P2) | ((~P/S) & Q_1)}
+       D3 = {(P/S & P3) | ((~P/S) & Q_2)}
+       D4 = {(P/S & P4) | ((~P/S) & Q_3)}
+       D5 = {(P/S & P5) | ((~P/S) & Q_4)}
+       D6 = {(P/S & P6) | ((~P/S) & Q_5)}
+       D7 = {(P/S & P7) | ((~P/S) & Q_6)}
+       D8 = {(P/S & P8) | ((~P/S) & Q_7)}

U2 DFF(8) VDD VSS
+ $D_HI $D_HI CLK
+ D1 D2 D3 D4 D5 D6 D7 D8
+ Q_1 Q_2 Q_3 Q_4 Q_5 Q_6 Q_7 Q_8
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ DFF_DLY IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DFF_DLY UEFF(TWCLKLMN=-1 TWCLKLTY=90NS TWCLKLMX=180NS)

U3 PINDLY(3,0,0) VDD VSS
+ Q_6 Q_7 Q_8
+ Q6 Q7 Q8
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+         Q6 Q7 Q8 = {
+           CASE(
+               TRN_LH | TRN_HL, DELAY(-1,200NS,320NS),
+               DELAY(-1,201NS,321NS))}

U4 CONSTRAINT(11) VDD VSS
+ CLK DS P1 P2 P3 P4 P5 P6 P7 P8 P/S
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ FREQ:
+       NODE = CLK
+       MAXFREQ = 4MEG
+ SETUP_HOLD:
+             CLOCK LH = CLK
+             DATA(1) = DS
+             SETUPTIME = 60NS
+ SETUP_HOLD:
+             CLOCK LH = CLK
+             DATA(8) =  P1 P2 P3 P4 P5 P6 P7 P8
+             SETUPTIME = 80NS
+ SETUP_HOLD:
+             CLOCK LH = CLK
+             DATA(1) = P/S
+             SETUPTIME = 100NS

.ENDS CD4014B

*------------------------------------------------------------CD4015B-----

* Dual 4-Bit Static Shift Register
* National Semiconductor, CMOS Logic Databook, 1988, pages 5-45 to 5-49
* jat 8/18/95

.SUBCKT CD4015B
+ DA CLKA RA Q1A Q2A Q3A Q4A
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 INV VDD VSS
+ RA RESET
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 DFF(4) VDD VSS
+ $D_HI RESET CLKA
+ DA Q_1A Q_2A Q_3A
+ Q_1A Q_2A Q_3A Q_4A
+ $D_NC $D_NC $D_NC $D_NC
+ DFF_DLY IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DFF_DLY UEFF(TWCLKLMN=-1 TWCLKLTY=160NS TWCLKLMX=250NS
+                   TWCLKHMN=-1 TWCLKHTY=160NS TWCLKHMX=250NS)

U3 PINDLY(4,0,0) VDD VSS
+ Q_1A Q_2A Q_3A Q_4A
+ Q1A Q2A Q3A Q4A
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+         Q1A Q2A Q3A Q4A = {
+           CASE(
+             (TRN_LH | TRN_HL), DELAY(-1,230NS,350NS),
+             DELAY(-1,231NS,351NS))}

U4 CONSTRAINT(2) VDD VSS
+ CLKA DA
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+             CLOCK LH = CLKA
+             DATA(1) = DA
+             SETUPTIME = 50NS
+ FREQ:
+       NODE = CLKA
+       MAXFREQ = 3.5MEG

.ENDS CD4015B

* ----------------------------------------------------------- CD4017B----
*
*  Decade Counter
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-54 to 6-58
*  jds    6/6/94
*  This part is shown in the data book as MC14017B
*  Note that the NAND gate feeding into the 3rd flip-flops D input should
*  be an AND gate for the circuit to operate as in the timing diagram.
*
.SUBCKT CD4017B CLK CLKENBAR RESET COUT Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0

U14017B LOGICEXP(13,14) VDD VSS
+      CLK CLKENBAR RESET q1ff q2ff q3ff q4ff q5ff
+      q1ffbar q2ffbar q3ffbar q4ffbar q5ffbar
+      clock clear i1
+      COUT_O Q0_O Q1_O Q2_O Q3_O Q4_O Q5_O Q6_O Q7_O Q8_O Q9_O
+      D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clock = {( CLK & ~CLKENBAR )}
+      clear = { (~RESET) }
+      i1 = { (q2ff & (q1ff | q3ff)) }
+      Q0_O = { (q1ffbar & q5ffbar) }
+      Q1_O = { (q1ff & q2ffbar) }
+      Q2_O = { (q2ff & q3ffbar) }
+      Q3_O = { (q3ff & q4ffbar) }
+      Q4_O = { (q4ff & q5ffbar) }
+      Q5_O = { (q1ff & q5ff) }
+      Q6_O = { (q1ffbar & q2ff) }
+      Q7_O = { (q2ffbar & q3ff) }
+      Q8_O = { (q3ffbar & q4ff) }
+      Q9_O = { (q5ff & q4ffbar) }
+      COUT_O = { q5ffbar }

Uf0 dff(5) VDD VSS
+   $D_HI clear clock q5ffbar q1ff i1 q3ff q4ff
+   q1ff q2ff q3ff q4ff q5ff q1ffbar q2ffbar q3ffbar q4ffbar q5ffbar
+   DLY_DFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_DFF UEFF(TWCLKLMN=-1 TWCLKLTY=125NS TWCLKLMX=250NS
+                   TWCLKHMN=-1 TWCLKHTY=125NS TWCLKHMX=250NS)

Udly PINDLY (11,0,2) VDD VSS
+    COUT_O Q0_O Q1_O Q2_O Q3_O Q4_O Q5_O Q6_O Q7_O Q8_O Q9_O
+    CLK RESET
+    COUT Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9
+    IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CP = {CHANGED_LH(CLK,0)}
+     CLR = { CHANGED_LH(RESET,0) }
+
+    PINDLY:
+       Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 = {
+            CASE(
+                 CLR, DELAY(-1,500ns,1us),
+                 CP, DELAY(-1,500ns,1us),
+                 DELAY(-1,501ns,1.001us)
+                )
+            }
+       COUT = {
+            CASE(
+                 CLR, DELAY(-1,400ns,800ns),
+                 CP, DELAY(-1,400ns,800ns),
+                 DELAY(-1,401ns,801ns)
+                )
+            }

Ucnstr CONSTRAINT(3) VDD VSS
+          CLKENBAR CLK RESET
+          IO_4000B
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 5MEG
+      WIDTH:
+         NODE = RESET
+         MIN_HI = 250ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = CLKENBAR
+        SETUPTIME_HI = 175ns
+        SETUPTIME_LO = 260ns
+        WHEN = { RESET != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = RESET
+        SETUPTIME_LO = 375ns

.ENDS CD4017B
*
*
*-------------------------------------------------------------CD4018B----

* Presettable Divide by N Counter
* National CMOS Logic Databook, 1988, pages 5-63 to 5-66
* jat 8/29/95

.SUBCKT CD4018B
+ RESET PREENAB DATA JAM1 JAM2 JAM3 JAM4 JAM5 CLOCK Q1BAR Q2BAR Q3BAR
+ Q4BAR Q5BAR
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(10,11) VDD VSS
+ RESET PREENAB JAM1 JAM2 JAM3 JAM4 JAM5 Q_1 Q_2BAR Q_3
+ PRESETBAR1 RESETBAR1 PRESETBAR2 RESETBAR2 PRESETBAR3 RESETBAR3
+ PRESETBAR4 RESETBAR4 PRESETBAR5 RESETBAR5 D3
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   PRESETBAR1 = {~(((~RESET) & PREENAB) & JAM1)}
+   RESETBAR1 = {((~RESET) & (~PREENAB)) | ((~RESET) & JAM1)}
+   PRESETBAR2 = {~(((~RESET) & PREENAB) & JAM2)}
+   RESETBAR2 = {((~RESET) & (~PREENAB)) | ((~RESET) & JAM2)}
+   PRESETBAR3 = {~(((~RESET) & PREENAB) & JAM3)}
+   RESETBAR3 = {((~RESET) & (~PREENAB)) | ((~RESET) & JAM3)}
+   PRESETBAR4 = {~(((~RESET) & PREENAB) & JAM4)}
+   RESETBAR4 = {((~RESET) & (~PREENAB)) | ((~RESET) & JAM4)}
+   PRESETBAR5 = {~(((~RESET) & PREENAB) & JAM5)}
+   RESETBAR5 = {((~RESET) & (~PREENAB)) | ((~RESET) & JAM5)}
+   D3 = {~(Q_2BAR | (~(Q_1 | Q_3)))}

U2 DFF(1) VDD VSS
+ PRESETBAR1 RESETBAR1 CLOCK
+ DATA Q_1 Q_1BAR
+ FFDLY IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(1) VDD VSS
+ PRESETBAR2 RESETBAR2 CLOCK
+ Q_1 Q_2 Q_2BAR
+ FFDLY IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 DFF(1) VDD VSS
+ PRESETBAR3 RESETBAR3 CLOCK
+ D3 Q_3 Q_3BAR
+ FFDLY IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 DFF(1) VDD VSS
+ PRESETBAR4 RESETBAR4 CLOCK
+ Q_3 Q_4 Q_4BAR
+ FFDLY IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 DFF(1) VDD VSS
+ PRESETBAR5 RESETBAR5 CLOCK
+ Q_4 $D_NC Q_5BAR
+ FFDLY IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL FFDLY UEFF(TWPCLMN=-1 TWPCLTY=100NS TWPCLMX=400NS
+                 TWCLKLMN=-1 TWCLKLTY=125NS TWCLKLMX=500NS
+                 TWCLKHMN=-1 TWCLKHTY=125NS TWCLKHMX=500NS
+                 TSUDCLKMN=-1 TSUDCLKTY=40NS TSUDCLKMX=200NS
+                 TSUPCCLKHMN=-1 TSUPCCLKHTY=100NS TSUPCCLKHMX=400NS)

U7 PINDLY(5,0,0) VDD VSS
+ Q_1BAR Q_2BAR Q_3BAR Q_4BAR Q_5BAR
+ Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+          Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR = {
+             CASE(
+                (TRN_LH | TRN_HL), DELAY(-1,235NS,700NS),
+                DELAY(-1,236NS,701NS))}

U8 CONSTRAINT(1) VDD VSS
+ CLOCK
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ FREQ:
+      NODE = CLOCK
+      MAXFREQ = 4MEG

.ENDS CD4018B   


* ----------------------------------------------------------- CD4019B----
*
*  Quad AND-OR Select Gate
*
*  The CMOS Logic Data Book, 1988, National Semiconductor Pages 5-67 to 5-69
*  jds    6/8/94
*
.SUBCKT CD4019B KA KB A1 A2 A3 A4 B1 B2 B3 B4 D1 D2 D3 D4
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf1 ao(2,2) VDD VSS
+   A1 KA B1 KB D1
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf2 ao(2,2) VDD VSS
+   A2 KA B2 KB D2
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf3 ao(2,2) VDD VSS
+   A3 KA B3 KB D3
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf4 ao(2,2) VDD VSS
+   A4 KA B4 KB D4
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=100ns TPLHMX=300ns
+                     TPHLMN=-1 TPHLTY=100ns TPHLMX=300ns)

.ENDS CD4019B
*
*
* ----------------------------------------------------------- CD4020B ----
*
*  14-Stage Binary Counter
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-63 to 6-66
*  jds    6/7/94
*  This part is shown in the data book as MC14020B
*
.SUBCKT CD4020B CLK RESET Q1 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12 Q13 Q14
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0

uf0 inv VDD VSS
+   RESET clr
+   D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf1 jkff(1) VDD VSS
+   $D_HI clr CLK $D_HI $D_HI Q1_O Q1BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf2 jkff(1) VDD VSS
+   $D_HI clr Q1_O $D_HI $D_HI Q2_O Q2BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf3 jkff(1) VDD VSS
+   $D_HI clr Q2_O $D_HI $D_HI Q3_O Q3BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf4 jkff(1) VDD VSS
+   $D_HI clr Q3_O $D_HI $D_HI Q4_O Q4BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf5 jkff(1) VDD VSS
+   $D_HI clr Q4_O $D_HI $D_HI Q5_O Q5BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf6 jkff(1) VDD VSS
+   $D_HI clr Q5_O $D_HI $D_HI Q6_O Q6BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf7 jkff(1) VDD VSS
+   $D_HI clr Q6_O $D_HI $D_HI Q7_O Q7BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf8 jkff(1) VDD VSS
+   $D_HI clr Q7_O $D_HI $D_HI Q8_O Q8BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf9 jkff(1) VDD VSS
+   $D_HI clr Q8_O $D_HI $D_HI Q9_O Q9BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf10 jkff(1) VDD VSS
+   $D_HI clr Q9_O $D_HI $D_HI Q10_O Q10BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf11 jkff(1) VDD VSS
+   $D_HI clr Q10_O $D_HI $D_HI Q11_O Q11BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf12 jkff(1) VDD VSS
+   $D_HI clr Q11_O $D_HI $D_HI Q12_O Q12BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf13 jkff(1) VDD VSS
+   $D_HI clr Q12_O $D_HI $D_HI Q13_O Q13BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf14 jkff(1) VDD VSS
+   $D_HI clr Q13_O $D_HI $D_HI Q14_O Q14BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Udly PINDLY (12,0,13) VDD VSS
+    Q1_O Q4_O Q5_O Q6_O Q7_O Q8_O Q9_O Q10_O Q11_O Q12_O Q13_O Q14_O
+    CLK RESET Q3_O Q4_O Q5_O Q6_O Q7_O Q8_O Q9_O Q10_O Q11_O Q12_O Q13_O
+    Q1 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12 Q13 Q14
+    IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+
+ PINDLY:
+    Q1  = {
+         CASE(
+              CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+              CHANGED_HL(CLK,0) & (TRN_LH | TRN_HL), DELAY(-1,260ns,520ns),
+              DELAY(-1,371ns,741ns)
+             )
+         }
+    Q4  = {
+         CASE(
+              CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+              CHANGED_HL(Q3_O,0) & (TRN_LH | TRN_HL), DELAY(-1,620ns,1300ns),
+              DELAY(-1,621ns,1301ns)
+             )
+         }
+    Q5  = {
+         CASE(
+              CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+              CHANGED_HL(Q4_O,0) & (TRN_LH | TRN_HL), DELAY(-1,740ns,1560ns),
+              DELAY(-1,741ns,1561ns)
+             )
+         }
+    Q6  = {
+         CASE(
+              CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+              CHANGED_HL(Q5_O,0) & (TRN_LH | TRN_HL), DELAY(-1,860ns,1820ns),
+              DELAY(-1,861ns,1821ns)
+             )
+         }
+    Q7  = {
+         CASE(
+              CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+              CHANGED_HL(Q6_O,0) & (TRN_LH | TRN_HL), DELAY(-1,980ns,2080ns),
+              DELAY(-1,981ns,2081ns)
+             )
+         }
+    Q8  = {
+         CASE(
+              CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+              CHANGED_HL(Q7_O,0) & (TRN_LH | TRN_HL), DELAY(-1,1100ns,2340ns),
+              DELAY(-1,1101ns,2341ns)
+             )
+         }
+    Q9  = {
+         CASE(
+              CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+              CHANGED_HL(Q8_O,0) & (TRN_LH | TRN_HL), DELAY(-1,1220ns,2600ns),
+              DELAY(-1,1221ns,2601ns)
+             )
+         }
+    Q10  = {
+         CASE(
+              CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+              CHANGED_HL(Q9_O,0) & (TRN_LH | TRN_HL), DELAY(-1,1340ns,2860ns),
+              DELAY(-1,1341ns,2861ns)
+             )
+         }
+    Q11  = {
+         CASE(
+              CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+              CHANGED_HL(Q10_O,0) & (TRN_LH | TRN_HL), DELAY(-1,1460ns,3120ns),
+              DELAY(-1,1461ns,3121ns)
+             )
+         }
+    Q12  = {
+         CASE(
+              CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+              CHANGED_HL(Q11_O,0) & (TRN_LH | TRN_HL), DELAY(-1,1580ns,3380ns),
+              DELAY(-1,1581ns,3381ns)
+             )
+         }
+    Q13  = {
+         CASE(
+              CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+              CHANGED_HL(Q12_O,0) & (TRN_LH | TRN_HL), DELAY(-1,1700ns,3640ns),
+              DELAY(-1,1701ns,3641ns)
+             )
+         }
+    Q14  = {
+         CASE(
+              CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+              CHANGED_HL(Q13_O,0) & (TRN_LH | TRN_HL), DELAY(-1,1820ns,3900ns),
+              DELAY(-1,1821ns,3901ns)
+             )
+          }

Ucnstr CONSTRAINT(2) VDD VSS
+          CLK RESET
+          IO_4000B
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 2MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 140ns
+      WIDTH:
+         NODE = RESET
+         MIN_HI = 320ns
+      SETUP_HOLD:
+        CLOCK HL = CLK
+        DATA(1) = RESET
+        SETUPTIME_LO = 65ns

.ENDS CD4020B
*
*
*------------------------------------------------------------CD4021B-----

* CD4021B 8 Stage Static Shift Register
* National Semiconductor, CMOS Logic Databook, 1988, pages 5-75 to 5-79
* jat 8/30/95

.SUBCKT CD4021B
+ SERIN P1 P2 P3 P4 P5 P6 P7 P8 CLK P/S Q6 Q7 Q8
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(10,17) VDD VSS
+ CLK P/S P1 P2 P3 P4 P5 P6 P7 P8
+ CLOCK PRESETBAR1 RESETBAR1 PRESETBAR2 RESETBAR2 PRESETBAR3 RESETBAR3
+ PRESETBAR4 RESETBAR4 PRESETBAR5 RESETBAR5 PRESETBAR6 RESETBAR6 
+ PRESETBAR7 RESETBAR7 PRESETBAR8 RESETBAR8 
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+        CLOCK = {CLK | P/S}
+        PRESETBAR1 = {~(P/S & P1)}
+        RESETBAR1 = {~(P/S) | (P/S & P1)}
+        PRESETBAR2 = {~(P/S & P2)}
+        RESETBAR2 = {~(P/S) | (P/S & P2)}
+        PRESETBAR3 = {~(P/S & P3)}
+        RESETBAR3 = {~(P/S) | (P/S & P3)}
+        PRESETBAR4 = {~(P/S & P4)}
+        RESETBAR4 = {~(P/S) | (P/S & P4)}
+        PRESETBAR5 = {~(P/S & P5)}
+        RESETBAR5 = {~(P/S) | (P/S & P5)}
+        PRESETBAR6 = {~(P/S & P6)}
+        RESETBAR6 = {~(P/S) | (P/S & P6)}
+        PRESETBAR7 = {~(P/S & P7)}
+        RESETBAR7 = {~(P/S) | (P/S & P7)}
+        PRESETBAR8 = {~(P/S & P8)}
+        RESETBAR8 = {~(P/S) | (P/S & P8)}

U2 DFF(1) VDD VSS
+ PRESETBAR1 RESETBAR1 CLOCK
+ SERIN Q_1 $D_NC
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(1) VDD VSS
+ PRESETBAR2 RESETBAR2 CLOCK
+ Q_1 Q_2 $D_NC
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 DFF(1) VDD VSS
+ PRESETBAR3 RESETBAR3 CLOCK
+ Q_2 Q_3 $D_NC
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 DFF(1) VDD VSS
+ PRESETBAR4 RESETBAR4 CLOCK
+ Q_3 Q_4 $D_NC
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 DFF(1) VDD VSS
+ PRESETBAR5 RESETBAR5 CLOCK
+ Q_4 Q_5 $D_NC
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 DFF(1) VDD VSS
+ PRESETBAR6 RESETBAR6 CLOCK
+ Q_5 Q_6 $D_NC
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 DFF(1) VDD VSS
+ PRESETBAR7 RESETBAR7 CLOCK
+ Q_6 Q_7 $D_NC
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 DFF(1) VDD VSS
+ PRESETBAR8 RESETBAR8 CLOCK
+ Q_7 Q_8 $D_NC
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 PINDLY(3,0,0) VDD VSS
+ Q_6 Q_7 Q_8
+ Q6 Q7 Q8
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+         Q6 Q7 Q8 = {
+           CASE(
+               TRN_LH | TRN_HL, DELAY(-1,240NS,350NS),
+               DELAY(-1,241NS,351NS))}

U11 CONSTRAINT(11) VDD VSS
+ CLK SERIN P1 P2 P3 P4 P5 P6 P7 P8 P/S
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ FREQ:
+       NODE = CLK
+       MAXFREQ = 3.5MEG
+ SETUP_HOLD:
+             CLOCK LH = CLK
+             DATA(1) = SERIN
+             SETUPTIME = 60NS
+ SETUP_HOLD:
+             CLOCK LH = P/S
+             DATA(8) =  P1 P2 P3 P4 P5 P6 P7 P8
+             SETUPTIME = 25NS
+ SETUP_HOLD:
+             CLOCK LH = CLK
+             DATA(1) = P/S
+             SETUPTIME = 100NS
+ WIDTH:
+        NODE = CLK
+        MIN_HI = 100NS
+        MIN_LO = 100NS
+ WIDTH:
+        NODE = P/S
+        MIN_LO = 150NS
+        MIN_HI = 150NS

.ENDS CD4021B


*-------------------------------------------------------------CD4022B----

* Divide by 8 Counter/Divider with 8 Decoded Outputs
* National Semiconductor, CMOS Logic Databook, 1988, pages 5-57 to 5-62
* jat 8/18/95
* Note that there should only be a single inversion in front of COUT, not
* a double inversion as shown in the logic diagram.

.SUBCKT CD4022B
+ CLK CLKENBAR RESET COUT Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ OPTIONAL: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(11,12) VDD VSS
+ CLK CLKENBAR RESET Q1FF Q2FF Q3FF Q4FF Q1FFBAR Q2FFBAR Q3FFBAR Q4FFBAR
+ CLOCK CLEAR D3 COUT_O Q0_O Q1_O Q2_O Q3_O Q4_O Q5_O Q6_O Q7_O
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+    LOGIC:
+      CLOCK = {(CLK & (~CLKENBAR))}
+      CLEAR = {(~RESET)}
+      D3 = {~(Q2FFBAR | (~(Q1FF | Q2FFBAR | Q3FF)))}
+      Q0_O = {(Q1FFBAR & Q4FFBAR) }
+      Q1_O = {(Q1FF & Q2FFBAR)}
+      Q2_O = {(Q2FF & Q3FFBAR)}
+      Q3_O = {(Q3FF & Q4FFBAR)}
+      Q4_O = {(Q1FF & Q4FF)}
+      Q5_O = {(Q1FFBAR & Q2FF)}
+      Q6_O = {(Q2FFBAR & Q3FF)}
+      Q7_O = {(Q3FFBAR & Q4FF)}
+      COUT_O = {~Q4FF}

U2 DFF(4) VDD VSS
+ $D_HI CLEAR CLOCK
+ Q4FFBAR Q1FF D3 Q3FF  
+ Q1FF Q2FF Q3FF Q4FF Q1FFBAR Q2FFBAR Q3FFBAR Q4FFBAR
+ DLY_DFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_DFF UEFF(TWCLKLMN=-1 TWCLKLTY=125NS TWCLKLMX=250NS
+                   TWCLKHMN=-1 TWCLKHTY=125NS TWCLKHMX=250NS)

U3 PINDLY(9,0,2) VDD VSS
+ COUT_O Q0_O Q1_O Q2_O Q3_O Q4_O Q5_O Q6_O Q7_O
+ CLK RESET
+ COUT Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          EDGE = {CHANGED_LH(CLK,0)}
+          CLR = {CHANGED_LH(RESET,0)}
+ PINDLY:
+          Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 = {
+            CASE(
+                 EDGE & (TRN_LH | TRN_HL), DELAY(-1,500NS,1000NS),
+                 CLR & (TRN_LH | TRN_HL), DELAY(-1,500NS,1000NS),
+                 DELAY(-1,501NS,1001NS))}
+          COUT = {
+            CASE(
+                 EDGE & (TRN_LH | TRN_HL), DELAY(-1,415NS,800NS),
+                 CLR & (TRN_LH | TRN_HL), DELAY(-1,415NS,800NS),
+                 DELAY(-1,416NS,801NS))}

U4 CONSTRAINT(3) VDD VSS
+ CLKENBAR CLK RESET
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ FREQ:
+       NODE = CLK
+       MAXFREQ = 2MEG
+ WIDTH:
+       NODE = RESET
+       MIN_HI = 200NS 
+ SETUP_HOLD:
+             CLOCK LH = CLK
+             DATA(1) = CLKENBAR
+             SETUPTIME_HI = 120NS
+             WHEN = { RESET != '1 }
+ SETUP_HOLD:
+             CLOCK LH = CLK
+             DATA(1) = RESET
+             SETUPTIME_LO = 75NS

.ENDS CD4022B

* ----------------------------------------------------------- CD4023B----
*
*  Triple 3-Input NAND Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-5 to 6-14
*  jds    6/6/94
*  This part is shown in the data book as MC14023B
*
.SUBCKT CD4023B IN1A IN2A IN3A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 nand(3) VDD VSS
+   IN1A IN2A IN3A OUTA
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=160ns TPLHMX=300ns
+                     TPHLMN=-1 TPHLTY=160ns TPHLMX=300ns)

.ENDS CD4023B
*
*
* ----------------------------------------------------------- CD4023UB----
*
*  Triple 3-Input NAND Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-14 to 6-18
*  jds    6/6/94
*  This part is shown in the data book as MC14023UB
*
.SUBCKT CD4023UB IN1A IN2A IN3A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 nand(3) VDD VSS
+   IN1A IN2A IN3A OUTA
+   DLY_MOD IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=90ns TPLHMX=180ns
+                     TPHLMN=-1 TPHLTY=90ns TPHLMX=180ns)

.ENDS CD4023UB
*
*
* ----------------------------------------------------------- CD4024B ----
*
*  7-Stage Ripple Carry Binary Counter
*
*  The CMOS Logic Data Book, 1988, National Semiconductor Pages 5-88 to 5-91
*  jds    6/8/94
*
.SUBCKT CD4024B CLK RESET Q1 Q2 Q3 Q4 Q5 Q6 Q7
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0

uf0 inv VDD VSS
+   RESET clr
+   D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf1 jkff(1) VDD VSS
+   $D_HI clr CLK $D_HI $D_HI Q1_O Q1BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf2 jkff(1) VDD VSS
+   $D_HI clr Q1_O $D_HI $D_HI Q2_O Q2BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf3 jkff(1) VDD VSS
+   $D_HI clr Q2_O $D_HI $D_HI Q3_O Q3BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf4 jkff(1) VDD VSS
+   $D_HI clr Q3_O $D_HI $D_HI Q4_O Q4BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf5 jkff(1) VDD VSS
+   $D_HI clr Q4_O $D_HI $D_HI Q5_O Q5BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf6 jkff(1) VDD VSS
+   $D_HI clr Q5_O $D_HI $D_HI Q6_O Q6BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf7 jkff(1) VDD VSS
+   $D_HI clr Q6_O $D_HI $D_HI Q7_O Q7BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Udly PINDLY (7,0,8) VDD VSS
+    Q1_O Q2_O Q3_O Q4_O Q5_O Q6_O Q7_O
+    CLK RESET Q1_O Q2_O Q3_O Q4_O Q5_O Q6_O
+    Q1 Q2 Q3 Q4 Q5 Q6 Q7
+    IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    PINDLY:
+   Q1  = {
+        CASE(
+             CHANGED(RESET,0) & TRN_HL, DELAY(-1,185ns,350ns),
+             CHANGED_HL(CLK,0) & (TRN_LH | TRN_HL), DELAY(-1,185ns,350ns),
+             DELAY(-1,186ns,351ns)
+            )
+        }
+   Q2  = {
+        CASE(
+             CHANGED(RESET,0) & TRN_HL, DELAY(-1,185ns,350ns),
+             CHANGED_HL(Q1_O,0) & (TRN_LH | TRN_HL), DELAY(-1,370ns,700ns),
+             DELAY(-1,371ns,701ns)
+            )
+        }
+   Q3  = {
+        CASE(
+             CHANGED(RESET,0) & TRN_HL, DELAY(-1,185ns,350ns),
+             CHANGED_HL(Q2_O,0) & (TRN_LH | TRN_HL), DELAY(-1,555ns,1050ns),
+             DELAY(-1,556ns,1051ns)
+            )
+        }
+   Q4  = {
+        CASE(
+             CHANGED(RESET,0) & TRN_HL, DELAY(-1,185ns,350ns),
+             CHANGED_HL(Q3_O,0) & (TRN_LH | TRN_HL), DELAY(-1,740ns,1400ns),
+             DELAY(-1,741ns,1401ns)
+            )
+        }
+   Q5  = {
+        CASE(
+             CHANGED(RESET,0) & TRN_HL, DELAY(-1,185ns,350ns),
+             CHANGED_HL(Q4_O,0) & (TRN_LH | TRN_HL), DELAY(-1,925ns,1750ns),
+             DELAY(-1,926ns,1751ns)
+            )
+        }
+   Q6  = {
+        CASE(
+             CHANGED(RESET,0) & TRN_HL, DELAY(-1,185ns,350ns),
+             CHANGED_HL(Q5_O,0) & (TRN_LH | TRN_HL), DELAY(-1,1110ns,2100ns),
+             DELAY(-1,1111ns,2101ns)
+            )
+        }
+   Q7  = {
+        CASE(
+             CHANGED(RESET,0) & TRN_HL, DELAY(-1,185ns,350ns),
+             CHANGED_HL(Q6_O,0) & (TRN_LH | TRN_HL), DELAY(-1,1295ns,2450ns),
+             DELAY(-1,1296ns,2451ns)
+            )
+        }

Ucnstr CONSTRAINT(2) VDD VSS
+          CLK RESET
+          IO_4000B
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 5MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 75ns
+         MIN_LO = 75ns
+      WIDTH:
+         NODE = RESET
+         MIN_HI = 185ns

.ENDS CD4024B
*
*
* ----------------------------------------------------------- CD4025B----
*
*  Triple 3-Input NOR Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-5 to 6-14
*  jds    6/6/94
*  This part is shown in the data book as MC14025B
*
.SUBCKT CD4025B IN1A IN2A IN3A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 nor(3) VDD VSS
+   IN1A IN2A IN3A OUTA
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=160ns TPLHMX=300ns
+                     TPHLMN=-1 TPHLTY=160ns TPHLMX=300ns)

.ENDS CD4025B
*
*
* ----------------------------------------------------------- CD4025UB----
*
*  Triple 3-Input NOR Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-14 to 6-18
*  jds    6/6/94
*  This part is shown in the data book as MC14025UB
*
.SUBCKT CD4025UB IN1A IN2A IN3A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 nor(3) VDD VSS
+   IN1A IN2A IN3A OUTA
+   DLY_MOD IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=90ns TPLHMX=180ns
+                     TPHLMN=-1 TPHLTY=90ns TPHLMX=180ns)

.ENDS CD4025UB
*
*
*-------------------------------------------------------------CD4026B------

* CMOS Decade Counters/Dividers
* Harris AnswerFax document # 1118
* jat 12/13/95
* Note that the logic diagram is wrong.  The error occurs at the two 
* cascaded OR gates feeding data into flip flop #3.  One way to fix it is
* to add an inverting bubble at the output of the first stage OR gate, before
* it is NORed with Q2BAR.

.SUBCKT CD4026B CLK CLKINH RESET DISPENIN DISPENOUT A B C D E F G CARRYOUT
+ UNGATEDC
+ OPTIONAL: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(13,11) VDD VSS
+ CLKINH RESET Q1 Q2 Q3 Q4 Q5 Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR DISPENIN
+ CLKINHBAR RESETBAR D3 AO BO UNGATEDCO CO DO EO FO GO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLKINHBAR = {~CLKINH}
+   RESETBAR = {~RESET}
+   D3 = {Q2 & (Q1 | Q3)}
+   OR1 = {Q4BAR | Q5}
+   OR2 = {Q2 | Q1BAR}
+   OR3 = {Q1BAR | Q5BAR}
+   OR4 = {Q1 | Q2BAR}
+   OR5 = {Q2BAR | Q3}
+   OR6 = {Q2 | Q3BAR}
+   OR7 = {Q1 | Q5}
+   OR8 = {Q3 | Q4BAR}
+   OR9 = {Q3BAR | Q4}
+   AO = {OR1 & OR2 & DISPENIN}
+   BO = {OR3 & OR4 & DISPENIN}
+   UNGATEDCO = {OR5}
+   CO = {OR5 & DISPENIN}
+   DO = {OR6 & OR1 & OR2 & DISPENIN}
+   EO = {DISPENIN & (~(OR7 & OR4 & OR5 & OR8))}
+   FO = {OR5 & OR9 & OR2 & OR6 & DISPENIN}
+   GO = {OR6 & OR2 & OR7 & DISPENIN}

U2 AND(2) VDD VSS
+ CLK CLKINHBAR CL
+ D0_GATE IO_4000B_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(5) VDD VSS
+ $D_HI RESETBAR CL
+ Q5BAR Q1 D3 Q3 Q4
+ Q1 Q2 Q3 Q4 Q5
+ Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 PINDLY(10,0,2) VDD VSS
+ Q5BAR AO BO UNGATEDCO CO DO EO FO GO DISPENIN
+ CL RESET
+ CARRYOUT A B UNGATEDC C D E F G DISPENOUT
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    CLOCK = {CHANGED_LH(CL,0)}
+    RST = {CHANGED_LH(RESET,0)}
+ PINDLY:
+    CARRYOUT = {
+       CASE(
+          RST & TRN_LH, DELAY(-1,275NS,550NS),
+          CLOCK & (TRN_LH | TRN_HL), DELAY(-1,250NS,500NS),
+          DELAY(-1,276NS,551NS))}
+    A B UNGATEDC C D E F G DISPENOUT = {
+       CASE(
+          RST & (TRN_LH | TRN_HL), DELAY(-1,300NS,600NS),
+          CLOCK & (TRN_LH | TRN_HL), DELAY(-1,350NS,700NS),
+          DELAY(-1,351NS,701NS))}

U5 CONSTRAINT(2) VDD VSS
+ CLK RESET
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 5MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 110NS
+   MIN_HI = 110NS
+ WIDTH:
+   NODE = RESET
+   MIN_LO = 100NS
+   MIN_HI = 100NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(1) = RESET
+   SETUPTIME_LO = 30NS

.ENDS CD4026B

* ----------------------------------------------------------- CD4027B ----
*
*  Dual J-K Flip Flop
*
*  The CMOS Logic Data Book, 1988, National Semiconductor Pages 5-92 to 5-96
*  jds    6/8/94
*
.SUBCKT CD4027B CLK RESET SET J K Q QBAR
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0

uf0 inva(3) VDD VSS
+   RESET SET CLK clrbar prebar clkbar
+   D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf1 jkff(1) VDD VSS
+   prebar clrbar clkbar J K Q QBAR
+   JKFF4027 IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model JKFF4027 ueff(TPPCQLHMN=-1   TPPCQLHTY=110ns   TPPCQLHMX=220ns
+                    TPPCQHLMN=-1   TPPCQHLTY=170ns   TPPCQHLMX=340ns
+                    TWPCLMN=-1     TWPCLTY=80ns      TWPCLMX=160ns
+                    TPCLKQLHMN=-1  TPCLKQLHTY=200ns  TPCLKQLHMX=400ns
+                    TPCLKQHLMN=-1  TPCLKQHLTY=200ns  TPCLKQHLMX=400ns
+                    TWCLKLMN=-1    TWCLKLTY=100ns    TWCLKLMX=200ns
+                    TWCLKHMN=-1    TWCLKHTY=100ns    TWCLKHMX=200ns
+                    TSUDCLKMN=-1   TSUDCLKTY=135ns   TSUDCLKMX=270ns
+                    TSUPCCLKHMN=-1 TSUPCCLKHTY=-1    TSUPCCLKHMX=-1
+                    THDCLKMN=-1    THDCLKTY=-1       THDCLKMX=-1)

.ENDS CD4027B
*
*
* ----------------------------------------------------------- CD4028B ----
*
*  BCD-to-Decimal Decoder
*
*  The CMOS Logic Data Book, 1988, National Semiconductor Pages 5-97 to 5-99
*  jds    6/8/94
*
.SUBCKT CD4028B A B C D O0 O1 O2 O3 O4 O5 O6 O7 O8 O9
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0

U4028B LOGICEXP(4,10) VDD VSS
+      A B C D
+      O0_O O1_O O2_O O3_O O4_O O5_O O6_O O7_O O8_O O9_O
+      D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      O0_O = { (~D & ~C & ~B & ~A) }
+      O1_O = { (~D & ~C & ~B & A) }
+      O2_O = { (~D & ~C & B & ~A) }
+      O3_O = { (~D & ~C & B & A) }
+      O4_O = { (~D & C & ~B & ~A) }
+      O5_O = { (~D & C & ~B & A) }
+      O6_O = { (~D & C & B & ~A) }
+      O7_O = { (~D & C & B & A) }
+      O8_O = { ((D & ~C & ~B & ~A) | (D & ~C & B & ~A) |
+                (D & C & ~B & ~A) | (D & C & B & ~A)) }
+      O9_O = { ((D & ~C & ~B & A) | (D & ~C & B & A) |
+                (D & C & ~B & A) | (D & C & B & A)) }

Udly PINDLY (10,0,4) VDD VSS
+    O0_O O1_O O2_O O3_O O4_O O5_O O6_O O7_O O8_O O9_O
+    A B C D
+    O0 O1 O2 O3 O4 O5 O6 O7 O8 O9
+    IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     DATA = {CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+       O0 O1 O2 O3 O4 O5 O6 O7 O8 O9 = {
+            CASE(
+                 DATA, DELAY(-1,240ns,480ns),
+                 DELAY(-1,241ns,481ns)
+                )
+            }

.ENDS CD4028B
*
*
*-------------------------------------------------------------CD4029B---

* Presettable Binary/Decade Up/Down Counter
* National CMOS Logic Databook, 1988, pages 5-100 to 5-105
* jat 8/30/95

.SUBCKT CD4029B
+ CLK PREENAB CIN COUT U/D B/D JAM1 JAM2 JAM3 JAM4 Q1 Q2 Q3 Q4
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(17,14) VDD VSS
+ PREENAB JAM1 JAM2 JAM3 JAM4 CLK U/D B/D Q_4BAR Q_3BAR Q_2BAR Q_2 Q_3 CIN
+ Q_1 Q_1BAR Q_4
+ PBAR1 RBAR1 PBAR2 RBAR2 PBAR3 RBAR3 PBAR4 RBAR4 CLOCK T1 T2 T3 T4 C_OUT
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  PBAR1 = {~(JAM1 & PREENAB)}
+  RBAR1 = {~(PBAR1 & PREENAB)}
+  PBAR2 = {~(JAM2 & PREENAB)}
+  RBAR2 = {~(PBAR2 & PREENAB)}
+  PBAR3 = {~(JAM3 & PREENAB)}
+  RBAR3 = {~(PBAR3 & PREENAB)}
+  PBAR4 = {~(JAM4 & PREENAB)}
+  RBAR4 = {~(PBAR4 & PREENAB)}
+  CLOCK = {~(CLK | PREENAB)}
+  U/DBAR = {~U/D}
+  B/DBAR = {~B/D}
+  NANDIN = {~(B/DBAR & Q_4BAR & Q_3BAR & Q_2BAR)}
+  ORIN = {(~(Q_4BAR | B/D)) | (Q_2 & Q_3)}
+  T1 = {~CIN}
+  TL2IN1 = {~(Q_1 & T1)}
+  TL2IN2 = {~(Q_1BAR & T1)}
+  TL2IN3 = {~(U/D & (B/D | Q_4BAR))}
+  TL2IN4 = {~(NANDIN & U/DBAR)}
+  TL3IN1 = {~(Q_2 & U/D)}
+  TL3IN2 = {~(Q_2BAR & NANDIN & U/DBAR)}
+  TL3IN3 = {TL2IN1}
+  TL3IN4 = {TL2IN2}
+  TL4IN1 = {~(Q_3BAR & Q_2BAR & U/DBAR)}
+  TL4IN2 = {~(U/D & ORIN)}
+  TL4IN3 = {TL2IN2}
+  TL4IN4 = {TL2IN1}
+  T2 = {~((TL2IN1 | TL2IN3) & (TL2IN2 | TL2IN4))}
+  T3 = {~((TL3IN1 | TL3IN3) & (TL3IN2 | TL3IN4))}
+  T4 = {~((TL4IN1 | TL4IN3) & (TL4IN2 | TL4IN4))}
+  NAND1OUT = {~(Q_2BAR & Q_3BAR & Q_4BAR & U/DBAR)}
+  OROUT = {B/DBAR | (Q_3 & Q_2)}
+  NAND2OUT = {~(Q_4 & OROUT & U/D)}
+  C_OUT = {(NAND1OUT | TL2IN2) & (NAND2OUT | TL2IN1)}

U2 JKFF(1) VDD VSS
+ PBAR1 RBAR1 CLOCK
+ T1 T1 Q_1 Q_1BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) VDD VSS
+ PBAR2 RBAR2 CLOCK
+ T2 T2 Q_2 Q_2BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) VDD VSS
+ PBAR3 RBAR3 CLOCK
+ T3 T3 Q_3 Q_3BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) VDD VSS
+ PBAR4 RBAR4 CLOCK
+ T4 T4 Q_4 Q_4BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 PINDLY(5,0,3) VDD VSS
+ Q_1 Q_2 Q_3 Q_4 C_OUT
+ PREENAB CLK CIN
+ Q1 Q2 Q3 Q4 COUT
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          PRESETENAB = {CHANGED_LH(PREENAB,0)}
+          EDGE = {CHANGED_LH(CLK,0)}
+          CARRYIN = {CHANGED(CIN,0)}
+ PINDLY:
+         Q1 Q2 Q3 Q4 = {
+           CASE(
+              PRESETENAB & (TRN_LH | TRN_HL), DELAY(-1,285NS,570NS),
+              EDGE & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+              DELAY(-1,286NS,571NS))}
+         COUT = {
+           CASE(
+              PRESETENAB & (TRN_LH | TRN_HL), DELAY(-1,400NS,800NS),
+              EDGE & (TRN_LH | TRN_HL), DELAY(-1,320NS,640NS),
+              CARRYIN & (TRN_LH | TRN_HL), DELAY(-1,265NS,530NS),
+              DELAY(-1,401NS,801NS))}

U7 CONSTRAINT(3) VDD VSS
+ CLK CIN PREENAB
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ WIDTH:
+         NODE = CLK
+         MIN_LO = 160NS
+         MIN_HI = 160NS
+ SETUP_HOLD:
+             CLOCK LH = CLK
+             DATA(1) = CIN
+             SETUPTIME = 180NS
+ FREQ:
+      NODE = CLK
+      MAXFREQ = 3.1MEG
+ WIDTH:
+       NODE = PREENAB
+       MIN_HI = 80NS
+ SETUP_HOLD:
+             CLOCK LH = CLK
+             DATA(1) = PREENAB
+             SETUPTIME_LO = 150NS

.ENDS CD4029B

* ----------------------------------------------------------- CD4030 ----
*
*  Quad 2-Input XOR Gate
*
*  The CMOS Logic Data Book, 1988, National Semiconductor Pages 5-106 to 5-108
*  jds    6/8/94
*
.SUBCKT CD4030 A B J
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 xor VDD VSS
+   A B J
+   DLY_MOD IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=100ns TPLHMX=300ns
+                     TPHLMN=-1 TPHLTY=100ns TPHLMX=300ns)

.ENDS CD4030
*
*
*-------------------------------------------------------------CD4030B-----

* CMOS Quad Exclusive-OR Gates
* Harris AnswerFax, document #1055
* jat 12/14/95

.SUBCKT CD4030B A B J
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 XOR VDD VSS
+ A B J
+ DLY IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY UGATE (TPLHMN=-1 TPLHTY=140NS TPLHMX=280NS
+                 TPHLMN=-1 TPHLTY=140NS TPHLMX=280NS)

.ENDS CD4030B

*-------------------------------------------------------------CD4031B-----

* CMOS 64-Stage Static Shift Register
* Harris AnswerFax document # 1073
* jat 12/14/95

.SUBCKT CD4031B DATA1 DATA2 CL CLD MODE Q QBAR QPRIME
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(4,2) VDD VSS
+ DATA1 DATA2 MODE CL
+ D CLBAR
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   D = {(DATA1 & (~MODE)) | (DATA2 & MODE)}
+   CLBAR = {~CL}

U2 DFF(64) VDD VSS
+ $D_HI $D_HI CL
+ D 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27
+ 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52
+ 53 54 55 56 57 58 59 60 61 62 63
+ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27
+ 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52
+ 53 54 55 56 57 58 59 60 61 62 63 QO
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 		
+ $D_NC $D_NC $D_NC QBARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(1) VDD VSS
+ $D_HI $D_HI CLBAR
+ QO
+ QPRIMEO
+ $D_NC
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 PINDLY(4,0,2) VDD VSS
+ CL QO QBARO QPRIMEO
+ CL CLBAR
+ CLD Q QBAR QPRIME
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = {CHANGED_LH(CL,0)}
+   CLOCKBAR = {CHANGED_LH(CLBAR,0)}
+ PINDLY:
+   Q = {
+     CASE(
+      CLOCK & TRN_LH, DELAY(-1,250NS,500NS),
+      CLOCK & TRN_HL, DELAY(-1,190NS,380NS),
+      DELAY(-1,251NS,501NS))}
+   QBAR = {
+     CASE(
+      CLOCK & (TRN_LH | TRN_HL), DELAY(-1,250NS,500NS),
+      DELAY(-1,251NS,501NS))}
+   QPRIME = {
+     CASE(
+      CLOCKBAR & (TRN_LH | TRN_HL), DELAY(-1,190NS,380NS),
+      DELAY(-1,191NS,381NS))}
+   CLD = {
+     CASE(
+       (TRN_LH | TRN_HL), DELAY(-1,100NS,200NS),
+       DELAY(-1,101NS,201NS))}

U5 CONSTRAINT(3) VDD VSS
+ CL DATA1 DATA2
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+   CLOCK LH = CL
+   DATA(2) = DATA1 DATA2
+   SETUPTIME = 30NS
+   HOLDTIME = 30NS
+ WIDTH:
+   NODE = CL
+   MIN_LO = 120NS
+   MIN_HI = 120NS
+ FREQ:
+   NODE = CL
+   MAXFREQ = 4MEG

.ENDS CD4031B

*-------------------------------------------------------------CD4032B-----

* Triple Serial Adders
* Motorola CMOS Logic Data, 1991, pages 6-92 to 6-96
* jat 8/31/95

.SUBCKT CD4032B
+ A1 A2 A3 B1 B2 B3 S1 S2 S3 INV1 INV2 INV3 CLK CR
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(14,8) VDD VSS
+ CLK A1 A2 A3 B1 B2 B3 Q1 Q2 Q3 INV1 INV2 INV3 QRESET
+ CLKBAR D1 D2 D3 RESETBAR S_1 S_2 S_3
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLKBAR = {~CLK}
+   D1 = {(Q1 & A1) | (A1 & B1) | (Q1 & B1)}
+   D2 = {(Q2 & A2) | (A2 & B2) | (Q2 & B2)}
+   D3 = {(Q3 & A3) | (A3 & B3) | (Q3 & B3)}
+   RESETBAR = {~(QRESET & CLK)}
+   S1IN1 = {~(A1 ^ B1)}
+   S1IN2 = {~(Q1 ^ INV1)}
+   S2IN1 = {~(A2 ^ B2)}
+   S2IN2 = {~(Q2 ^ INV2)}
+   S3IN1 = {~(A3 ^ B3)}
+   S3IN2 = {~(Q3 ^ INV3)}
+   S_1 = {S1IN1 ^ S1IN2}
+   S_2 = {S2IN1 ^ S2IN2}
+   S_3 = {S3IN1 ^ S3IN2}

U2 DFF(3) VDD VSS
+ $D_HI RESETBAR CLK
+ D1 D2 D3 Q1 Q2 Q3 $D_NC $D_NC $D_NC
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(1) VDD VSS
+ $D_HI $D_HI CLKBAR
+ CR QRESET $D_NC
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 PINDLY(3,0,10) VDD VSS
+ S_1 S_2 S_3
+ A1 A2 A3 B1 B2 B3 INV1 INV2 INV3 CLK
+ S1 S2 S3
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+         DATA1 = {CHANGED(A1,0) | CHANGED(B1,0) | CHANGED(INV1,0)}
+         DATA2 = {CHANGED(A2,0) | CHANGED(B2,0) | CHANGED(INV2,0)}
+         DATA3 = {CHANGED(A3,0) | CHANGED(B3,0) | CHANGED(INV3,0)}
+         EDGE = {CHANGED_LH(CLK,0)}  
+ PINDLY:
+         S1 = {
+           CASE(
+              DATA1 & (TRN_LH | TRN_HL), DELAY(-1,280NS,1400NS),
+              EDGE & (TRN_LH | TRN_HL), DELAY(-1,500NS,2400NS),
+              DELAY(-1,501NS,2401NS))}
+         S2 = {
+           CASE(
+              DATA2 & (TRN_LH | TRN_HL), DELAY(-1,280NS,1400NS),
+              EDGE & (TRN_LH | TRN_HL), DELAY(-1,500NS,2400NS),
+              DELAY(-1,501NS,2401NS))}
+         S3 = {
+           CASE(
+              DATA3 & (TRN_LH | TRN_HL), DELAY(-1,280NS,1400NS),
+              EDGE & (TRN_LH | TRN_HL), DELAY(-1,500NS,2400NS),
+              DELAY(-1,501NS,2401NS))}

U5 CONSTRAINT(10) VDD VSS
+ CLK A1 A2 A3 B1 B2 B3 INV1 INV2 INV3
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ FREQ:
+      NODE = CLK
+      MAXFREQ = 4MEG
+ SETUP_HOLD:
+      CLOCK LH = CLK
+      DATA(9) = A1 A2 A3 B1 B2 B3 INV1 INV2 INV3
+      SETUPTIME = 10NS

.ENDS CD4032B

*-------------------------------------------------------------CD4033B------

* CMOS Decade Counters/Dividers
* Harris AnswerFax document # 1118
* jat 12/14/95
* Note that the logic diagram is wrong.  The error occurs at the two 
* cascaded OR gates feeding data into flip flop #3.  One way to fix it is
* to add an inverting bubble at the output of the first stage OR gate, before
* it is NORed with Q2BAR.

.SUBCKT CD4033B CLK CLKINH RESET RBI RBO LAMPTEST A B C D E F G CARRYOUT
+ OPTIONAL: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(14,11) VDD VSS
+ CLKINH RESET Q1 Q2 Q3 Q4 Q5 Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR LAMPTEST RBI
+ CLKINHBAR RESETBAR D3 AO BO CO DO EO FO GO RIPPLE
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLKINHBAR = {~CLKINH}
+   RESETBAR = {~RESET}
+   D3 = {Q2 & (Q1 | Q3)}
+   OR1 = {Q4BAR | Q5}
+   OR2 = {Q2 | Q1BAR}
+   OR3 = {Q1BAR | Q5BAR}
+   OR4 = {Q1 | Q2BAR}
+   OR5 = {Q2BAR | Q3}
+   OR6 = {Q2 | Q3BAR}
+   OR7 = {Q1 | Q5}
+   OR8 = {Q3 | Q4BAR}
+   OR9 = {Q3BAR | Q4}
+   RIPPLE = {RBI | OR7}
+   AO = {LAMPTEST | (OR1 & OR2 & RIPPLE)}
+   BO = {LAMPTEST | (OR3 & OR4 & RIPPLE)}
+   CO = {LAMPTEST | (OR5 & RIPPLE)}
+   DO = {LAMPTEST | (OR6 & OR1 & OR2 & RIPPLE)}
+   EO = {LAMPTEST | (RIPPLE & (~(OR7 & OR4 & OR5 & OR8)))}
+   FO = {LAMPTEST | (OR5 & OR9 & OR2 & OR6 & RIPPLE)}
+   GO = {LAMPTEST | (OR6 & OR2 & OR7 & RIPPLE)}

U2 AND(2) VDD VSS
+ CLK CLKINHBAR CL
+ D0_GATE IO_4000B_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(5) VDD VSS
+ $D_HI RESETBAR CL
+ Q5BAR Q1 D3 Q3 Q4
+ Q1 Q2 Q3 Q4 Q5
+ Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 PINDLY(9,0,2) VDD VSS
+ Q5BAR AO BO CO DO EO FO GO RIPPLE
+ CL RESET
+ CARRYOUT A B C D E F G RBO
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    CLOCK = {CHANGED_LH(CL,0)}
+    RST = {CHANGED_LH(RESET,0)}
+ PINDLY:
+    CARRYOUT = {
+       CASE(
+          RST & TRN_LH, DELAY(-1,275NS,550NS),
+          CLOCK & (TRN_LH | TRN_HL), DELAY(-1,250NS,500NS),
+          DELAY(-1,276NS,551NS))}
+    A B C D E F G RBO = {
+       CASE(
+          RST & (TRN_LH | TRN_HL), DELAY(-1,300NS,600NS),
+          CLOCK & (TRN_LH | TRN_HL), DELAY(-1,350NS,700NS),
+          DELAY(-1,351NS,701NS))}

U5 CONSTRAINT(2) VDD VSS
+ CLK RESET
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 5MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 110NS
+   MIN_HI = 110NS
+ WIDTH:
+   NODE = RESET
+   MIN_LO = 100NS
+   MIN_HI = 100NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(1) = RESET
+   SETUPTIME_LO = 30NS

.ENDS CD4033B

*-------------------------------------------------------------CD4035B-----

* CMOS 4 Stage Parallel In/Parallel Out Shift Register
* Harris AnswerFax document # 1101
* jat 12/15/95

.SUBCKT CD4035B PI1 PI2 PI3 PI4 Q1/Q1BAR Q2/Q2BAR Q3/Q3BAR Q4/Q4BAR
+ P/S CLK RESET J KBAR T/C
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(17,9) VDD VSS
+ J KBAR P/S PI1 PI2 PI3 PI4 Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR RESET T/C
+ D1 D2 D3 D4 RESETBAR Q1/Q1BARO Q2/Q2BARO Q3/Q3BARO Q4/Q4BARO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+ D1 = {(((J | Q1) & (KBAR | Q1BAR)) & (~P/S)) | (PI1 & P/S)}
+ D2 = {(Q1 & (~P/S)) | (PI2 & P/S)}
+ D3 = {(Q2 & (~P/S)) | (PI3 & P/S)}
+ D4 = {(Q3 & (~P/S)) | (PI4 & P/S)}
+ RESETBAR = {~RESET}
+ Q1/Q1BARO = {(Q1 & T/C) | (Q1BAR & (~T/C))}
+ Q2/Q2BARO = {(Q2 & T/C) | (Q2BAR & (~T/C))}
+ Q3/Q3BARO = {(Q3 & T/C) | (Q3BAR & (~T/C))}
+ Q4/Q4BARO = {(Q4 & T/C) | (Q4BAR & (~T/C))}

U2 DFF(4) VDD VSS
+ $D_HI RESETBAR CLK
+ D1 D2 D3 D4 Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(4,0,2) VDD VSS
+ Q1/Q1BARO Q2/Q2BARO Q3/Q3BARO Q4/Q4BARO
+ CLK RESET
+ Q1/Q1BAR Q2/Q2BAR Q3/Q3BAR Q4/Q4BAR
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = {CHANGED_LH(CLK,0)}
+   RST = {CHANGED_LH(RESET,0)}
+ PINDLY:
+   Q1/Q1BAR Q2/Q2BAR Q3/Q3BAR Q4/Q4BAR = {
+     CASE(
+       RST & (TRN_LH | TRN_HL), DELAY(-1,230NS,460NS),
+       CLOCK & (TRN_LH | TRN_HL), DELAY(-1,250NS,500NS),
+       DELAY(-1,251NS,501NS))}

U4 CONSTRAINT(8) VDD VSS
+ CLK J KBAR PI1 PI2 PI3 PI4 RESET
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 100NS
+   MIN_HI = 100NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(2) = J KBAR
+   SETUPTIME = 110NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(4) = PI1 PI2 PI3 PI4
+   SETUPTIME = 70NS
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 4MEG
+ WIDTH:
+   NODE = RESET
+   MIN_LO = 125NS
+   MIN_HI = 125NS

.ENDS CD4035B

*-------------------------------------------------------------CD4038B-----

* Triple Serial Adders
* Motorola CMOS Logic Data, 1991, pages 6-92 to 6-96
* jat 8/31/95

.SUBCKT CD4038B
+ A1 A2 A3 B1 B2 B3 S1 S2 S3 INV1 INV2 INV3 CLK CR
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(18,9) VDD VSS
+ CLK CR A1 A2 A3 B1 B2 B3 Q1 Q2 Q3 Q1BAR Q2BAR Q3BAR INV1 INV2 INV3 QRESET
+ CLKBAR CRBAR D1 D2 D3 RESETBAR S_1 S_2 S_3
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLKBAR = {~CLK}
+   CRBAR = {~CR}
+   D1 = {~((Q1BAR & A1) | (A1 & B1) | (Q1BAR & B1))}
+   D2 = {~((Q2BAR & A2) | (A2 & B2) | (Q2BAR & B2))}
+   D3 = {~((Q3BAR & A3) | (A3 & B3) | (Q3BAR & B3))}
+   RESETBAR = {~(QRESET & CLKBAR)}
+   S1IN1 = {~(A1 ^ B1)}
+   S1IN2 = {~(Q1 ^ (~INV1))}
+   S2IN1 = {~(A2 ^ B2)}
+   S2IN2 = {~(Q2 ^ (~INV2))}
+   S3IN1 = {~(A3 ^ B3)}
+   S3IN2 = {~(Q3 ^ (~INV3))}
+   S_1 = {~(S1IN1 ^ S1IN2)}
+   S_2 = {~(S2IN1 ^ S2IN2)}
+   S_3 = {~(S3IN1 ^ S3IN2)}

U2 DFF(3) VDD VSS
+ $D_HI RESETBAR CLKBAR
+ D1 D2 D3 Q1 Q2 Q3 Q1BAR Q2BAR Q3BAR 
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(1) VDD VSS
+ $D_HI $D_HI CLK
+ CRBAR QRESET $D_NC
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 PINDLY(3,0,10) VDD VSS
+ S_1 S_2 S_3
+ A1 A2 A3 B1 B2 B3 INV1 INV2 INV3 CLK
+ S1 S2 S3
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+         DATA1 = {CHANGED(A1,0) | CHANGED(B1,0) | CHANGED(INV1,0)}
+         DATA2 = {CHANGED(A2,0) | CHANGED(B2,0) | CHANGED(INV2,0)}
+         DATA3 = {CHANGED(A3,0) | CHANGED(B3,0) | CHANGED(INV3,0)}
+         EDGE = {CHANGED_HL(CLK,0)}  
+ PINDLY:
+         S1 = {
+           CASE(
+              DATA1 & (TRN_LH | TRN_HL), DELAY(-1,280NS,1400NS),
+              EDGE & (TRN_LH | TRN_HL), DELAY(-1,500NS,2400NS),
+              DELAY(-1,501NS,2401NS))}
+         S2 = {
+           CASE(
+              DATA2 & (TRN_LH | TRN_HL), DELAY(-1,280NS,1400NS),
+              EDGE & (TRN_LH | TRN_HL), DELAY(-1,500NS,2400NS),
+              DELAY(-1,501NS,2401NS))}
+         S3 = {
+           CASE(
+              DATA3 & (TRN_LH | TRN_HL), DELAY(-1,280NS,1400NS),
+              EDGE & (TRN_LH | TRN_HL), DELAY(-1,500NS,2400NS),
+              DELAY(-1,501NS,2401NS))}

U5 CONSTRAINT(10) VDD VSS
+ CLK A1 A2 A3 B1 B2 B3 INV1 INV2 INV3
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ FREQ:
+      NODE = CLK
+      MAXFREQ = 4MEG
+ SETUP_HOLD:
+      CLOCK LH = CLK
+      DATA(9) = A1 A2 A3 B1 B2 B3 INV1 INV2 INV3
+      SETUPTIME = 10NS

.ENDS CD4038B


* ----------------------------------------------------------- CD4040B ----
*
*  12-Stage Binary Counter
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-108 to 6-111
*  jds    6/8/94
*  This part is shown in the data book as MC14040B
*
.SUBCKT CD4040B CLK RESET Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0

USTBUF BUF VDD VSS
+ CLK CLKST
+ D0_GATE IO_4000B_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

uf0 inv VDD VSS
+   RESET clr
+   D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf1 jkff(1) VDD VSS
+   $D_HI clr CLKST $D_HI $D_HI Q1_O Q1BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf2 jkff(1) VDD VSS
+   $D_HI clr Q1_O $D_HI $D_HI Q2_O Q2BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf3 jkff(1) VDD VSS
+   $D_HI clr Q2_O $D_HI $D_HI Q3_O Q3BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf4 jkff(1) VDD VSS
+   $D_HI clr Q3_O $D_HI $D_HI Q4_O Q4BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf5 jkff(1) VDD VSS
+   $D_HI clr Q4_O $D_HI $D_HI Q5_O Q5BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf6 jkff(1) VDD VSS
+   $D_HI clr Q5_O $D_HI $D_HI Q6_O Q6BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf7 jkff(1) VDD VSS
+   $D_HI clr Q6_O $D_HI $D_HI Q7_O Q7BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf8 jkff(1) VDD VSS
+   $D_HI clr Q7_O $D_HI $D_HI Q8_O Q8BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf9 jkff(1) VDD VSS
+   $D_HI clr Q8_O $D_HI $D_HI Q9_O Q9BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf10 jkff(1) VDD VSS
+   $D_HI clr Q9_O $D_HI $D_HI Q10_O Q10BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf11 jkff(1) VDD VSS
+   $D_HI clr Q10_O $D_HI $D_HI Q11_O Q11BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf12 jkff(1) VDD VSS
+   $D_HI clr Q11_O $D_HI $D_HI Q12_O Q12BAR_O
+   D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Udly PINDLY (12,0,13) VDD VSS
+    Q1_O Q2_O Q3_O Q4_O Q5_O Q6_O Q7_O Q8_O Q9_O Q10_O Q11_O Q12_O
+    CLK RESET Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR Q6BAR Q7BAR
+    Q8BAR Q9BAR Q10BAR Q11BAR
+    Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12
+    IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    PINDLY:
+       Q1  = {
+            CASE(
+                 CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+                 CHANGED_HL(CLK,0), DELAY(-1,260ns,520ns),
+                 DELAY(-1,261ns,521ns)
+                )
+            }
+       Q2  = {
+            CASE(
+                 CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+                 CHANGED_HL(Q1_O,0), DELAY(-1,384.1ns,768.2ns),
+                 DELAY(-1,385.1ns,769.2ns)
+                )
+            }
+       Q3  = {
+            CASE(
+                 CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+                 CHANGED_HL(Q2_O,0), DELAY(-1,508.2ns,1016.4ns),
+                 DELAY(-1,509.2ns,1017.4ns)
+                )
+            }
+       Q4  = {
+            CASE(
+                 CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+                 CHANGED_HL(Q3_O,0), DELAY(-1,632.3ns,1264.6ns),
+                 DELAY(-1,633.3ns,1265.6ns)
+                )
+            }
+       Q5  = {
+            CASE(
+                 CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+                 CHANGED_HL(Q4_O,0), DELAY(-1,756.4ns,1512.8ns),
+                 DELAY(-1,757.4ns,1513.8ns)
+                )
+            }
+       Q6  = {
+            CASE(
+                 CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+                 CHANGED_HL(Q5_O,0), DELAY(-1,880.5ns,1761ns),
+                 DELAY(-1,881.5ns,1762ns)
+                )
+            }
+       Q7  = {
+            CASE(
+                 CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+                 CHANGED_HL(Q6_O,0), DELAY(-1,1004.6ns,2009.2ns),
+                 DELAY(-1,1005.6ns,2010.2ns)
+                )
+            }
+       Q8  = {
+            CASE(
+                 CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+                 CHANGED_HL(Q7_O,0), DELAY(-1,1128.7ns,2257.4ns),
+                 DELAY(-1,1129.7ns,2258.4ns)
+                )
+            }
+       Q9  = {
+            CASE(
+                 CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+                 CHANGED_HL(Q8_O,0), DELAY(-1,1252.8ns,2505.6ns),
+                 DELAY(-1,1253.8ns,2506.6ns)
+                )
+            }
+       Q10  = {
+            CASE(
+                 CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+                 CHANGED_HL(Q9_O,0), DELAY(-1,1376.9ns,2753.8ns),
+                 DELAY(-1,1377.9ns,2754.8ns)
+                )
+            }
+       Q11  = {
+            CASE(
+                 CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+                 CHANGED_HL(Q10_O,0), DELAY(-1,1501ns,3002ns),
+                 DELAY(-1,1502ns,3003ns)
+                )
+            }
+       Q12  = {
+            CASE(
+                 CHANGED(RESET,0) & TRN_HL, DELAY(-1,370ns,740ns),
+                 CHANGED_HL(Q11_O,0), DELAY(-1,1625ns,3250ns),
+                 DELAY(-1,1626ns,3251ns)
+                )
+            }

Ucnstr CONSTRAINT(2) VDD VSS
+          CLK RESET
+          IO_4000B
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 2.1MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 140ns
+      WIDTH:
+         NODE = RESET
+         MIN_HI = 320ns
+      SETUP_HOLD:
+        CLOCK HL = CLK
+        DATA(1) = RESET
+        SETUPTIME_LO = 65ns

.ENDS CD4040B
*
*
* ----------------------------------------------------------- CD4041UB ----
*
*  Quad True/Complement Buffer
*
*  The CMOS Logic Data Book, 1988, National Semiconductor Pages 5-128 to 5-131
*  jds    6/8/94
*
.SUBCKT CD4041UB AIN AOUT AOUTBAR
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0

uf0 inv VDD VSS
+   AIN AOUTBAR
+   DLY_INV1 IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

uf1 buf VDD VSS
+   AIN AOUT
+   DLY_BUF1 IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_INV1 ugate (TPLHMN=-1 TPLHTY=75ns TPLHMX=150ns
+                     TPHLMN=-1 TPHLTY=75ns TPHLMX=150ns)

.model DLY_BUF1 ugate (TPLHMN=-1 TPLHTY=60ns TPLHMX=120ns
+                     TPHLMN=-1 TPHLTY=60ns TPHLMX=120ns)

.ENDS CD4041UB
*
*
* ----------------------------------------------------------- CD4042B ----
*
*  Quad Clocked D Latch
*
* The CMOS Logic Data Book, 1988, National Semiconductor Pages 5-132 to 5-136
* jds    6/8/94
*
.SUBCKT CD4042B CLK POL D1 D2 D3 D4 Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0

uf0 nxor VDD VSS
+   CLK POL gate
+   D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Uf2 dltch(4) VDD VSS
+   $D_HI $D_HI gate
+   D1 D2 D3 D4
+   Q1_O Q2_O Q3_O Q4_O
+   Q1BAR_O Q2BAR_O Q3BAR_O Q4BAR_O
+   D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Udly PINDLY (8,0,5) VDD VSS
+   Q1_O Q2_O Q3_O Q4_O Q1BAR_O Q2BAR_O Q3BAR_O Q4BAR_O
+   CLK D1 D2 D3 D4 
+   Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+   IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    PINDLY:
+       Q1  = {
+            CASE(
+                 CHANGED(CLK,0) & (TRN_LH | TRN_HL), DELAY(-1,250ns,500ns),
+                 CHANGED(D1,0) & (TRN_LH | TRN_HL), DELAY(-1,175ns,350ns),
+                 DELAY(-1,251ns,501ns)
+                )
+            }
+       Q1BAR  = {
+            CASE(
+                 CHANGED(CLK,0) & (TRN_LH | TRN_HL), DELAY(-1,250ns,500ns),
+                 CHANGED(D1,0) & (TRN_LH | TRN_HL), DELAY(-1,150ns,300ns),
+                 DELAY(-1,251ns,501ns)
+                )
+            }
+       Q2  = {
+            CASE(
+                 CHANGED(CLK,0) & (TRN_LH | TRN_HL), DELAY(-1,250ns,500ns),
+                 CHANGED(D2,0) & (TRN_LH | TRN_HL), DELAY(-1,175ns,350ns),
+                 DELAY(-1,251ns,501ns)
+                )
+            }
+       Q2BAR  = {
+            CASE(
+                 CHANGED(CLK,0) & (TRN_LH | TRN_HL), DELAY(-1,250ns,500ns),
+                 CHANGED(D2,0) & (TRN_LH | TRN_HL), DELAY(-1,150ns,300ns),
+                 DELAY(-1,251ns,501ns)
+                )
+            }
+       Q3  = {
+            CASE(
+                 CHANGED(CLK,0) & (TRN_LH | TRN_HL), DELAY(-1,250ns,500ns),
+                 CHANGED(D3,0) & (TRN_LH | TRN_HL), DELAY(-1,175ns,350ns),
+                 DELAY(-1,251ns,501ns)
+                )
+            }
+       Q3BAR  = {
+            CASE(
+                 CHANGED(CLK,0) & (TRN_LH | TRN_HL), DELAY(-1,250ns,500ns),
+                 CHANGED(D3,0) & (TRN_LH | TRN_HL), DELAY(-1,150ns,300ns),
+                 DELAY(-1,251ns,501ns)
+                )
+            }
+       Q4  = {
+            CASE(
+                 CHANGED(CLK,0) & (TRN_LH | TRN_HL), DELAY(-1,250ns,500ns),
+                 CHANGED(D4,0) & (TRN_LH | TRN_HL), DELAY(-1,175ns,350ns),
+                 DELAY(-1,251ns,501ns)
+                )
+            }
+       Q4BAR  = {
+            CASE(
+                 CHANGED(CLK,0) & (TRN_LH | TRN_HL), DELAY(-1,250ns,500ns),
+                 CHANGED(D4,0) & (TRN_LH | TRN_HL), DELAY(-1,150ns,300ns),
+                 DELAY(-1,251ns,501ns)
+                )
+            }

Ucnstr CONSTRAINT(6) VDD VSS
+          CLK D1 D2 D3 D4 POL
+          IO_4000B IO_LEVEL={IO_LEVEL}
+
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 100ns
+         MIN_LO = 100ns
+      SETUP_HOLD:
+         CLOCK LH = CLK
+         DATA(4) = D1 D2 D3 D4
+         HOLDTIME = 60NS
+         WHEN = {POL == '0}
+      SETUP_HOLD:
+         CLOCK HL = CLK
+         DATA(4) = D1 D2 D3 D4
+         HOLDTIME = 60NS
+         WHEN = {POL == '1}

.ENDS CD4042B
*
*
* ----------------------------------------------------------- CD4043B ----
*
*  Quad Tri-State NOR R/S Latch
*
*  The CMOS Logic Data Book, 1988, National Semiconductor Pages 5-137 to 5-140
*  jds    6/8/94
*
.SUBCKT CD4043B R1 R2 R3 R4 S1 S2 S3 S4 Q1 Q2 Q3 Q4 EN
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0

U1 srff(4) VDD VSS
+   $D_HI $D_HI $D_HI
+   S1 S2 S3 S4
+   R1 R2 R3 R4
+   Q1_O Q2_O Q3_O Q4_O
+   $D_NC $D_NC $D_NC $D_NC 
+   D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Udly PINDLY (4,1,8) VDD VSS
+    Q1_O Q2_O Q3_O Q4_O
+    EN
+    S1 S2 S3 S4 R1 R2 R3 R4
+    Q1 Q2 Q3 Q4
+    IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    TRISTATE:
+       ENABLE HI = EN
+       Q1 = {
+          CASE(
+              TRN_HZ | TRN_ZH, DELAY(-1,115ns,230ns),
+              TRN_LZ | TRN_ZL, DELAY(-1,100ns,200ns),
+              CHANGED(S1,0) | CHANGED(R1,0), DELAY(-1,175ns,350ns),
+              DELAY(-1,176ns,351ns)
+              )
+            }
+       Q2 = {
+          CASE(
+              TRN_HZ | TRN_ZH, DELAY(-1,115ns,230ns),
+              TRN_LZ | TRN_ZL, DELAY(-1,100ns,200ns),
+              CHANGED(S2,0) | CHANGED(R2,0), DELAY(-1,175ns,350ns),
+              DELAY(-1,176ns,351ns)
+              )
+            }
+       Q3 = {
+          CASE(
+              TRN_HZ | TRN_ZH, DELAY(-1,115ns,230ns),
+              TRN_LZ | TRN_ZL, DELAY(-1,100ns,200ns),
+              CHANGED(S3,0) | CHANGED(R3,0), DELAY(-1,175ns,350ns),
+              DELAY(-1,176ns,351ns)
+              )
+            }
+       Q4 = {
+          CASE(
+              TRN_HZ | TRN_ZH, DELAY(-1,115ns,230ns),
+              TRN_LZ | TRN_ZL, DELAY(-1,100ns,200ns),
+              CHANGED(S4,0) | CHANGED(R4,0), DELAY(-1,175ns,350ns),
+              DELAY(-1,176ns,351ns)
+              )
+            }

Ucnstr CONSTRAINT(8) VDD VSS
+          S1 S2 S3 S4 R1 R2 R3 R4
+          IO_4000B IO_LEVEL={IO_LEVEL}
+
+      WIDTH:
+         NODE = S1
+         MIN_HI = 80ns
+         MIN_LO = 80ns
+      WIDTH:
+         NODE = R1
+         MIN_HI = 80ns
+         MIN_LO = 80ns
+      WIDTH:
+         NODE = S2
+         MIN_HI = 80ns
+         MIN_LO = 80ns
+      WIDTH:
+         NODE = R2
+         MIN_HI = 80ns
+         MIN_LO = 80ns
+      WIDTH:
+         NODE = S3
+         MIN_HI = 80ns
+         MIN_LO = 80ns
+      WIDTH:
+         NODE = R3
+         MIN_HI = 80ns
+         MIN_LO = 80ns
+      WIDTH:
+         NODE = S4
+         MIN_HI = 80ns
+         MIN_LO = 80ns
+      WIDTH:
+         NODE = R4
+         MIN_HI = 80ns
+         MIN_LO = 80ns

.ENDS CD4043B
*
*
* ----------------------------------------------------------- CD4044B ----
*
*  Quad Tri-State NAND R/S Latch
*
*  The CMOS Logic Data Book, 1988, National Semiconductor Pages 5-137 to 5-140
*  jds    6/8/94
*
.SUBCKT CD4044B R1 R2 R3 R4 S1 S2 S3 S4 Q1 Q2 Q3 Q4 EN
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0

UINV INVA(8) VDD VSS
+ S1 S2 S3 S4 R1 R2 R3 R4
+ S1BAR S2BAR S3BAR S4BAR R1BAR R2BAR R3BAR R4BAR
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U1 srff(4) VDD VSS
+   $D_HI $D_HI $D_HI
+   S1BAR S2BAR S3BAR S4BAR
+   R1BAR R2BAR R3BAR R4BAR
+   Q1_O Q2_O Q3_O Q4_O
+   $D_NC $D_NC $D_NC $D_NC
+   D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

Udly PINDLY (4,1,8) VDD VSS
+    Q1_O Q2_O Q3_O Q4_O
+    EN
+    S1 S2 S3 S4 R1 R2 R3 R4
+    Q1 Q2 Q3 Q4
+    IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    TRISTATE:
+       ENABLE HI = EN
+       Q1 = {
+          CASE(
+              TRN_HZ | TRN_ZH, DELAY(-1,115ns,230ns),
+              TRN_LZ | TRN_ZL, DELAY(-1,100ns,200ns),
+              CHANGED(S1,0) | CHANGED(R1,0), DELAY(-1,175ns,350ns),
+              DELAY(-1,176ns,351ns)
+              )
+            }
+       Q2 = {
+          CASE(
+              TRN_HZ | TRN_ZH, DELAY(-1,115ns,230ns),
+              TRN_LZ | TRN_ZL, DELAY(-1,100ns,200ns),
+              CHANGED(S2,0) | CHANGED(R2,0), DELAY(-1,175ns,350ns),
+              DELAY(-1,176ns,351ns)
+              )
+            }
+       Q3 = {
+          CASE(
+              TRN_HZ | TRN_ZH, DELAY(-1,115ns,230ns),
+              TRN_LZ | TRN_ZL, DELAY(-1,100ns,200ns),
+              CHANGED(S3,0) | CHANGED(R3,0), DELAY(-1,175ns,350ns),
+              DELAY(-1,176ns,351ns)
+              )
+            }
+       Q4 = {
+          CASE(
+              TRN_HZ | TRN_ZH, DELAY(-1,115ns,230ns),
+              TRN_LZ | TRN_ZL, DELAY(-1,100ns,200ns),
+              CHANGED(S4,0) | CHANGED(R4,0), DELAY(-1,175ns,350ns),
+              DELAY(-1,176ns,351ns)
+              )
+            }

Ucnstr CONSTRAINT(8) VDD VSS
+          S1 S2 S3 S4 R1 R2 R3 R4
+          IO_4000B IO_LEVEL={IO_LEVEL}
+
+      WIDTH:
+         NODE = S1
+         MIN_HI = 80ns
+         MIN_LO = 80ns
+      WIDTH:
+         NODE = R1
+         MIN_HI = 80ns
+         MIN_LO = 80ns
+      WIDTH:
+         NODE = S2
+         MIN_HI = 80ns
+         MIN_LO = 80ns
+      WIDTH:
+         NODE = R2
+         MIN_HI = 80ns
+         MIN_LO = 80ns
+      WIDTH:
+         NODE = S3
+         MIN_HI = 80ns
+         MIN_LO = 80ns
+      WIDTH:
+         NODE = R3
+         MIN_HI = 80ns
+         MIN_LO = 80ns
+      WIDTH:
+         NODE = S4
+         MIN_HI = 80ns
+         MIN_LO = 80ns
+      WIDTH:
+         NODE = R4
+         MIN_HI = 80ns
+         MIN_LO = 80ns

.ENDS CD4044B
*
*
*-------------------------------------------------------------CD4048B-----

* Tri-State Expandable 8-Function 8-Input Gate
* National CMOS Logic Databook, 1988, pages 5-154 to 5-160
* jat 9/1/95

.SUBCKT CD4048B
+ A B C D E F G H KA KB KC KD EXP J
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(12,1) VDD VSS
+ A B C D E F G H KA KB KC EXP
+ J_O
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  XNORA = {~((~KA) ^ (~A))}
+  XNORB = {~((~KA) ^ (~B))}
+  XNORC = {~((~KA) ^ (~C))}
+  XNORD = {~((~KA) ^ (~D))}
+  XNORE = {~((~KA) ^ (~E))}
+  XNORF = {~((~KA) ^ (~F))}
+  XNORG = {~((~KA) ^ (~G))}
+  XNORH = {~((~KA) ^ (~H))}
+  NANDAD = {~(XNORA & XNORB & XNORC & XNORD)}
+  NANDEH = {~(XNORE & XNORF & XNORG & XNORH)}
+  XNORTOP = {~(NANDEH ^ KB)}
+  XNORBOT = {~(NANDAD ^ KB)}
+  NANDEXP = {~(XNORTOP & (~EXP) & XNORBOT)}
+  J_O = {~(NANDEXP ^ KC)}

U2 PINDLY(1,1,0) VDD VSS
+ J_O
+ KD
+ J
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+   ENABLE HI = KD
+     J = {
+       CASE(
+         TRN_LZ | TRN_HZ, DELAY(-1,175NS,350NS),
+         TRN_ZL | TRN_ZH, DELAY(-1,225NS,450NS),
+         TRN_LH | TRN_HL, DELAY(-1,425NS,850NS),
+         DELAY(-1,426NS,851NS))}

.ENDS 4048B

* ----------------------------------------------------------- CD4049B ----
*
*  Hex Buffer
*
*  The CMOS Logic Data Book, 1991, Motorola, Pages 6-125 to 6-128
*  jds    6/8/94
*
.SUBCKT CD4049B INA OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0

uf0 inv VDD VSS
+   INA OUTA
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=80ns TPLHMX=140ns
+                     TPHLMN=-1 TPHLTY=40ns TPHLMX=80ns)

.ENDS CD4049B

* ----------------------------------------------------------- CD4049UB ----
*
*  Hex Inverting Buffer
*
*  The CMOS Logic Data Book, 1988, National Semiconductor Pages 5-161 to 5-165
*  jds    6/8/94
*
.SUBCKT CD4049UB A ABAR
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0

uf0 inv VDD VSS
+   A ABAR
+   DLY_MOD IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=45ns TPLHMX=85ns
+                     TPHLMN=-1 TPHLTY=30ns TPHLMX=65ns)

.ENDS CD4049UB
*
*
* ----------------------------------------------------------- CD4050B ----
*
*  Hex Buffer
*
*  The CMOS Logic Data Book, 1988, National Semiconductor Pages 5-161 to 5-165
*  jds    6/8/94
*
.SUBCKT CD4050B AIN AOUT
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0

uf0 buf VDD VSS
+   AIN AOUT
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=60ns TPLHMX=120ns
+                     TPHLMN=-1 TPHLTY=60ns TPHLMX=110ns)

.ENDS CD4050B
*
*
*-------------------------------------------------------------CD4054B----

* CMOS Liquid Crystal Display Driver
* Harris AnswerFax document # 634
* jat 12/15/95

.SUBCKT CD4054B
+ DF IN1 IN2 IN3 IN4 STR1 STR2 STR3 STR4 OUT1 OUT2 OUT3 OUT4
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(9,4) VDD VSS
+ DF Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+ OUT1O OUT2O OUT3O OUT4O
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    OUT1O = {((~DF) & Q1) | (DF & Q1BAR)}
+    OUT2O = {((~DF) & Q2) | (DF & Q2BAR)}
+    OUT3O = {((~DF) & Q3) | (DF & Q3BAR)}
+    OUT4O = {((~DF) & Q4) | (DF & Q4BAR)}

U2 DLTCH(1) VDD VSS
+ $D_HI $D_HI STR1
+ IN1 Q1 Q1BAR
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DLTCH(1) VDD VSS
+ $D_HI $D_HI STR2
+ IN2 Q2 Q2BAR
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 DLTCH(1) VDD VSS
+ $D_HI $D_HI STR3
+ IN3 Q3 Q3BAR
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 DLTCH(1) VDD VSS
+ $D_HI $D_HI STR4
+ IN4 Q4 Q4BAR
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 PINDLY(4,0,0) VDD VSS
+ OUT1O OUT2O OUT3O OUT4O
+ OUT1 OUT2 OUT3 OUT4
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+    OUT1 OUT2 OUT3 OUT4 = {
+       CASE(
+          (TRN_LH | TRN_HL), DELAY(-1,400NS,800NS),
+           DELAY(-1,401NS,801NS))}

U7 CONSTRAINT(8) VDD VSS
+ IN1 IN2 IN3 IN4 STR1 STR2 STR3 STR4
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+   CLOCK LH = STR1
+   DATA(1) = IN1
+   SETUPTIME = 110NS
+ SETUP_HOLD:
+   CLOCK LH = STR2
+   DATA(1) = IN2
+   SETUPTIME = 110NS
+ SETUP_HOLD:
+   CLOCK LH = STR3
+   DATA(1) = IN3
+   SETUPTIME = 110NS
+ SETUP_HOLD:
+   CLOCK LH = STR4
+   DATA(1) = IN4
+   SETUPTIME = 110NS
+ WIDTH:
+   NODE = STR1
+   MIN_LO = 110NS
+   MIN_HI = 110NS
+ WIDTH:
+   NODE = STR2
+   MIN_LO = 110NS
+   MIN_HI = 110NS
+ WIDTH:
+   NODE = STR3
+   MIN_LO = 110NS
+   MIN_HI = 110NS
+ WIDTH:
+   NODE = STR4
+   MIN_LO = 110NS
+   MIN_HI = 110NS

.ENDS CD4054B

*-------------------------------------------------------------CD4055B----

* CMOS Liquid Crystal Display Drivers
* Harris AnswerFax document # 634
* jat 12/15/95

.SUBCKT CD4055B
+ BCD0 BCD1 BCD2 BCD3 DFIN DFOUT A B C D E F G
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(5,7) VDD VSS
+ BCD0 BCD1 BCD2 BCD3 DFIN
+ AO BO CO DO EO FO GO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+ AX = {(BCD3 ^ BCD1) | ((~BCD1) & (~(BCD2 ^ BCD0)))}
+ BX = {((~BCD1) & (~BCD0)) | ((~BCD3) & (~BCD2)) | (BCD3 & (~BCD1)) | 
+        ((~BCD2) & BCD0) | ((~BCD3) & BCD1 & BCD0)}
+ CX = {((~BCD3) & BCD2) | ((~BCD1) & BCD0) | ((~BCD2) & BCD0) |
+        ((~BCD2) & (~BCD1))}
+ DX = {((~BCD2) & (~BCD0)) | ((~BCD3) & BCD1 & ((~BCD2) | (~BCD0))) |
+        (BCD3 & (~BCD2) & (~BCD1)) | ((~BCD3) & BCD2 & (~BCD1) & BCD0)}
+ EX = {((~BCD0) & ((~BCD2) | ((~BCD3) & BCD1))) | (BCD3 & (BCD1 ^ BCD2))}
+ FX = {((~BCD1) & ((~BCD0) | BCD2)) | (BCD3 & (~BCD2)) |
+        ((~BCD3) & BCD2 & (~BCD0))}
+ GX = {((~BCD1) & (BCD2 | BCD3)) | (BCD1 & (((~BCD2) & BCD0) |
+        ((~BCD3) & (~BCD0)))) | (BCD2 & (~BCD0))}
+ AO = {AX ^ DFIN}
+ BO = {BX ^ DFIN}
+ CO = {CX ^ DFIN}
+ DO = {DX ^ DFIN}
+ EO = {EX ^ DFIN}
+ FO = {FX ^ DFIN}
+ GO = {GX ^ DFIN}

U2 PINDLY(8,0,0) VDD VSS
+ AO BO CO DO EO FO GO DFIN
+ A B C D E F G DFOUT
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+    A B C D E F G DFOUT = {
+       CASE(
+          (TRN_LH | TRN_HL), DELAY(-1,650NS,1300NS),
+           DELAY(-1,651NS,1301NS))}

.ENDS CD4055B

*-------------------------------------------------------------CD4056B----

* CMOS Liquid Crystal Display Drivers
* Harris AnswerFax document # 634
* jat 12/15/95

.SUBCKT CD4056B
+ BCD0 BCD1 BCD2 BCD3 DFIN STR A B C D E F G
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(5,7) VDD VSS
+ BCD0L BCD1L BCD2L BCD3L DFIN
+ AO BO CO DO EO FO GO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+ AX = {(BCD3L ^ BCD1L) | ((~BCD1L) & (~(BCD2L ^ BCD0L)))}
+ BX = {((~BCD1L) & (~BCD0L)) | ((~BCD3L) & (~BCD2L)) | (BCD3L & (~BCD1L)) | 
+        ((~BCD2L) & BCD0L) | ((~BCD3L) & BCD1L & BCD0L)}
+ CX = {((~BCD3L) & BCD2L) | ((~BCD1L) & BCD0L) | ((~BCD2L) & BCD0L) |
+        ((~BCD2L) & (~BCD1L))}
+ DX = {((~BCD2L) & (~BCD0L)) | ((~BCD3L) & BCD1L & ((~BCD2L) | (~BCD0L))) |
+        (BCD3L & (~BCD2L) & (~BCD1L)) | ((~BCD3L) & BCD2L & (~BCD1L) & BCD0L)}
+ EX = {((~BCD0L) & ((~BCD2L) | ((~BCD3L) & BCD1L))) | (BCD3L & (BCD1L ^ BCD2L))}
+ FX = {((~BCD1L) & ((~BCD0L) | BCD2L)) | (BCD3L & (~BCD2L)) |
+        ((~BCD3L) & BCD2L & (~BCD0L))}
+ GX = {((~BCD1L) & (BCD2L | BCD3L)) | (BCD1L & (((~BCD2L) & BCD0L) |
+        ((~BCD3L) & (~BCD0L)))) | (BCD2L & (~BCD0L))}
+ AO = {AX ^ DFIN}
+ BO = {BX ^ DFIN}
+ CO = {CX ^ DFIN}
+ DO = {DX ^ DFIN}
+ EO = {EX ^ DFIN}
+ FO = {FX ^ DFIN}
+ GO = {GX ^ DFIN}

U2 DLTCH(4) VDD VSS
+ $D_HI $D_HI STR
+ BCD3 BCD2 BCD1 BCD0 BCD3L BCD2L BCD1L BCD0L $D_NC $D_NC $D_NC $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(7,0,0) VDD VSS
+ AO BO CO DO EO FO GO
+ A B C D E F G
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+    A B C D E F G = {
+       CASE(
+          (TRN_LH | TRN_HL), DELAY(-1,650NS,1300NS),
+           DELAY(-1,651NS,1301NS))}

U4 CONSTRAINT(5) VDD VSS
+ BCD1 BCD2 BCD3 BCD4 STR
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+   CLOCK LH = STR
+   DATA(1) = BCD1
+   SETUPTIME = 110NS
+ SETUP_HOLD:
+   CLOCK LH = STR
+   DATA(1) = BCD2
+   SETUPTIME = 110NS
+ SETUP_HOLD:
+   CLOCK LH = STR
+   DATA(1) = BCD3
+   SETUPTIME = 110NS
+ SETUP_HOLD:
+   CLOCK LH = STR
+   DATA(1) = BCD4
+   SETUPTIME = 110NS
+ WIDTH:
+   NODE = STR
+   MIN_LO = 110NS
+   MIN_HI = 110NS

.ENDS CD4056B

*-------------------------------------------------------------CD4060B----

* 14 Bit Binary Counter and Oscillator
* Motorola CMOS Logic Data, 1991, pages 6-140 to 6-143
* jat 9/1/95

.SUBCKT CD4060B
+ OUT1 OUT2 RESET CLOCK Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q12 Q13 Q14
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,4) VDD VSS
+ RESET CLOCK
+ RESETBAR CLOCKBAR OUT1 OUT2
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   RESETBAR = {~RESET}
+   CLOCKBAR = {~CLOCK}
+   OUT1 = {CLOCKBAR}
+   OUT2 = {CLOCK}

U2 BUF VDD VSS
+ CLOCKBAR CLOCKBARST
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) VDD VSS
+ $D_HI RESETBAR CLOCKBARST
+ $D_HI $D_HI Q_1 Q_1BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) VDD VSS
+ $D_HI RESETBAR Q_1
+ $D_HI $D_HI Q_2 Q_2BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) VDD VSS
+ $D_HI RESETBAR Q_2
+ $D_HI $D_HI Q_3 Q_3BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 JKFF(1) VDD VSS
+ $D_HI RESETBAR Q_3
+ $D_HI $D_HI Q_4 Q_4BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 JKFF(1) VDD VSS
+ $D_HI RESETBAR Q_4
+ $D_HI $D_HI Q_5 Q_5BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 JKFF(1) VDD VSS
+ $D_HI RESETBAR Q_5
+ $D_HI $D_HI Q_6 Q_6BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 JKFF(1) VDD VSS
+ $D_HI RESETBAR Q_6
+ $D_HI $D_HI Q_7 Q_7BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 JKFF(1) VDD VSS
+ $D_HI RESETBAR Q_7
+ $D_HI $D_HI Q_8 Q_8BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U11 JKFF(1) VDD VSS
+ $D_HI RESETBAR Q_8
+ $D_HI $D_HI Q_9 Q_9BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U12 JKFF(1) VDD VSS
+ $D_HI RESETBAR Q_9
+ $D_HI $D_HI Q_10 Q_10BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U13 JKFF(1) VDD VSS
+ $D_HI RESETBAR Q_10
+ $D_HI $D_HI Q_11 Q_11BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U14 JKFF(1) VDD VSS
+ $D_HI RESETBAR Q_11
+ $D_HI $D_HI Q_12 Q_12BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U15 JKFF(1) VDD VSS
+ $D_HI RESETBAR Q_12
+ $D_HI $D_HI Q_13 Q_13BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U16 JKFF(1) VDD VSS
+ $D_HI RESETBAR Q_13
+ $D_HI $D_HI Q_14 Q_14BAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U17 PINDLY(10,0,11) VDD VSS
+ Q_4 Q_5 Q_6 Q_7 Q_8 Q_9 Q_10 Q_12 Q_13 Q_14
+ RESET Q_3 Q_4 Q_5 Q_6 Q_7 Q_8 Q_9 Q_11 Q_12 Q_13
+ Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q12 Q13 Q14
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+         Q4 = {
+           CASE(
+             CHANGED(RESET,0) & TRN_HL, DELAY(-1,170NS,360NS),
+             CHANGED_HL(Q_3,0) & (TRN_LH | TRN_HL), DELAY(-1,415NS,740NS),
+             DELAY(-1,416NS,741NS))}
+         Q5 = {
+           CASE(
+             CHANGED(RESET,0) & TRN_HL, DELAY(-1,170NS,360NS),
+             CHANGED_HL(Q_4,0) & (TRN_LH | TRN_HL), DELAY(-1,523.5NS,936NS),
+             DELAY(-1,524.5NS,937NS))}
+         Q6 = {
+           CASE(
+             CHANGED(RESET,0) & TRN_HL, DELAY(-1,170NS,360NS),
+             CHANGED_HL(Q_5,0) & (TRN_LH | TRN_HL), DELAY(-1,632NS,1132NS),
+             DELAY(-1,633NS,1133NS))}
+         Q7 = {
+           CASE(
+             CHANGED(RESET,0) & TRN_HL, DELAY(-1,170NS,360NS),
+             CHANGED_HL(Q_6,0) & (TRN_LH | TRN_HL), DELAY(-1,740.5NS,1328NS),
+             DELAY(-1,741.5NS,1329NS))}
+         Q8 = {
+           CASE(
+             CHANGED(RESET,0) & TRN_HL, DELAY(-1,170NS,360NS),
+             CHANGED_HL(Q_7,0) & (TRN_LH | TRN_HL), DELAY(-1,849NS,1524NS),
+             DELAY(-1,850NS,1525NS))}
+         Q9 = {
+           CASE(
+             CHANGED(RESET,0) & TRN_HL, DELAY(-1,170NS,360NS),
+             CHANGED_HL(Q_8,0) & (TRN_LH | TRN_HL), DELAY(-1,957.5NS,1720NS),
+             DELAY(-1,958.5NS,1721NS))}
+         Q10 = {
+           CASE(
+             CHANGED(RESET,0) & TRN_HL, DELAY(-1,170NS,360NS),
+             CHANGED_HL(Q_9,0) & (TRN_LH | TRN_HL), DELAY(-1,1066NS,1916NS),
+             DELAY(-1,1067NS,1917NS))}
+         Q12 = {
+           CASE(
+             CHANGED(RESET,0) & TRN_HL, DELAY(-1,170NS,360NS),
+             CHANGED_HL(Q_11,0) & (TRN_LH | TRN_HL), DELAY(-1,1283NS,2308NS),
+             DELAY(-1,1284NS,2309NS))}
+         Q13 = {
+           CASE(
+             CHANGED(RESET,0) & TRN_HL, DELAY(-1,170NS,360NS),
+             CHANGED_HL(Q_12,0) & (TRN_LH | TRN_HL), DELAY(-1,1391.5NS,2504NS),
+             DELAY(-1,1392.5NS,2505NS))}
+         Q14 = {
+           CASE(
+             CHANGED(RESET,0) & TRN_HL, DELAY(-1,170NS,360NS),
+             CHANGED_HL(Q_13,0) & (TRN_LH | TRN_HL), DELAY(-1,1500NS,2700NS),
+             DELAY(-1,1501NS,2701NS))}

U18 CONSTRAINT(2) VDD VSS
+ CLOCK RESET
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ WIDTH:
+        NODE = CLOCK
+        MIN_HI = 65NS
+        MIN_LO =  65NS
+ FREQ:
+        NODE = CLOCK
+        MAXFREQ = 5MEG
+ WIDTH:
+        NODE = RESET
+        MIN_HI = 40NS

.ENDS CD4060B

*-------------------------------------------------------------CD4063B----

* CMOS 4 Bit Magnitude Comparator
* Harris AnswerFax document # 805
* jat 12/15/95

.SUBCKT CD4063B
+ A0 A1 A2 A3 B0 B1 B2 B3 ALESSBIN AEQBIN AGRTBIN ALESSBOUT AEQBOUT AGRTBOUT
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(11,3) VDD VSS
+ A0 A1 A2 A3 B0 B1 B2 B3 ALESSBIN AEQBIN AGRTBIN
+ ALESSBOUTO AEQBOUTO AGRTBOUTO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  A3BAR = {~A3}
+  A2BAR = {~A2}
+  A1BAR = {~A1}
+  A0BAR = {~A0}
+  B3BAR = {~B3}
+  B2BAR = {~B2}
+  B1BAR = {~B1}
+  B0BAR = {~B0}
+  ALESSBINBAR = {~ALESSBIN}
+  AGRTBINBAR = {~AGRTBIN}
+  NAND3A = {~(B3BAR & A3)}
+  NAND3B = {~(A3BAR & B3)}
+  NAND2A = {~(B2BAR & A2)}
+  NAND2B = {~(A2BAR & B2)}
+  NAND1A = {~(B1BAR & A1)}
+  NAND1B = {~(A1BAR & B1)}
+  NAND0A = {~(B0BAR & A0)}
+  NAND0B = {~(A0BAR & B0)}
+  NAND3 = {~(NAND3A & NAND3B)}
+  NAND2 = {~(NAND2A & NAND2B)}
+  NAND1 = {~(NAND1A & NAND1B)}
+  NAND0 = {~(NAND0A & NAND0B)}
+  OR3L = {NAND3 | NAND2B}
+  OR3G = {NAND3 | NAND2A}
+  OR2L = {NAND3 | NAND2 | NAND1B}
+  OR2G = {NAND3 | NAND2 | NAND1A}
+  OR1L = {NAND3 | NAND2 | NAND1 | NAND0B}
+  OR1G = {NAND3 | NAND2 | NAND1 | NAND0A}
+  OR0L = {NAND3 | NAND2 | NAND1 | NAND0 | ALESSBINBAR}
+  OR0G = {NAND3 | NAND2 | NAND1 | NAND0 | AGRTBINBAR}
+  ALESSBOUTO = {~(NAND3B & OR3L & OR2L & OR1L & OR0L)}
+  AGRTBOUTO = {~(NAND3A & OR3G & OR2G & OR1G & OR0G)}
+  AEQBOUTO = {(~ALESSBOUTO) & (~AGRTBOUTO) & AEQBIN}

U2 PINDLY(3,0,11) VDD VSS
+ ALESSBOUTO AGRTBOUTO AEQBOUTO
+ A0 A1 A2 A3 B0 B1 B2 B3 ALESSBIN AEQBIN AGRTBIN
+ ALESSBOUT AGRTBOUT AEQBOUT
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 
+ BOOLEAN:
+    COMPARING = {CHANGED(A0,0) | CHANGED(A1,0) | CHANGED(A2,0) |
+                 CHANGED(A3,0) | CHANGED(B0,0) | CHANGED(B1,0) | 
+                 CHANGED(B2,0) | CHANGED(B3,0)}
+    CASCADING = {CHANGED(ALESSBIN,0) | CHANGED(AEQBIN,0) | CHANGED(AGRTBIN,0)}
+ PINDLY:
+    ALESSBOUT AGRTBOUT AEQBOUT = {
+       CASE(
+          CASCADING & (TRN_LH | TRN_HL), DELAY(-1,500NS,1000NS),
+          COMPARING & (TRN_LH | TRN_HL), DELAY(-1,625NS,1250NS),
+          DELAY(-1,626NS,1251NS))}

.ENDS CD4063B

* ----------------------------------------------------------- CD4068B----
*
*  8-Input NAND Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-5 to 6-14
*  jds    6/6/94
*  This part is shown in the data book as MC14068B
*
.SUBCKT CD4068B IN1 IN2 IN3 IN4 IN5 IN6 IN7 IN8 OUT
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 nand(8) VDD VSS
+   IN1 IN2 IN3 IN4 IN5 IN6 IN7 IN8 OUT
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=200ns TPLHMX=350ns
+                     TPHLMN=-1 TPHLTY=200ns TPHLMX=350ns)

.ENDS CD4068B
*
*
* ----------------------------------------------------------- CD4069UB ----
*
*  Hex Inverting Buffer
*
*  The CMOS Logic Data Book, 1988, National Semiconductor Pages 5-180 to 5-183
*  jds    6/8/94
*
.SUBCKT CD4069UB A ABAR
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0

uf0 inv VDD VSS
+   A ABAR
+   DLY_MOD IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=50ns TPLHMX=90ns
+                     TPHLMN=-1 TPHLTY=50ns TPHLMX=90ns)

.ENDS CD4069UB
*
*
* ----------------------------------------------------------- CD4070B ----
*
*  Quad 2-Input XOR Gate
*
*  The CMOS Logic Data Book, 1988, National Semiconductor Pages 5-184 to 5-187
*  jds    6/8/94
*
.SUBCKT CD4070B IN1A IN2A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0

uf0 xor VDD VSS
+   IN1A IN2A OUTA
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=110ns TPLHMX=185ns
+                     TPHLMN=-1 TPHLTY=110ns TPHLMX=185ns)

.ENDS CD4070B
*
*
* ----------------------------------------------------------- CD4071B----
*
*  Quad 2-Input OR Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-5 to 6-14
*  jds    6/6/94
*  This part is shown in the data book as MC14071B
*
.SUBCKT CD4071B IN1A IN2A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 or(2) VDD VSS
+   IN1A IN2A OUTA
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=160ns TPLHMX=300ns
+                     TPHLMN=-1 TPHLTY=160ns TPHLMX=300ns)

.ENDS CD4071B
*
*
* ----------------------------------------------------------- CD4072B----
*
*  Dual 4-Input OR Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-5 to 6-14
*  jds    6/6/94
*  This part is shown in the data book as MC14072B
*
.SUBCKT CD4072B IN1A IN2A IN3A IN4A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 or(4) VDD VSS
+   IN1A IN2A IN3A IN4A OUTA
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=160ns TPLHMX=300ns
+                     TPHLMN=-1 TPHLTY=160ns TPHLMX=300ns)

.ENDS CD4072B
*
*
* ----------------------------------------------------------- CD4073B----
*
*  Triple 3-Input AND Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-5 to 6-14
*  jds    6/6/94
*  This part is shown in the data book as MC14073B
*
.SUBCKT CD4073B IN1A IN2A IN3A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 and(3) VDD VSS
+   IN1A IN2A IN3A OUTA
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=160ns TPLHMX=300ns
+                     TPHLMN=-1 TPHLTY=160ns TPHLMX=300ns)

.ENDS CD4073B
*
*
* ----------------------------------------------------------- CD4075B----
*
*  Triple 3-Input OR Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-5 to 6-14
*  jds    6/6/94
*  This part is shown in the data book as MC14075B
*
.SUBCKT CD4075B IN1A IN2A IN3A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 or(3) VDD VSS
+   IN1A IN2A IN3A OUTA
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=160ns TPLHMX=300ns
+                     TPHLMN=-1 TPHLTY=160ns TPHLMX=300ns)

.ENDS CD4075B
*
*
*-----------------------------------------------------------CD4076B------

* Quad D Flip-Flop
* National CMOS Logic Databook, 1988, pages 5-201 to 5-205
* jat 9/1/95

.SUBCKT CD4076B
+ INA INB INC IND OUTA OUTB OUTC OUTD CLOCK CLEAR INDIS1 INDIS2 OUTDIS1
+ OUTDIS2
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS

U1 LOGICEXP(13,6) VDD VSS
+ INA INB INC IND OUT_A OUT_B OUT_C OUT_D INDIS1 INDIS2 OUTDIS1 OUTDIS2 CLEAR
+ DA DB DC DD OUTDIS CLRBAR
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  INYES = {~(INDIS1 | INDIS2)}
+  INNO = {~INYES}
+  DA = {(INA & INYES) | (OUT_A & INNO)}
+  DB = {(INB & INYES) | (OUT_B & INNO)}
+  DC = {(INC & INYES) | (OUT_C & INNO)}
+  DD = {(IND & INYES) | (OUT_D & INNO)}
+  OUTDIS = {~(OUTDIS1 | OUTDIS2)}
+  CLRBAR = {~CLEAR}

U2 DFF(4) VDD VSS
+ $D_HI CLRBAR CLOCK
+ DA DB DC DD
+ OUT_A OUT_B OUT_C OUT_D
+ $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(4,1,1) VDD VSS
+ OUT_A OUT_B OUT_C OUT_D
+ OUTDIS
+ CLEAR
+ OUTA OUTB OUTC OUTD
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+     ENABLE HI = OUTDIS
+     OUTA OUTB OUTC OUTD = {
+        CASE(
+           TRN_$Z | TRN_Z$, DELAY(-1,170NS,340NS),
+           CHANGED(CLEAR,0) & TRN_HL, DELAY(-1,240NS,490NS),
+           TRN_LH | TRN_HL, DELAY(-1,220NS,400NS),
+           DELAY(-1,241NS,491NS))}

U4 CONSTRAINT(8) VDD VSS
+ CLOCK INA INB INC IND INDIS1 INDIS2 CLEAR
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+             CLOCK LH = CLOCK
+             DATA(4) = INA INB INC IND
+             SETUPTIME = 40NS
+ SETUP_HOLD:
+             CLOCK LH = CLOCK
+             DATA(2) = INDIS1 INDIS2
+             SETUPTIME_HI = 100NS
+ FREQ:
+       NODE = CLOCK
+       MAXFREQ = 4MEG
+ WIDTH:
+       NODE = CLEAR
+       MIN_HI = 150NS

.ENDS CD4076B

*-----------------------------------------------------------CD4077B----

* Quad 2-Input XNOR Gate
* Motorola CMOS Logic Data, 1991, pages 6-160 to 6-161
* jat 9/1/95

.SUBCKT CD4077B IN1A IN2A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0

uf0 NXOR VDD VSS
+   IN1A IN2A OUTA
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=175ns TPLHMX=350ns
+                     TPHLMN=-1 TPHLTY=175ns TPHLMX=350ns)

.ENDS CD4077B

* ----------------------------------------------------------- CD4078B----
*
*  8-Input NOR Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-5 to 6-14
*  jds    6/6/94
*  This part is shown in the data book as MC14078B
*
.SUBCKT CD4078B IN1 IN2 IN3 IN4 IN5 IN6 IN7 IN8 OUT
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 nor(8) VDD VSS
+   IN1 IN2 IN3 IN4 IN5 IN6 IN7 IN8 OUT
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=200ns TPLHMX=350ns
+                     TPHLMN=-1 TPHLTY=200ns TPHLMX=350ns)

.ENDS CD4078B
*
*
* ----------------------------------------------------------- CD4081B----
*
*  Quad 2-Input AND Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-5 to 6-14
*  jds    6/6/94
*  This part is shown in the data book as MC14081B
*
.SUBCKT CD4081B IN1A IN2A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 and(2) VDD VSS
+   IN1A IN2A OUTA
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=160ns TPLHMX=300ns
+                     TPHLMN=-1 TPHLTY=160ns TPHLMX=300ns)

.ENDS CD4081B
*
*
* ----------------------------------------------------------- CD4082B----
*
*  Dual 4-Input AND Gate
*
*  The CMOS Logic Data Book, 1991, Motorola Pages 6-5 to 6-14
*  jds    6/6/94
*  This part is shown in the data book as MC14082B
*
.SUBCKT CD4082B IN1A IN2A IN3A IN4A OUTA
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 and(4) VDD VSS
+   IN1A IN2A IN3A IN4A OUTA
+   DLY_MOD IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=160ns TPLHMX=300ns
+                     TPHLMN=-1 TPHLTY=160ns TPHLMX=300ns)

.ENDS CD4082B
*
*
*-------------------------------------------------------------CD4085B----

* CMOS Dual 2-Wide, 2-Input AND-OR-INVERT Gate
* Harris AnswerFax document # 811
* jat 12/18/95

.SUBCKT CD4085B
+ A B C D E INH
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(5,1) VDD VSS
+ A B C D INH
+ EO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    EO = {~(INH | (A & B ) | (C & D))}

U2 PINDLY(1,0,5) VDD VSS
+ EO
+ A B C D INH
+ E
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   INHIBIT = {CHANGED(INH,0)}
+   DATA = {CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0)}
+ PINDLY:
+   E = {
+     CASE(
+         INHIBIT & TRN_LH, DELAY(-1,250NS,500NS),
+         INHIBIT & TRN_HL, DELAY(-1,150NS,300NS),
+         DATA & TRN_LH, DELAY(-1,310NS,620NS),
+         DATA & TRN_HL, DELAY(-1,225NS,450NS),
+         DELAY(-1,311NS,621NS))}

.ENDS CD4085B

*-------------------------------------------------------------CD4086B----

* CMOS Expandable 4-Wide 2-Input AND-OR-INVERT Gate
* Harris AnswerFax document # 812
* jat 12/18/95

.SUBCKT CD4086B
+ A B C D E F G H INH ENAB J
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(10,1) VDD VSS
+ A B C D E F G H INH ENAB
+ JO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    JO = {~(INH | (A & B) | (C & D) | (E & F) | (G & H) | (~ENAB))}

U2 PINDLY(1,0,10) VDD VSS
+ JO
+ A B C D E F G H INH ENAB
+ J
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    DATA = {CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) | 
+            CHANGED(E,0) | CHANGED(F,0) | CHANGED(G,0) | CHANGED(H,0)}
+    INHIBIT = {CHANGED(INH,0) | CHANGED(ENAB,0)}
+ PINDLY:
+     J = {
+      CASE(
+    INHIBIT & TRN_LH, DELAY(-1,250NS,500NS),
+    INHIBIT & TRN_HL, DELAY(-1,150NS,300NS),
+    DATA & TRN_LH, DELAY(-1,310NS,620NS),
+    DATA & TRN_HL, DELAY(-1,225NS,450NS),
+    DELAY(-1,311NS,621NS))}

.ENDS CD4086B

*----------------------------------------------------------CD4089B------

* CMOS Binary Rate Multiplier
* Harris AnswerFax document # 1003
* jat 12/18/95

.SUBCKT CD4089B
+ A B C D CLOCK CLEAR SET15 INHIN STR CASC OUT OUTBAR OUT15 INHOUT
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(18,11) VDD VSS
+ CLEAR SET15 CLOCK INHIN STR CASC A B C D QA QB QC QD QABAR QBBAR QCBAR QDBAR
+ CLRBAR SETBAR CLK DA DB DC DD OUTBARO OUTO INHOUTO OUT15O
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    CLRBAR = {~CLEAR}
+    SETBAR = {~SET15}
+    CLK = {CLOCK & (~INHIN)}
+    DA = {QABAR}
+    DB = {QA ^ QB}
+    DC = {(QCBAR & QA & QB) | (QABAR & QC) | (QBBAR & QC)}
+    DD = {(QDBAR & QA & QB & QC) | (QD & (QABAR | QBBAR | QCBAR))}
+    NAND5 = {~(A & QDBAR & QC & QB & QA)}
+    NAND4 = {~(B & QCBAR & QB & QA)}
+    NAND3 = {~(C & QBBAR & QA)}
+    NAND2 = {~(D & QABAR)}
+    AND = {NAND5 & NAND4 & NAND3 & NAND2}
+    OUTBARO = {STR | CLOCK | AND}
+    OUTO = {CASC | (~OUTBARO)}
+    NANDALL = {~(QD & QC & QB & QA)}
+    INHOUTO = {NANDALL | INHIN}
+    OUT15O = {~NANDALL}

U2 DFF(1) VDD VSS
+ SETBAR CLRBAR CLK
+ DA QA QABAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(1) VDD VSS
+ SETBAR CLRBAR CLK
+ DB QB QBBAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 DFF(1) VDD VSS
+ SETBAR CLRBAR CLK
+ DC QC QCBAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 DFF(1) VDD VSS
+ SETBAR CLRBAR CLK
+ DD QD QDBAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 PINDLY(4,0,6) VDD VSS
+ OUTO OUTBARO INHOUTO OUT15O
+ CLOCK CLEAR CASC INH SET15 STR
+ OUT OUTBAR INHOUT OUT15
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CL = {CHANGED(CLOCK,0)}
+   CLR = {CHANGED_LH(CLEAR,0)}
+   CASCADE = {CHANGED(CASC,0)}
+   INHIBIT = {CHANGED(INH,0)}
+   SET = {CHANGED(SET15,0)}
+   STROBE = {CHANGED(STR,0)}
+ PINDLY:
+   OUT = {
+     CASE(
+       SET & (TRN_LH | TRN_HL), DELAY(-1,330NS,660NS),
+       CLR & (TRN_LH | TRN_HL), DELAY(-1,380NS,760NS),
+       CASCADE & (TRN_LH | TRN_HL), DELAY(-1,90NS,180NS),
+       (STROBE | CL) & (TRN_LH | TRN_HL), DELAY(-1,150NS,300NS),
+       DELAY(-1,381NS,761NS))}
+   OUTBAR = {
+     CASE(
+       CL & (TRN_LH | TRN_HL), DELAY(-1,110NS,220NS),
+       DELAY(-1,111NS,221NS))}
+   INHOUT = {
+     CASE(
+       INHIBIT & (TRN_LH | TRN_HL), DELAY(-1,160NS,320NS),
+       CL & TRN_LH, DELAY(-1,250NS,500NS),
+       CL & TRN_HL, DELAY(-1,360NS,720NS),
+       DELAY(-1,361NS,721NS))}
+   OUT15 = {
+      CASE(
+        CL & (TRN_LH | TRN_HL), DELAY(-1,300NS,600NS),
+        DELAY(-1,301NS,601NS))}

U7 CONSTRAINT(4) VDD VSS
+ CLOCK SET15 CLEAR INHIN
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLOCK
+  MAXFREQ = 2.4MEG
+ WIDTH:
+  NODE = CLOCK
+  MIN_HI = 165NS
+  MIN_LO = 165NS
+ WIDTH:
+  NODE = SET15
+  MIN_LO = 80NS
+  MIN_HI = 80NS
+ WIDTH:
+  NODE = CLEAR
+  MIN_LO = 80NS
+  MIN_HI = 80NS
+ SETUP_HOLD:
+   CLOCK LH = CLOCK
+   DATA(1) = INHIN
+   SETUPTIME = 50NS
+   HOLDTIME = 120NS
+ SETUP_HOLD:
+   CLOCK LH = CLOCK
+   DATA(1) = SET15
+   SETUPTIME_LO = 75NS
+ SETUP_HOLD:
+   CLOCK LH = CLOCK
+   DATA(1) = CLEAR
+   SETUPTIME_LO = 30NS

.ENDS CD4089B

* ----------------------------------------------------------- CD4093B----
*
*  Quad 2-Input NAND Schmitt Trigger
*
*  The CMOS Logic Data Book, 1988, National, pages 5-214 to 5-218
*  jds    6/9/94
*  This part is shown in the data book as MC14093B
*
.SUBCKT CD4093B A B J
+  optional: VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+  params: MNTYMXDLY=0 IO_LEVEL=0
*
Uf0 nand(2) VDD VSS
+   A B J
+   DLY_MOD IO_4000B_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_MOD ugate (TPLHMN=-1 TPLHTY=300ns TPLHMX=450ns
+                     TPHLMN=-1 TPHLTY=300ns TPHLMX=450ns)

.ENDS CD4093B
*
*
*-------------------------------------------------------------CD4094B-----

* 8 Bit Static Shift Register/Latch with Tri-State Outputs
* National CMOS Logic Databook
* jat 9/7/95

.SUBCKT CD4094B
+ STROBE DATA CLOCK OUTEN Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 QS QSPRIME
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(1,1) VDD VSS
+ CLOCK CLOCKBAR
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLOCKBAR = {~CLOCK}

U2 DFF(8) VDD VSS
+ $D_HI $D_HI CLOCK
+ DATA Q1I Q2I Q3I Q4I Q5I Q6I Q7I
+ Q1I Q2I Q3I Q4I Q5I Q6I Q7I QSO
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(1) VDD VSS
+ $D_HI $D_HI CLOCKBAR
+ QSO QSPRIMEO $D_NC
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 DLTCH(8) VDD VSS
+ $D_HI $D_HI STROBE
+ Q1I Q2I Q3I Q4I Q5I Q6I Q7I QSO
+ Q1O Q2O Q3O Q4O Q5O Q6O Q7O Q8O 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 PINDLY(10,1,2) VDD VSS
+ Q1O Q2O Q3O Q4O Q5O Q6O Q7O Q8O QSO QSPRIMEO
+ OUTEN
+ STROBE CLOCK
+ Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 QS QSPRIME
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   UNLATCH = {CHANGED_LH(STROBE,0)}
+   EDGE = {CHANGED_LH(CLOCK,0)}
+ TRISTATE:
+   ENABLE HI = OUTEN
+      Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 = {
+         CASE(
+            TRN_Z$ | TRN_$Z, DELAY(-1,140NS,280NS),
+            UNLATCH & (TRN_LH | TRN_HL), DELAY(-1,290NS,580NS),
+            EDGE & (TRN_LH | TRN_HL), DELAY(-1,420NS,840NS),
+            DELAY(-1,421NS,841NS))}
+ PINDLY:
+   QS = {
+      CASE(
+         (TRN_LH | TRN_HL), DELAY(-1,300NS,600NS),
+          DELAY(-1,301NS,601NS))}
+ PINDLY:
+   QSPRIME= {
+      CASE(
+         (TRN_LH | TRN_HL), DELAY(-1,230NS,460NS),
+          DELAY(-1,231NS,461NS))}

U6 CONSTRAINT(3) VDD VSS
+ CLOCK DATA STROBE
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+   CLOCK LH = CLOCK
+   DATA(1) = DATA
+   SETUPTIME = 40NS
+ WIDTH:
+  NODE = CLOCK
+  MIN_HI = 100NS
+  MIN_LO = 100NS
+ WIDTH:
+  NODE = STROBE
+  MIN_HI = 100NS
+ FREQ: 
+  NODE = CLOCK
+  MAXFREQ = 3MEG

.ENDS CD4094B

*------------------------------------------------------------CD4095B-----

* CMOS Gated J-K Master-Slave Flip-Flops
* Harris AnswerFax document # 879
* jat 12/18/95

.SUBCKT CD4095B
+ J1 J2 J3 K1 K2 K3 SET RESET CLOCK Q QBAR
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(9,5) VDD VSS
+ J1 J2 J3 K1 K2 K3 SET RESET CLOCK
+ J K SETBAR RESETBAR CLOCKBAR
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   J = {J1 & J2 & J3}
+   K = {K1 & K2 & K3}
+   SETBAR = {~SET}
+   RESETBAR = {~RESET}
+   CLOCKBAR = {~CLOCK}

U2 JKFF(1) VDD VSS
+ SETBAR RESETBAR CLOCKBAR
+ J K QO QOBAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(2,0,3) VDD VSS
+ QO QOBAR
+ CLOCK RESET SET
+ Q QBAR
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    CLK = {CHANGED_LH(CLOCK,0)}
+    SR = {CHANGED(SET,0) | CHANGED(RESET,0)}
+ PINDLY:
+   Q QBAR = {
+     CASE(
+       SR & (TRN_LH | TRN_HL), DELAY(-1,150NS,300NS),
+       CLK & (TRN_LH | TRN_HL), DELAY(-1,250NS,500NS),
+       DELAY(-1,251NS,501NS))}

U4 CONSTRAINT(9) VDD VSS
+ CLOCK SET RESET J1 J2 J3 K1 K2 K3
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ FREQ:
+    NODE = CLOCK
+    MAXFREQ = 7MEG
+ WIDTH:
+    NODE = CLOCK
+    MIN_LO = 70NS
+    MIN_HI = 70NS
+ WIDTH:
+    NODE = SET
+    MIN_LO = 100NS
+    MIN_HI = 100NS
+ WIDTH:
+    NODE = RESET
+    MIN_LO = 100NS
+    MIN_HI = 100NS
+ SETUP_HOLD:
+    CLOCK LH = CLOCK
+    DATA(6) = J1 J2 J3 K1 K2 K3
+    SETUPTIME = 200NS

.ENDS CD4095B

*------------------------------------------------------------CD4096B-----

* CMOS Gated J-K Master-Slave Flip-Flops
* Harris AnswerFax document # 879
* jat 12/18/95

.SUBCKT CD4096B
+ J1 J2 J3BAR K1 K2 K3BAR SET RESET CLOCK Q QBAR
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(9,5) VDD VSS
+ J1 J2 J3BAR K1 K2 K3BAR SET RESET CLOCK
+ J K SETBAR RESETBAR CLOCKBAR
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   J = {J1 & J2 & (~J3BAR)}
+   K = {K1 & K2 & (~K3BAR)}
+   SETBAR = {~SET}
+   RESETBAR = {~RESET}
+   CLOCKBAR = {~CLOCK}

U2 JKFF(1) VDD VSS
+ SETBAR RESETBAR CLOCKBAR
+ J K QO QOBAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(2,0,3) VDD VSS
+ QO QOBAR
+ CLOCK RESET SET
+ Q QBAR
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    CLK = {CHANGED_LH(CLOCK,0)}
+    SR = {CHANGED(SET,0) | CHANGED(RESET,0)}
+ PINDLY:
+   Q QBAR = {
+     CASE(
+       SR & (TRN_LH | TRN_HL), DELAY(-1,150NS,300NS),
+       CLK & (TRN_LH | TRN_HL), DELAY(-1,250NS,500NS),
+       DELAY(-1,251NS,501NS))}

U4 CONSTRAINT(9) VDD VSS
+ CLOCK SET RESET J1 J2 J3BAR K1 K2 K3BAR
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ FREQ:
+    NODE = CLOCK
+    MAXFREQ = 7MEG
+ WIDTH:
+    NODE = CLOCK
+    MIN_LO = 70NS
+    MIN_HI = 70NS
+ WIDTH:
+    NODE = SET
+    MIN_LO = 100NS
+    MIN_HI = 100NS
+ WIDTH:
+    NODE = RESET
+    MIN_LO = 100NS
+    MIN_HI = 100NS
+ SETUP_HOLD:
+    CLOCK LH = CLOCK
+    DATA(6) = J1 J2 J3BAR K1 K2 K3BAR
+    SETUPTIME = 200NS

.ENDS CD4096B

*------------------------------------------------------------CD4099B------

* 8-Bit Addressable Latch
* National CMOS Logic Databook, 1988, pages 5-224 to 5-228
* jat 9/7/95

.SUBCKT CD4099B
+ CL D EBAR A0 A1 A2 Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(6,16) VDD VSS
+ A0 A1 A2 EBAR D CL
+ G0 G1 G2 G3 G4 G5 G6 G7 CLR0 CLR1 CLR2 CLR3 CLR4 CLR5 CLR6 CLR7
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   G0 = {(~A0) & (~A1) & (~A2) & (~EBAR)}
+   G1 = {  A0  & (~A1) & (~A2) & (~EBAR)}
+   G2 = {(~A0) &   A1  & (~A2) & (~EBAR)}
+   G3 = {  A0  &   A1  & (~A2) & (~EBAR)}
+   G4 = {(~A0) & (~A1) &   A2  & (~EBAR)}
+   G5 = {  A0  & (~A1) &   A2  & (~EBAR)}
+   G6 = {(~A0) &   A1  &   A2  & (~EBAR)}
+   G7 = {  A0  &   A1  &   A2  & (~EBAR)}
+   CLR0 = {~((EBAR & CL) | ((~EBAR) & CL & (~G0)))}
+   CLR1 = {~((EBAR & CL) | ((~EBAR) & CL & (~G1)))}
+   CLR2 = {~((EBAR & CL) | ((~EBAR) & CL & (~G2)))}
+   CLR3 = {~((EBAR & CL) | ((~EBAR) & CL & (~G3)))}
+   CLR4 = {~((EBAR & CL) | ((~EBAR) & CL & (~G4)))}
+   CLR5 = {~((EBAR & CL) | ((~EBAR) & CL & (~G5)))}
+   CLR6 = {~((EBAR & CL) | ((~EBAR) & CL & (~G6)))}
+   CLR7 = {~((EBAR & CL) | ((~EBAR) & CL & (~G7)))}

U2 DLTCH(1) VDD VSS
+ $D_HI CLR0 G0
+ D Q0O $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DLTCH(1) VDD VSS
+ $D_HI CLR1 G1
+ D Q1O $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 DLTCH(1) VDD VSS
+ $D_HI CLR2 G2
+ D Q2O $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 DLTCH(1) VDD VSS
+ $D_HI CLR3 G3
+ D Q3O $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 DLTCH(1) VDD VSS
+ $D_HI CLR4 G4
+ D Q4O $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 DLTCH(1) VDD VSS
+ $D_HI CLR5 G5
+ D Q5O $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 DLTCH(1) VDD VSS
+ $D_HI CLR6 G6
+ D Q6O $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 DLTCH(1) VDD VSS
+ $D_HI CLR7 G7
+ D Q7O $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 PINDLY(8,0,13) VDD VSS
+ Q0O Q1O Q2O Q3O Q4O Q5O Q6O Q7O
+ EBAR D CLR0 CLR1 CLR2 CLR3 CLR4 CLR5 CLR6 CLR7 A0 A1 A2
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+     ADD = {CHANGED(A0,0) | CHANGED(A1,0) | CHANGED(A2,0)}
+     ENABLE = {CHANGED_HL(EBAR,0)}
+     DATAIN = {CHANGED(D,0)}
+     CLEAR0 = {CHANGED_HL(CLR0,0)}
+     CLEAR1 = {CHANGED_HL(CLR1,0)}
+     CLEAR2 = {CHANGED_HL(CLR2,0)}
+     CLEAR3 = {CHANGED_HL(CLR3,0)}
+     CLEAR4 = {CHANGED_HL(CLR4,0)}
+     CLEAR5 = {CHANGED_HL(CLR5,0)}
+     CLEAR6 = {CHANGED_HL(CLR6,0)}
+     CLEAR7 = {CHANGED_HL(CLR7,0)}
+ PINDLY:
+     Q0 = {
+       CASE(
+         CLEAR0 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAIN) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q1 = {
+       CASE(
+         CLEAR1 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAIN) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q2 = {
+       CASE(
+         CLEAR2 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAIN) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q3 = {
+       CASE(
+         CLEAR3 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAIN) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q4 = {
+       CASE(
+         CLEAR4 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAIN) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q5 = {
+       CASE(
+         CLEAR5 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAIN) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q6 = {
+       CASE(
+         CLEAR6 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAIN) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q7 = {
+       CASE(
+         CLEAR7 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAIN) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}

U11 CONSTRAINT(6) VDD VSS
+ A0 A1 A2 CL EBAR D
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ WIDTH:
+   NODE = D
+   MIN_LO = 100NS
+   MIN_HI = 100NS
+ WIDTH:
+   NODE = A0
+   MIN_LO = 200NS
+   MIN_HI = 200NS
+ WIDTH:
+   NODE = A1
+   MIN_LO = 200NS
+   MIN_HI = 200NS
+ WIDTH:
+   NODE = A2
+   MIN_LO = 200NS
+   MIN_HI = 200NS
+ WIDTH:
+   NODE = CL
+   MIN_HI = 75NS
+ SETUP_HOLD:
+  CLOCK HL = EBAR
+  DATA(1) = D
+  SETUPTIME = 40NS
+  HOLDTIME = 60NS

.ENDS CD4099B

*--------------------------------------------------------CD40106B--------

* Hex Schmitt Trigger
* National CMOS Logic Databook, 1988, pages 5-229 to 5-232
* jat 9/7/95

.SUBCKT CD40106B
+ A ABAR
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 INV VDD VSS
+ A ABAR
+ DLY IO_4000B_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY UGATE (TPLHMN=-1 TPLHTY=220NS TPLHMX=400NS
+                 TPHLMN=-1 TPHLTY=220NS TPHLMX=400NS)

.ENDS CD40106B

*------------------------------------------------------------CD40107B-----

* CMOS Dual 2 Input NAND Buffer/Driver
* Harris AnswerFax document # 1015
* jat 12/19/95

.SUBCKT CD40107B
+ A B C
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) VDD VSS
+ A B
+ C
+ DLY IO_4000B_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   C = {~(A & B)}

.MODEL DLY UGATE(TPLHMN=-1 TPLHTY=100NS TPLHMX=200NS
+                TPHLMN=-1 TPHLTY=100NS TPHLMX=200NS)

.ENDS CD40107B

*------------------------------------------------------------CD40147B----

* 10 Line to 4 Line BCD Priority Encoder
* Harris AnswerFax document # 1117
* Note that the logic diagram shown has extensive errors in it.
* jat 12/19/95

.SUBCKT CD40147B
+ D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 A B C D
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(10,4) VDD VSS
+ D0 D1 D2 D3 D4 D5 D6 D7 D8 D9
+ A B C D
+ DLY IO_4000B_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   D0BAR = {~D0}
+   D1BAR = {~D1}
+   D2BAR = {~D2}
+   D3BAR = {~D3}
+   D4BAR = {~D4}
+   D5BAR = {~D5}
+   D6BAR = {~D6}
+   D7BAR = {~D7}
+   D8BAR = {~D8}
+   D9BAR = {~D9}
+   ANDALL = {D0BAR & D1BAR & D2BAR & D3BAR & D4BAR & D5BAR & D6BAR & 
+            D7BAR & D8BAR & D9BAR}
+   D = {D9 | (D8 & D9BAR) | ANDALL}
+   C = {((D9BAR & D8BAR) & (D7 | (D7BAR & D6) | (D7BAR & D6BAR & D5))) | ANDALL}
+   B = {((D9BAR & D8BAR) & (D7 | (D7BAR & D6) | (D7BAR & D6BAR & D5BAR &
+          D4BAR & D3) | (D7BAR & D6BAR & D5BAR & D4BAR & D3BAR & D2))) | ANDALL}
+   A = {((D9BAR & D8BAR) & (D7 | (D7BAR & D6BAR & D5) | (D7BAR & D6BAR & D5BAR &
+          D4BAR & D3) | (D7BAR & D6BAR & D5BAR & D4BAR & D3BAR & D2BAR & D1))) | ANDALL | D9}

.MODEL DLY UGATE(TPLHMN=-1 TPLHTY=450NS TPLHMX=900NS
+                TPHLMN=-1 TPHLTY=450NS TPHLMX=900NS)

.ENDS CD40147B

*------------------------------------------------------------CD40160B-----

* Decade Counter with Asynchronous Clear
* National CMOS Logic Databook, 1988, pages 5-233 to 5-237
* jat 9/7/95

.SUBCKT CD40160B
+ CLRBAR CLK ENP ENT LOADBAR RIPCAR INA INB INC IND QA QB QC QD
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(13,5) VDD VSS
+ ENP ENT QABARO QBBARO QCBARO QDBARO INA INB INC IND LOADBAR QAO QDO
+ DA DB DC DD RIPCARO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    ENAB = {~(ENP & ENT)}
+    NORB = {~(QABARO | ENAB | QDO)}
+    NORC = {~(QABARO | QBBARO | ENAB)}
+    ORD1 = {QABARO | QBBARO | QCBARO | ENAB}
+    ORD2 = {QABARO | ENAB | QDBARO}
+    NANDD = {~(ORD1 & ORD2)}
+    XNORA = {~((~ENAB) ^ QABARO)}
+    XNORB = {~(NORB ^ QBBARO)}
+    XNORC = {~(NORC ^ QCBARO)}
+    XNORD = {~(NANDD ^ QDBARO)}
+    DA = {(INA & (~LOADBAR)) | (LOADBAR & XNORA)}
+    DB = {(INB & (~LOADBAR)) | (LOADBAR & XNORB)}
+    DC = {(INC & (~LOADBAR)) | (LOADBAR & XNORC)}
+    DD = {(IND & (~LOADBAR)) | (LOADBAR & XNORD)}
+    RIPCARO = {QAO & QDO & ENT}

U2 DFF(4) VDD VSS
+ $D_HI CLRBAR CLK
+ DA DB DC DD
+ QAO QBO QCO QDO
+ QABARO QBBARO QCBARO QDBARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,3) VDD VSS
+ QAO QBO QCO QDO RIPCARO
+ CLRBAR CLK ENT
+ QA QB QC QD RIPCAR
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          CLEAR = {CHANGED_HL(CLRBAR,0)}
+          EDGE = {CHANGED_LH(CLK,0)}
+          TENAB = {CHANGED_HL(ENT,0)}
+ PINDLY:
+    QA QB QC QD = {
+       CASE(
+          CLEAR & TRN_HL, DELAY(-1,190NS,300NS),
+          EDGE, DELAY(-1,250NS,400NS),
+          DELAY(-1,251NS,401NS))}
+    RIPCAR = {
+       CASE(
+          TENAB & (TRN_LH | TRN_HL), DELAY(-1,180NS,290NS),
+          EDGE & (TRN_LH | TRN_HL), DELAY(-1,290NS,450NS),
+          DELAY(-1,291NS,451NS))}

U4 CONSTRAINT(8) VDD VSS
+ CLK LOADBAR INA INB INC IND ENT ENP
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+    CLOCK LH = CLK
+    DATA(5) = LOADBAR INA INB INC IND
+    SETUPTIME = 120NS
+ SETUP_HOLD:
+    CLOCK LH = CLK
+    DATA(2) = ENT ENP
+    SETUPTIME = 170NS
+ WIDTH:
+    NODE = CLK
+    MIN_LO = 125NS
+    MIN_HI = 125NS
+ FREQ:
+    NODE = CLK
+    MAXFREQ = 4MEG

.ENDS CD40160B

*------------------------------------------------------------CD40161B-----

* Binary Counter with Asynchronous Clear
* National CMOS Logic Databook, 1988, pages 5-233 to 5-237
* jat 9/7/95

.SUBCKT CD40161B
+ CLRBAR CLK ENP ENT LOADBAR RIPCAR INA INB INC IND QA QB QC QD
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(15,5) VDD VSS
+ ENP ENT QABARO QBBARO QCBARO QDBARO INA INB INC IND LOADBAR QAO QBO QCO QDO
+ DA DB DC DD RIPCARO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    ENAB = {~(ENP & ENT)}
+    NORB = {~(QABARO | ENAB)}
+    NORC = {~(QABARO | QBBARO | ENAB)}
+    NORD = {~(QABARO | QBBARO | QCBARO | ENAB)}
+    XNORA = {~((~ENAB) ^ QABARO)}
+    XNORB = {~(NORB ^ QBBARO)}
+    XNORC = {~(NORC ^ QCBARO)}
+    XNORD = {~(NORD ^ QDBARO)}
+    DA = {(INA & (~LOADBAR)) | (LOADBAR & XNORA)}
+    DB = {(INB & (~LOADBAR)) | (LOADBAR & XNORB)}
+    DC = {(INC & (~LOADBAR)) | (LOADBAR & XNORC)}
+    DD = {(IND & (~LOADBAR)) | (LOADBAR & XNORD)}
+    RIPCARO = {QAO & QBO & QCO & QDO & ENT}

U2 DFF(4) VDD VSS
+ $D_HI CLRBAR CLK
+ DA DB DC DD
+ QAO QBO QCO QDO
+ QABARO QBBARO QCBARO QDBARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,3) VDD VSS
+ QAO QBO QCO QDO RIPCARO
+ CLRBAR CLK ENT
+ QA QB QC QD RIPCAR
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          CLEAR = {CHANGED_HL(CLRBAR,0)}
+          EDGE = {CHANGED_LH(CLK,0)}
+          TENAB = {CHANGED_HL(ENT,0)}
+ PINDLY:
+    QA QB QC QD = {
+       CASE(
+          CLEAR & TRN_HL, DELAY(-1,190NS,300NS),
+          EDGE, DELAY(-1,250NS,400NS),
+          DELAY(-1,251NS,401NS))}
+    RIPCAR = {
+       CASE(
+          TENAB & (TRN_LH | TRN_HL), DELAY(-1,180NS,290NS),
+          EDGE & (TRN_LH | TRN_HL), DELAY(-1,290NS,450NS),
+          DELAY(-1,291NS,451NS))}

U4 CONSTRAINT(8) VDD VSS
+ CLK LOADBAR INA INB INC IND ENT ENP
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+    CLOCK LH = CLK
+    DATA(5) = LOADBAR INA INB INC IND
+    SETUPTIME = 120NS
+ SETUP_HOLD:
+    CLOCK LH = CLK
+    DATA(2) = ENT ENP
+    SETUPTIME = 170NS
+ WIDTH:
+    NODE = CLK
+    MIN_LO = 125NS
+    MIN_HI = 125NS
+ FREQ:
+    NODE = CLK
+    MAXFREQ = 4MEG

.ENDS CD40161B

*------------------------------------------------------------CD40162B-----

* Decade Counter with Synchronous Clear
* National CMOS Logic Databook, 1988, pages 5-233 to 5-237
* jat 9/7/95

.SUBCKT CD40162B
+ CLRBAR CLK ENP ENT LOADBAR RIPCAR INA INB INC IND QA QB QC QD
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(14,5) VDD VSS
+ ENP ENT QABARO QBBARO QCBARO QDBARO INA INB INC IND LOADBAR QAO QDO CLRBAR
+ DA DB DC DD RIPCARO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    ENAB = {~(ENP & ENT)}
+    NORB = {~(QABARO | ENAB | QDO)}
+    NORC = {~(QABARO | QBBARO | ENAB)}
+    ORD1 = {QABARO | QBBARO | QCBARO | ENAB}
+    ORD2 = {QABARO | ENAB | QDBARO}
+    NANDD = {~(ORD1 & ORD2)}
+    XNORA = {~((~ENAB) ^ QABARO)}
+    XNORB = {~(NORB ^ QBBARO)}
+    XNORC = {~(NORC ^ QCBARO)}
+    XNORD = {~(NANDD ^ QDBARO)}
+    DA = {(INA & (~LOADBAR) & CLRBAR) | (LOADBAR & XNORA & CLRBAR)}
+    DB = {(INB & (~LOADBAR) & CLRBAR) | (LOADBAR & XNORB & CLRBAR)}
+    DC = {(INC & (~LOADBAR) & CLRBAR) | (LOADBAR & XNORC & CLRBAR)}
+    DD = {(IND & (~LOADBAR) & CLRBAR) | (LOADBAR & XNORD & CLRBAR)}
+    RIPCARO = {QAO & QDO & ENT}

U2 DFF(4) VDD VSS
+ $D_HI $D_HI CLK
+ DA DB DC DD
+ QAO QBO QCO QDO
+ QABARO QBBARO QCBARO QDBARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,2) VDD VSS
+ QAO QBO QCO QDO RIPCARO
+ CLK ENT
+ QA QB QC QD RIPCAR
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          EDGE = {CHANGED_LH(CLK,0)}
+          TENAB = {CHANGED_HL(ENT,0)}
+ PINDLY:
+    QA QB QC QD = {
+       CASE(
+          EDGE, DELAY(-1,250NS,400NS),
+          DELAY(-1,251NS,401NS))}
+    RIPCAR = {
+       CASE(
+          TENAB & (TRN_LH | TRN_HL), DELAY(-1,180NS,290NS),
+          EDGE & (TRN_LH | TRN_HL), DELAY(-1,290NS,450NS),
+          DELAY(-1,291NS,451NS))}

U4 CONSTRAINT(9) VDD VSS
+ CLK LOADBAR INA INB INC IND ENT ENP CLRBAR
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+    CLOCK LH = CLK
+    DATA(5) = LOADBAR INA INB INC IND
+    SETUPTIME = 120NS
+ SETUP_HOLD:
+    CLOCK LH = CLK
+    DATA(2) = ENT ENP
+    SETUPTIME = 170NS
+ WIDTH:
+    NODE = CLK
+    MIN_LO = 125NS
+    MIN_HI = 125NS
+ FREQ:
+    NODE = CLK
+    MAXFREQ = 4MEG
+ SETUP_HOLD:
+    CLOCK LH = CLK
+    DATA(1) = CLRBAR
+    SETUPTIME_LO = 120NS

.ENDS CD40162B

*------------------------------------------------------------CD40163B-----

* Binary Counter with Synchronous Clear
* National CMOS Logic Databook, 1988, pages 5-233 to 5-237
* jat 9/7/95

.SUBCKT CD40163B
+ CLRBAR CLK ENP ENT LOADBAR RIPCAR INA INB INC IND QA QB QC QD
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,5) VDD VSS
+ ENP ENT QABARO QBBARO QCBARO QDBARO INA INB INC IND LOADBAR QAO QBO QCO QDO
+ CLRBAR
+ DA DB DC DD RIPCARO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    ENAB = {~(ENP & ENT)}
+    NORB = {~(QABARO | ENAB)}
+    NORC = {~(QABARO | QBBARO | ENAB)}
+    NORD = {~(QABARO | QBBARO | QCBARO | ENAB)}
+    XNORA = {~((~ENAB) ^ QABARO)}
+    XNORB = {~(NORB ^ QBBARO)}
+    XNORC = {~(NORC ^ QCBARO)}
+    XNORD = {~(NORD ^ QDBARO)}
+    DA = {(INA & (~LOADBAR) & CLRBAR) | (LOADBAR & XNORA & CLRBAR)}
+    DB = {(INB & (~LOADBAR) & CLRBAR) | (LOADBAR & XNORB & CLRBAR)}
+    DC = {(INC & (~LOADBAR) & CLRBAR) | (LOADBAR & XNORC & CLRBAR)}
+    DD = {(IND & (~LOADBAR) & CLRBAR) | (LOADBAR & XNORD & CLRBAR)}
+    RIPCARO = {QAO & QBO & QCO & QDO & ENT}

U2 DFF(4) VDD VSS
+ $D_HI $D_HI CLK
+ DA DB DC DD
+ QAO QBO QCO QDO
+ QABARO QBBARO QCBARO QDBARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,2) VDD VSS
+ QAO QBO QCO QDO RIPCARO
+ CLK ENT
+ QA QB QC QD RIPCAR
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          EDGE = {CHANGED_LH(CLK,0)}
+          TENAB = {CHANGED_HL(ENT,0)}
+ PINDLY:
+    QA QB QC QD = {
+       CASE(
+          EDGE, DELAY(-1,250NS,400NS),
+          DELAY(-1,251NS,401NS))}
+    RIPCAR = {
+       CASE(
+          TENAB & (TRN_LH | TRN_HL), DELAY(-1,180NS,290NS),
+          EDGE & (TRN_LH | TRN_HL), DELAY(-1,290NS,450NS),
+          DELAY(-1,291NS,451NS))}

U4 CONSTRAINT(9) VDD VSS
+ CLK LOADBAR INA INB INC IND ENT ENP CLRBAR
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+    CLOCK LH = CLK
+    DATA(5) = LOADBAR INA INB INC IND
+    SETUPTIME = 120NS
+ SETUP_HOLD:
+    CLOCK LH = CLK
+    DATA(2) = ENT ENP
+    SETUPTIME = 170NS
+ WIDTH:
+    NODE = CLK
+    MIN_LO = 125NS
+    MIN_HI = 125NS
+ FREQ:
+    NODE = CLK
+    MAXFREQ = 4MEG
+ SETUP_HOLD:
+    CLOCK LH = CLK
+    DATA(1) = CLRBAR
+    SETUPTIME_LO = 120NS

.ENDS CD40163B

*-----------------------------------------------------------CD40174B----

* Hex D Flip Flop
* National CMOS Logic Databook, 1988, pages 5-238 to 5-241
* jat 9/7/95

.SUBCKT CD40174B
+ CLK CLR D1 D2 D3 D4 D5 D6 Q1 Q2 Q3 Q4 Q5 Q6
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 DFF(6) VDD VSS
+ $D_HI CLR CLK
+ D1 D2 D3 D4 D5 D6 Q1O Q2O Q3O Q4O Q5O Q6O
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(6,0,2) VDD VSS
+ Q1O Q2O Q3O Q4O Q5O Q6O
+ CLR CLK
+ Q1 Q2 Q3 Q4 Q5 Q6
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+           CLEAR = {CHANGED_HL(CLR,0)}
+           EDGE = {CHANGED_LH(CLK,0)}
+ PINDLY:
+         Q1 Q2 Q3 Q4 Q5 Q6 = {
+           CASE(
+             CLEAR & TRN_HL, DELAY(-1,180NS,300NS),
+             EDGE & (TRN_LH | TRN_HL), DELAY(-1,190NS,300NS),
+             DELAY(-1,191NS,301NS))}

U3 CONSTRAINT(8) VDD VSS
+ CLK CLR D1 D2 D3 D4 D5 D6
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+     CLOCK LH = CLK
+     DATA(6) = D1 D2 D3 D4 D5 D6
+     SETUPTIME = 45NS
+ WIDTH:
+     NODE = CLK
+     MIN_HI = 130NS
+     MIN_LO = 130NS
+ WIDTH:
+     NODE = CLR
+     MIN_LO = 120NS
+ FREQ:
+     NODE = CLK
+     MAXFREQ = 3.5MEG

.ENDS CD40174B

*-------------------------------------------------------------CD40175B----

* Quad D Flip Flop
* National CMOS Logic Databook, 1988, pages 5-238 to 5-241
* jat 9/8/95 (happy birthday gretel)

.SUBCKT CD40175B
+ CLK CLR D1 D2 D3 D4 Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 DFF(4) VDD VSS
+ $D_HI CLR CLK
+ D1 D2 D3 D4 Q1O Q2O Q3O Q4O
+ Q1BARO Q2BARO Q3BARO Q4BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(8,0,2) VDD VSS
+ Q1O Q2O Q3O Q4O Q1BARO Q2BARO Q3BARO Q4BARO
+ CLR CLK
+ Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+           CLEAR = {CHANGED_HL(CLR,0)}
+           EDGE = {CHANGED_LH(CLK,0)}
+ PINDLY:
+         Q1 Q2 Q3 Q4 = {
+           CASE(
+             CLEAR & TRN_HL, DELAY(-1,180NS,300NS),
+             EDGE & (TRN_LH | TRN_HL), DELAY(-1,190NS,300NS),
+             DELAY(-1,191NS,301NS))}
+         Q1BAR Q2BAR Q3BAR Q4BAR = {
+           CASE(
+             CLEAR & TRN_LH, DELAY(-1,230NS,400NS),
+             EDGE & (TRN_LH | TRN_HL), DELAY(-1,190NS,300NS),
+             DELAY(-1,231NS,401NS))}

U3 CONSTRAINT(6) VDD VSS
+ CLK CLR D1 D2 D3 D4
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+     CLOCK LH = CLK
+     DATA(4) = D1 D2 D3 D4
+     SETUPTIME = 45NS
+ WIDTH:
+     NODE = CLK
+     MIN_HI = 130NS
+     MIN_LO = 130NS
+ WIDTH:
+     NODE = CLR
+     MIN_LO = 120NS
+ FREQ:
+     NODE = CLK
+     MAXFREQ = 3.5MEG

.ENDS CD40175B

*-----------------------------------------------------------CD40192B------

* Synchronous 4 Bit Up Down Decade Counter
* National CMOS Logic Databook, 1988, pages 5-242 to 5-246
* jat 9/8/95

.SUBCKT CD40192B
+ A B C D QA QB QC QD UP DOWN CLEAR CARRY LOADBAR BORROW
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,14) VDD VSS
+ UP DOWN QAO QABARO QBO QBBARO QCO QCBARO QDO QDBARO CLEAR LOADBAR A B C D  
+ CLKA CLKB CLKC CLKD SETA RESETA SETB RESETB SETC RESETC SETD RESETD
+ CARRYO BORROWO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    CLKA = {~(UP & DOWN)}
+    INB1 = {(~(QAO & QDBARO)) | UP}
+    INB2 = {(~((QDO | QCO | QBO) & QABARO)) | DOWN}
+    CLKB = {~(INB1 & INB2)}
+    INC1 = {(~(QAO & QBO)) | UP}
+    INC2 = {(~(QABARO & QBBARO & (QCO | QDO))) | DOWN}
+    CLKC = {~(INC1 & INC2)}
+    IND1 = {~(((QBO & QCO) | QDO) & QAO)}
+    IND2 = {~(QABARO & QBBARO & QCBARO)}
+    CLKD = {~((IND1 | UP) & (IND2 | DOWN))}
+    SETA = {~((~CLEAR) & (~LOADBAR) & A)}
+    RESETA = {((~CLEAR) & LOADBAR) | ((~CLEAR) & (~LOADBAR) & A)}
+    SETB = {~((~CLEAR) & (~LOADBAR) & B)}
+    RESETB = {((~CLEAR) & LOADBAR) | ((~CLEAR) & (~LOADBAR) & B)}
+    SETC = {~((~CLEAR) & (~LOADBAR) & C)}
+    RESETC = {((~CLEAR) & LOADBAR) | ((~CLEAR) & (~LOADBAR) & C)}
+    SETD = {~((~CLEAR) & (~LOADBAR) & D)}
+    RESETD = {((~CLEAR) & LOADBAR) | ((~CLEAR) & (~LOADBAR) & D)}
+    CARRYO = {IND1 | QDBARO | UP}
+    BORROWO = {IND2 | DOWN | QDO}

U2 JKFF(1) VDD VSS
+ SETA RESETA CLKA $D_HI $D_HI QAO QABARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) VDD VSS
+ SETB RESETB CLKB $D_HI $D_HI QBO QBBARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) VDD VSS
+ SETC RESETC CLKC $D_HI $D_HI QCO QCBARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) VDD VSS
+ SETD RESETD CLKD $D_HI $D_HI QDO QDBARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 PINDLY(6,0,4) VDD VSS
+ QAO QBO QCO QDO CARRYO BORROWO
+ UP DOWN CLEAR LOADBAR
+ QA QB QC QD CARRY BORROW
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          UPDOWN = {CHANGED_LH(UP,0) | CHANGED_LH(DOWN,0)}
+          CUP = {CHANGED_HL(UP,0)}
+          CDOWN = {CHANGED_HL(DOWN,0)}
+          CLR = {CHANGED_LH(CLEAR,0)}
+          LOAD = {CHANGED_HL(LOADBAR,0)}
+ PINDLY:
+         QA QB QC QD = {
+           CASE(
+              CLR & TRN_HL, DELAY(-1,130NS,220NS),
+              LOAD & (TRN_LH | TRN_HL), DELAY(-1,300NS,480NS),
+              UPDOWN & (TRN_LH | TRN_HL), DELAY(-1,250NS,400NS),
+              DELAY(-1,301NS,481NS))}
+         CARRY = {
+           CASE(
+              CUP & (TRN_LH | TRN_HL), DELAY(-1,120NS,200NS),
+              DELAY(-1,121NS,201NS))}
+         BORROW = {
+            CASE(
+              CDOWN & (TRN_LH | TRN_HL), DELAY(-1,120NS,200NS),
+              DELAY(-1,121NS,201NS))}

U7 CONSTRAINT(8) VDD VSS
+ LOADBAR A B C D UP DOWN CLEAR
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+       CLOCK HL = LOADBAR
+       DATA(4) = A B C D
+       SETUPTIME = 100NS
+ FREQ:
+       NODE = UP
+       MAXFREQ = 4MEG
+ FREQ:
+       NODE = DOWN
+       MAXFREQ = 4MEG
+ WIDTH:
+       NODE = UP
+       MIN_LO = 120NS
+       MIN_HI = 120NS
+ WIDTH:
+       NODE = DOWN
+       MIN_LO = 120NS
+       MIN_HI = 120NS
+ WIDTH:
+       NODE = CLEAR
+       MIN_HI = 300NS
+ WIDTH:
+       NODE = LOADBAR
+       MIN_LO = 100NS

.ENDS CD40192B

*-----------------------------------------------------------CD40193B------

* Synchronous 4 Bit Up Down Binary Counter
* National CMOS Logic Databook, 1988, pages 5-242 to 5-246
* jat 9/8/95

.SUBCKT CD40193B
+ A B C D QA QB QC QD UP DOWN CLEAR CARRY LOADBAR BORROW
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,14) VDD VSS
+ UP DOWN QAO QABARO QBO QBBARO QCO QCBARO QDO QDBARO CLEAR LOADBAR A B C D  
+ CLKA CLKB CLKC CLKD SETA RESETA SETB RESETB SETC RESETC SETD RESETD
+ CARRYO BORROWO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    CLKA = {~(UP & DOWN)}
+    ORB1 = {QAO | DOWN}
+    ORB2 = {QABARO | UP}
+    CLKB = {~(ORB1 & ORB2)}
+    INC1 = {(~(QAO & QBO)) | UP}
+    INC2 = {(~(QABARO & QBBARO)) | DOWN}
+    CLKC = {~(INC1 & INC2)}
+    IND1 = {~(QAO & QBO & QCO)}
+    IND2 = {~(QABARO & QBBARO & QCBARO)}
+    CLKD = {~((IND1 | UP) & (IND2 | DOWN))}
+    SETA = {~((~CLEAR) & (~LOADBAR) & A)}
+    RESETA = {((~CLEAR) & LOADBAR) | ((~CLEAR) & (~LOADBAR) & A)}
+    SETB = {~((~CLEAR) & (~LOADBAR) & B)}
+    RESETB = {((~CLEAR) & LOADBAR) | ((~CLEAR) & (~LOADBAR) & B)}
+    SETC = {~((~CLEAR) & (~LOADBAR) & C)}
+    RESETC = {((~CLEAR) & LOADBAR) | ((~CLEAR) & (~LOADBAR) & C)}
+    SETD = {~((~CLEAR) & (~LOADBAR) & D)}
+    RESETD = {((~CLEAR) & LOADBAR) | ((~CLEAR) & (~LOADBAR) & D)}
+    CARRYO = {IND1 | QDBARO | UP}
+    BORROWO = {IND2 | DOWN | QDO}

U2 JKFF(1) VDD VSS
+ SETA RESETA CLKA $D_HI $D_HI QAO QABARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) VDD VSS
+ SETB RESETB CLKB $D_HI $D_HI QBO QBBARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) VDD VSS
+ SETC RESETC CLKC $D_HI $D_HI QCO QCBARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) VDD VSS
+ SETD RESETD CLKD $D_HI $D_HI QDO QDBARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 PINDLY(6,0,4) VDD VSS
+ QAO QBO QCO QDO CARRYO BORROWO
+ UP DOWN CLEAR LOADBAR
+ QA QB QC QD CARRY BORROW
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          UPDOWN = {CHANGED_LH(UP,0) | CHANGED_LH(DOWN,0)}
+          CUP = {CHANGED_HL(UP,0)}
+          CDOWN = {CHANGED_HL(DOWN,0)}
+          CLR = {CHANGED_LH(CLEAR,0)}
+          LOAD = {CHANGED_HL(LOADBAR,0)}
+ PINDLY:
+         QA QB QC QD = {
+           CASE(
+              CLR & TRN_HL, DELAY(-1,130NS,220NS),
+              LOAD & (TRN_LH | TRN_HL), DELAY(-1,300NS,480NS),
+              UPDOWN & (TRN_LH | TRN_HL), DELAY(-1,250NS,400NS),
+              DELAY(-1,301NS,481NS))}
+         CARRY = {
+           CASE(
+              CUP & (TRN_LH | TRN_HL), DELAY(-1,120NS,200NS),
+              DELAY(-1,121NS,201NS))}
+         BORROW = {
+            CASE(
+              CDOWN & (TRN_LH | TRN_HL), DELAY(-1,120NS,200NS),
+              DELAY(-1,121NS,201NS))}

U7 CONSTRAINT(8) VDD VSS
+ LOADBAR A B C D UP DOWN CLEAR
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+       CLOCK HL = LOADBAR
+       DATA(4) = A B C D
+       SETUPTIME = 100NS
+ FREQ:
+       NODE = UP
+       MAXFREQ = 4MEG
+ FREQ:
+       NODE = DOWN
+       MAXFREQ = 4MEG
+ WIDTH:
+       NODE = UP
+       MIN_LO = 120NS
+       MIN_HI = 120NS
+ WIDTH:
+       NODE = DOWN
+       MIN_LO = 120NS
+       MIN_HI = 120NS
+ WIDTH:
+       NODE = CLEAR
+       MIN_HI = 300NS
+ WIDTH:
+       NODE = LOADBAR
+       MIN_LO = 100NS

.ENDS CD40193B

*-----------------------------------------------------------CD40194B-----

* 4 Bit Bidirectional Universal Shift Register
* Motorola CMOS Logic Databook, 1991, pages 6-201 to 6-204
* jat 9/8/95

.SUBCKT CD40194B
+ DP0 DP1 DP2 DP3 RBAR S0 S1 DSL DSR CLK Q0 Q1 Q2 Q3
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(12,4) VDD VSS
+ S0 S1 DSR DSL DP0 DP1 DP2 DP3 Q0O Q1O Q2O Q3O
+ D0 D1 D2 D3
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  AND01 = {DSR & (~S1) & S0}
+  AND02 = {S0 & S1 & DP0}
+  AND03 = {(~S0) & S1 & Q1O}
+  AND04 = {(~S0) & (~S1) & Q0O}
+  AND11 = {Q0O & (~S1) & S0}
+  AND12 = {S0 & S1 & DP1}
+  AND13 = {(~S0) & S1 & Q2O}
+  AND14 = {(~S0) & (~S1) & Q1O}
+  AND21 = {Q1O & (~S1) & S0}
+  AND22 = {S0 & S1 & DP2}
+  AND23 = {(~S0) & S1 & Q3O}
+  AND24 = {(~S0) & (~S1) & Q2O}
+  AND31 = {Q2O & (~S1) & S0}
+  AND32 = {S0 & S1 & DP3}
+  AND33 = {(~S0) & S1 & DSL}
+  AND34 = {(~S0) & (~S1) & Q3O}
+  D0 = {AND01 | AND02 | AND03 | AND04}
+  D1 = {AND11 | AND12 | AND13 | AND14}
+  D2 = {AND21 | AND22 | AND23 | AND24}
+  D3 = {AND31 | AND32 | AND33 | AND34}

U2 DFF(4) VDD VSS
+ $D_HI RBAR CLK
+ D0 D1 D2 D3 Q0O Q1O Q2O Q3O $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(4,0,2) VDD VSS
+ Q0O Q1O Q2O Q3O
+ RBAR CLK
+ Q0 Q1 Q2 Q3
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    RESET = {CHANGED_HL(RBAR,0)}
+    EDGE = {CHANGED_LH(CLK,0)}
+ PINDLY:
+       Q0 Q1 Q2 Q3 = {
+         CASE(
+            RESET & TRN_HL, DELAY(-1,350NS,700NS),
+            EDGE & (TRN_LH | TRN_HL), DELAY(-1,275NS,550NS),
+            DELAY(-1,351NS,701NS))}

U4 CONSTRAINT(10) VDD VSS
+ CLK RBAR S1 S0 DP0 DP1 DP2 DP3 DSL DSR 
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ WIDTH:
+        NODE = CLK
+        MIN_LO = 140NS
+        MIN_HI = 140NS
+ WIDTH:
+        NODE = RBAR
+        MIN_LO = 90NS
+ FREQ:
+        NODE = CLK
+        MAXFREQ = 3.6MEG
+        WHEN = {(S1 == '1 & S0 == '0) | (S1 == '0 & S0 == '1)}
+ SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(6) = DP0 DP1 DP2 DP3 DSL DSR
+        HOLDTIME = 90NS
+ SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) = S0 S1
+        SETUPTIME = 100NS
+ SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = RBAR
+        SETUPTIME_HI = 150NS

.ENDS CD40194B

*----------------------------------------------------------CD40257B------

* CMOS 2 line to 1 line Data Selector/Multiplexer
* Harris AnswerFax document # 982
* jat 12/19/95

.SUBCKT CD40257B
+ A1 A2 A3 A4 B1 B2 B3 B4 D1 D2 D3 D4 SELECT DISABLE
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(9,4) VDD VSS
+ A1 A2 A3 A4 B1 B2 B3 B4 SELECT
+ D1O D2O D3O D4O
+ D0_GATE IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   D4O = {(A4 & (~SELECT)) | (B4 & SELECT)}
+   D3O = {(A3 & (~SELECT)) | (B3 & SELECT)}
+   D2O = {(A2 & (~SELECT)) | (B2 & SELECT)}
+   D1O = {(A1 & (~SELECT)) | (B1 & SELECT)}

U2 PINDLY(4,1,9) VDD VSS
+ D4O D3O D2O D1O
+ DISABLE
+ A1 A2 A3 A4 B1 B2 B3 B4 SELECT
+ D4 D3 D2 D1
+ IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   SEL = {CHANGED(SELECT,0)}
+   DATA = {CHANGED(A4,0) | CHANGED(A3,0) | CHANGED(A2,0) | CHANGED(A1,0) |
+           CHANGED(B4,0) | CHANGED(B3,0) | CHANGED(B2,0) | CHANGED(B1,0)}
+ TRISTATE:
+    ENABLE LO = DISABLE
+    D4 D3 D2 D1 = {
+      CASE(
+        (TRN_Z$ | TRN_$Z), DELAY(-1,95NS,190NS),
+        SEL & (TRN_LH | TRN_HL), DELAY(-1,190NS,380NS),
+        DATA & (TRN_LH | TRN_HL), DELAY(-1,150NS,300NS),
+        DELAY(-1,191NS,381NS))}

.ENDS CD40257B

*----------------------------------------------------------CD4501UB------

* Dual 4 Input NAND Gate, 2 Input NOR/OR Gate, 8 Input AND/NAND Gate
* Motorola CMOS Logic Databook, 1991, pages 6-223 to 6-226
* jat 9/8/95

.SUBCKT CD4501UB
+ INA1 INA2 INA3 INA4 INB1 INB2 INB3 INB4 NORIN1 NORIN2 OUTA OUTB NOROUT OROUT
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(10,4) VDD VSS
+ INA1 INA2 INA3 INA4 INB1 INB2 INB3 INB4 NORIN1 NORIN2
+ OUTAO OUTBO NOROUTO OROUTO
+ D0_GATE IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+        OUTAO = {~(INA1 & INA2 & INA3 & INA4)}
+        OUTBO = {~(INB1 & INB2 & INB3 & INB4)}
+        NOROUTO = {~(NORIN1 | NORIN2)}
+        OROUTO = {~NOROUTO}

U2 PINDLY(4,0,0) VDD VSS
+ OUTAO OUTBO NOROUTO OROUTO
+ OUTA OUTB NOROUT OROUT
+ IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+     OUTA OUTB OROUT = {
+        CASE(
+           TRN_LH | TRN_HL, DELAY(-1,130NS,260NS),
+           DELAY(-1,131NS,261NS))}
+     NOROUT = {
+        CASE(
+           TRN_LH | TRN_HL, DELAY(-1,115NS,230NS),
+           DELAY(-1,116NS,231NS))}

.ENDS CD4501UB

*--------------------------------------------------------------CD4502B----

* Strobed Hex Inverter/Buffer
* Motorola CMOS Logic Databook, 1991, pages 6-227 to 6-230
* jat 9/8/95

.SUBCKT CD4502B
+ D1 D2 D3 D4 D5 D6 DISABLE INHIBIT Q1 Q2 Q3 Q4 Q5 Q6
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 NORA(2,6) VDD VSS
+ D1 INHIBIT D2 INHIBIT D3 INHIBIT D4 INHIBIT D5 INHIBIT D6 INHIBIT
+ Q1O Q2O Q3O Q4O Q5O Q6O
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(6,1,7) VDD VSS
+ Q1O Q2O Q3O Q4O Q5O Q6O
+ DISABLE
+ INHIBIT D1 D2 D3 D4 D5 D6
+ Q1 Q2 Q3 Q4 Q5 Q6
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          INH = {CHANGED(INHIBIT,0)}
+          DATA = {CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) | 
+                  CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0)}
+ TRISTATE:
+         ENABLE LO = DISABLE
+         Q1 Q2 Q3 Q4 Q5 Q6 = {
+            CASE(
+              TRN_HZ, DELAY(-1,65NS,130NS),
+              TRN_ZH, DELAY(-1,260NS,520NS),
+              TRN_LZ, DELAY(-1,150NS,300NS),
+              TRN_ZL, DELAY(-1,160NS,320NS),
+              INH & TRN_HL, DELAY(-1,335NS,670NS),
+              INH & TRN_LH, DELAY(-1,295NS,590NS),
+              DATA & TRN_HL, DELAY(-1,135NS,270NS),
+              DATA & TRN_LH, DELAY(-1,295NS,590NS),
+              DELAY(-1,336NS,671NS))}

.ENDS CD4502B

*------------------------------------------------------------CD4503B-----

* Hex Non Inverting Tri-State Buffer
* National CMOS Logic Databook, 1988, pages 5-247 to 5-252
* jat 9/11/95

.SUBCKT CD4503B
+ IN1 IN2 IN3 IN4 IN5 IN6 OUT1 OUT2 OUT3 OUT4 OUT5 OUT6 DIS2 DIS4
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 BUFA(6) VDD VSS
+ IN1 IN2 IN3 IN4 IN5 IN6 OUT1O OUT2O OUT3O OUT4O OUT5O OUT6O
+ D0_GATE IO_4000B MNTYMXDLY={MNYTMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(6,2,0) VDD VSS
+ OUT1O OUT2O OUT3O OUT4O OUT5O OUT6O
+ DIS2 DIS4
+ OUT1 OUT2 OUT3 OUT4 OUT5 OUT6
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+    ENABLE LO = DIS2
+    OUT5 OUT6 = {
+      CASE(
+         TRN_LZ | TRN_HZ, DELAY(-1,80NS,125NS),
+         TRN_ZL | TRN_ZH, DELAY(-1,95NS,175NS),
+         TRN_LH | TRN_HL, DELAY(-1,75NS,100NS),
+         DELAY(-1,96NS,176NS))}
+ TRISTATE:
+    ENABLE LO = DIS4
+    OUT1 OUT2 OUT3 OUT4 = {
+      CASE(
+         TRN_LZ | TRN_HZ, DELAY(-1,80NS,125NS),
+         TRN_ZL | TRN_ZH, DELAY(-1,95NS,175NS),
+         TRN_LH | TRN_HL, DELAY(-1,75NS,100NS),
+         DELAY(-1,96NS,176NS))}

.ENDS CD4503B

*---------------------------------------------------------------CD4506UB----

* Dual 2-Wide , 2-Input Expandable AND-OR-INVERT Gate
* Motorola CMOS Logic Databook, 1991, pages 6-238 to 6-242
* jat 9/11/95

.SUBCKT CD4506UB
+ AA BA CA DA EA AB BB CB DB EB INH DIS ZA ZB
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(11,2) VDD VSS
+ AA BA CA DA EA AB BB CB DB EB INH
+ ZAO ZBO
+ D0_GATE IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    ZAO = {(~((AA & BA) | (CA & DA))) & EA & (~INH)}
+    ZBO = {(~((AB & BB) | (CB & DB))) & EB & (~INH)}

U2 PINDLY(2,1,11) VDD VSS
+ ZAO ZBO
+ DIS
+ INH AA BA CA DA EA AB BB CB DB EB
+ ZA ZB
+ IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  INHIBIT = {CHANGED(INH,0)}
+  DATA = {CHANGED(AA,0) | CHANGED(BA,0) | CHANGED(CA,0) | CHANGED(DA,0) |
+          CHANGED(EA,0) | CHANGED(AB,0) | CHANGED(BB,0) | CHANGED(CB,0) |
+          CHANGED(DB,0) | CHANGED(EB,0)}
+ TRISTATE:
+    ENABLE LO = DIS
+    ZA ZB  = {
+      CASE(
+        TRN_HZ, DELAY(-1,60NS,150NS),
+        TRN_LZ, DELAY(-1,90NS,225NS),
+        TRN_ZH, DELAY(-1,110NS,300NS),
+        TRN_ZL, DELAY(-1,170NS,425NS),
+        INHIBIT & TRN_LH, DELAY(-1,220NS,500NS),
+        INHIBIT & TRN_HL, DELAY(-1,230NS,400NS),
+        DATA & TRN_LH, DELAY(-1,295NS,580NS),
+        DATA & TRN_HL, DELAY(-1,270NS,480NS),
+        DELAY(-1,296NS,581NS))}

.ENDS CD4506UB

*-------------------------------------------------------------CD4508B----

* Dual 4 Bit Latch
* Motorola CMOS Logic Databook, 1991, pages 6-243 to 6-247
* jat 9/11/95

.SUBCKT CD4508B
+ MR ST DIS D0 D1 D2 D3 Q0 Q1 Q2 Q3 
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(1,1) VDD VSS
+ MR
+ MRBAR
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   MRBAR = {~MR}

U2 DLTCH(4) VDD VSS
+ $D_HI MRBAR ST
+ D0 D1 D2 D3 Q0O Q1O Q2O Q3O $D_NC $D_NC $D_NC $D_NC 
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(4,1,0) VDD VSS
+ Q0O Q1O Q2O Q3O
+ DIS
+ Q0 Q1 Q2 Q3
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+     ENABLE LO = DIS
+     Q0 Q1 Q2 Q3 = {
+       CASE(
+          TRN_HZ, DELAY(-1,55NS,170NS),
+          TRN_LZ, DELAY(-1,75NS,170NS),
+          TRN_ZH, DELAY(-1,80NS,170NS),
+          TRN_ZL, DELAY(-1,105NS,210NS),
+          TRN_LH | TRN_HL, DELAY(-1,220NS,440NS),
+          DELAY(-1,221NS,441NS))}

U4 CONSTRAINT(6) VDD VSS
+ MR ST D0 D1 D2 D3
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ WIDTH:
+        NODE = MR
+        MIN_HI = 100NS
+ WIDTH:
+        NODE = ST
+        MIN_HI = 70NS
+ SETUP_HOLD:
+        CLOCK LH = ST
+        DATA(4) =  D0 D1 D2 D3
+        SETUPTIME = 25NS
+        HOLDTIME = 20NS

.ENDS CD4508B

*------------------------------------------------------------------CD4510B--

* BCD Up/Down Counter
* National CMOS Logic Databook, 1988, pages 5-252 to 5-258
* jat 9/11/95

.SUBCKT CD4510B
+ P1 P2 P3 P4 Q1 Q2 Q3 Q4 CLK U/D RESET PREENAB CIN COUT
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(17,14) VDD VSS
+ RESET PREENAB CLK P1 P2 P3 P4 CIN U/D Q1O Q2O Q3O Q4O Q1BARO Q2BARO
+ Q3BARO Q4BARO 
+ CLOCK PRESET1 RESET1 PRESET2 RESET2 PRESET3 RESET3 PRESET4 RESET4 
+ TE1 TE2 TE3 TE4 COUTO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  CLOCK = {~(RESET | PREENAB | CLK)}
+  PRESET1 = {~((~RESET) & PREENAB & P1)}
+  RESET1 = {((~RESET) & (~PREENAB)) | ((~RESET) & PREENAB & P1)}
+  PRESET2 = {~((~RESET) & PREENAB & P2)}
+  RESET2 = {((~RESET) & (~PREENAB)) | ((~RESET) & PREENAB & P2)}
+  PRESET3 = {~((~RESET) & PREENAB & P3)}
+  RESET3 = {((~RESET) & (~PREENAB)) | ((~RESET) & PREENAB & P3)}
+  PRESET4 = {~((~RESET) & PREENAB & P4)}
+  RESET4 = {((~RESET) & (~PREENAB)) | ((~RESET) & PREENAB & P4)}
+  TE1 = {~CIN}
+  UDBAR = {~U/D}
+  TE2INA = {~(TE1 & Q1O)}
+  TE2INB = {~(TE1 & Q1BARO)}
+  TE2INC = {~(Q4BARO & U/D)}
+  NANDX = {~(Q4BARO & Q3BARO & Q2BARO)}
+  TE2IND = {~(NANDX & UDBAR)}
+  TE2 = {~((TE2INA | TE2INC) & (TE2INB | TE2IND))}
+  TE3INA = {~(Q2O & U/D)}
+  TE3INB = {~(Q2BARO & UDBAR & NANDX)}
+  TE3INC = {TE2INA}
+  TE3IND = {TE2INB}
+  TE3 = {~((TE3INA | TE3INC) & (TE3INB | TE3IND))}
+  TE4INA = {~(Q3BARO & Q2BARO & UDBAR)}
+  ANDX = {Q2O & Q3O}
+  ORX = {ANDX | Q4O}
+  TE4INB = {~(U/D & ORX)}
+  TE4INC = {TE2INB}
+  TE4IND = {TE2INA}
+  TE4 = {~((TE4INA | TE4INC) & (TE4INB | TE4IND))}
+  NANDCOUT1 = {~(Q2BARO & Q3BARO & Q4BARO & UDBAR)}
+  NANDCOUT2 = {~(Q4O & U/D)}
+  COUTO = {(NANDCOUT1 | TE4INC) & (NANDCOUT2 | TE4IND)}

U2 JKFF(1) VDD VSS
+ PRESET1 RESET1 CLOCK
+ TE1 TE1 Q1O Q1BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) VDD VSS
+ PRESET2 RESET2 CLOCK
+ TE2 TE2 Q2O Q2BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) VDD VSS
+ PRESET3 RESET3 CLOCK
+ TE3 TE3 Q3O Q3BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) VDD VSS
+ PRESET4 RESET4 CLOCK
+ TE4 TE4 Q4O Q4BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 PINDLY(5,0,4) VDD VSS
+ Q1O Q2O Q3O Q4O COUTO
+ CLK RESET PREENAB CIN
+ Q1 Q2 Q3 Q4 COUT
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          EDGE = {CHANGED_LH(CLK,0)}
+          REPRE = {CHANGED(RESET,0) | CHANGED(PREENAB,0)}
+          CARRYIN = {CHANGED(CIN,0)}
+ PINDLY:
+        Q1 Q2 Q3 Q4 = {
+         CASE(
+          REPRE & (TRN_LH | TRN_HL), DELAY(-1,285NS,570NS),
+          EDGE & (TRN_LH | TRN_HL), DELAY(-1,220NS,500NS),
+          DELAY(-1,286NS,571NS))}
+        COUT = {
+          CASE(
+          REPRE & (TRN_LH | TRN_HL), DELAY(-1,420NS,860NS),
+          CARRYIN & (TRN_LH | TRN_HL), DELAY(-1,260NS,500NS),
+          EDGE & (TRN_LH | TRN_HL), DELAY(-1,315NS,630NS),
+          DELAY(-1,421NS,861NS))}

U7 CONSTRAINT(5) VDD VSS
+ CLK RESET PREENAB U/D CIN
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ WIDTH:
+    NODE = CLK
+    MIN_LO = 160NS
+    MIN_HI = 160NS
+ SETUP_HOLD:
+    CLOCK LH = CLK
+    DATA(1) = CIN
+    SETUPTIME = 100NS
+ SETUP_HOLD:
+    CLOCK LH = CLK
+    DATA(1) = U/D
+    SETUPTIME = 200NS
+ FREQ:
+    NODE = CLK
+    MAXFREQ = 3.1MEG
+ WIDTH:
+    NODE = RESET
+    MIN_HI = 90NS
+ WIDTH:
+     NODE = PREENAB
+     MIN_HI = 90NS
+ SETUP_HOLD:
+     CLOCK LH = CLK
+     DATA(2) = RESET PREENAB
+     SETUPTIME_LO = 170NS

.ENDS CD4510B

*------------------------------------------------------------CD4511B-----

* CMOS BCD to Seven Segment Latch Decoder Drivers
* Harris AnswerFax document # 901
* jat 12/18/95

.SUBCKT CD4511B
+ BCDD BCDC BCDB BCDA LTBAR BLBAR LE A B C D E F G
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(7,8) VDD VSS
+ BCDDL BCDCL BCDBL BCDAL LTBAR BLBAR LE
+ AO BO CO DO EO FO GO LEBAR
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+ BCDDLBAR = {~BCDDL}
+ BCDCLBAR = {~BCDCL}
+ BCDBLBAR = {~BCDBL}
+ BCDALBAR = {~BCDAL}
+ AX = {(BCDDL & BCDCLBAR & BCDBLBAR) | (BCDDLBAR & BCDCL & BCDAL) |
+       (BCDDLBAR & BCDBL & BCDAL) | (BCDDLBAR & BCDCLBAR & BCDALBAR)}
+ BX = {(BCDDLBAR & BCDCLBAR) | (BCDDLBAR & BCDBLBAR & BCDALBAR) |
+       (BCDDLBAR & BCDBL & BCDAL) | (BCDDL & BCDCLBAR & BCDBLBAR)}
+ CX = {(BCDDLBAR & BCDCL) | (BCDCLBAR & BCDBLBAR) | (BCDDLBAR & BCDAL)}
+ DX = {(BCDCLBAR & BCDBLBAR & BCDALBAR) | (BCDDLBAR & BCDCL & BCDBLBAR & BCDAL) |
+       (BCDDLBAR & BCDCLBAR & BCDBL) | (BCDDLBAR & BCDBL & BCDALBAR)}
+ EX = {(BCDCLBAR & BCDBLBAR & BCDALBAR) | (BCDDLBAR & BCDBL & BCDALBAR)}
+ FX = {(BCDDLBAR & BCDCL & BCDBLBAR) | (BCDDLBAR & BCDCL & BCDALBAR) |
+       (BCDDL & BCDCLBAR & BCDBLBAR) | (BCDCLBAR & BCDBLBAR & BCDALBAR)}
+ GX = {(BCDDLBAR & BCDCL & BCDBLBAR) | (BCDDL & BCDCLBAR & BCDBLBAR) |
+       (BCDDLBAR & BCDCLBAR & BCDBL) | (BCDDLBAR & BCDBL & BCDALBAR)}
+ AO = {BLBAR & (AX | (~LTBAR))}
+ BO = {BLBAR & (BX | (~LTBAR))}
+ CO = {BLBAR & (CX | (~LTBAR))}
+ DO = {BLBAR & (DX | (~LTBAR))}
+ EO = {BLBAR & (EX | (~LTBAR))}
+ FO = {BLBAR & (FX | (~LTBAR))}
+ GO = {BLBAR & (GX | (~LTBAR))}
+ LEBAR = {~LE}

U2 DLTCH(4) VDD VSS
+ $D_HI $D_HI LEBAR
+ BCDD BCDC BCDB BCDA BCDDL BCDCL BCDBL BCDAL $D_NC $D_NC $D_NC $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(7,0,6) VDD VSS
+ AO BO CO DO EO FO GO
+ BCDD BCDC BCDB BCDA BLBAR LTBAR
+ A B C D E F G
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    DATA = {CHANGED(BCDD,0) | CHANGED(BCDC,0) | CHANGED(BCDB,0) |
+            CHANGED(BCDA,0)}
+    BLANK = {CHANGED(BLBAR,0)}
+    LAMP = {CHANGED(LTBAR,0)}
+ PINDLY:
+    A B C D E F G = {
+       CASE(
+          BLANK & TRN_LH, DELAY(-1,400NS,800NS),
+          BLANK & TRN_HL, DELAY(-1,350NS,700NS),
+          LAMP & TRN_LH, DELAY(-1,150NS,300NS), 
+          LAMP & TRN_HL, DELAY(-1,250NS,500NS),
+          DATA & TRN_LH, DELAY(-1,660NS,1320NS),
+          DATA & TRN_HL, DELAY(-1,520NS,1040NS),
+          DELAY(-1,661NS,1321NS))}

U4 CONSTRAINT(5) VDD VSS
+ BCDD BCDC BCDB BCDA LE
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+   CLOCK HL = LE
+   DATA(4) = BCDD BCDC BCDB BCDA
+   SETUPTIME = 75NS
+ WIDTH:
+   NODE = LE
+   MIN_LO = 200NS
+   MIN_HI = 200NS

.ENDS CD4511B

*--------------------------------------------------------------CD4512B----

* CMOS 8-Channel Data Selector
* Harris AnswerFax document # 1032
* jat 12/18/95

.SUBCKT CD4512B
+ D0 D1 D2 D3 D4 D5 D6 D7 A B C INH TRIDIS SELOUT
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(12,1) VDD VSS
+ A B C D0 D1 D2 D3 D4 D5 D6 D7 INH
+ SELOUTO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CBAR = {~C}
+   BBAR = {~B}
+   ABAR = {~A}
+   OUT = {(CBAR & BBAR & ABAR & D0) | (CBAR & BBAR & A & D1) |
+          (CBAR & B & ABAR & D2) | (CBAR & B & A & D3) |
+          (C & BBAR & ABAR & D4) | (C & BBAR & A & D5) |
+          (C & B & ABAR & D6) | (C & B & A & D7)}
+   SELOUTO = {OUT & (~INH)}

U2 PINDLY(1,1,12) VDD VSS
+ SELOUTO
+ TRIDIS
+ D0 D1 D2 D3 D4 D5 D6 D7 A B C INH
+ SELOUT
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    DATA = {CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) |
+            CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0)}
+    SELECT = {CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0)}
+    INHIBIT = {CHANGED(INH,0)}
+ TRISTATE:
+    ENABLE LO = TRIDIS
+    SELOUT = {
+      CASE(
+        (TRN_Z$ | TRN_$Z), DELAY(-1,60NS,120NS),
+        INHIBIT & (TRN_LH | TRN_HL), DELAY(-1,140NS,280NS),
+        SELECT & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+        DATA & (TRN_LH | TRN_HL), DELAY(-1,180NS,360NS),
+        DELAY(-1,201NS,401NS))}

.ENDS CD4512B

*-------------------------------------------------------------CD4514B-----

* 4 Bit Latched/4 to 16 Line Decoders
* National CMOS Logic Databook, 1988, pages 5-270 to 5-274
* jat 9/11/95

.SUBCKT CD4514B
+ INA INB INC IND STR INH S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 S11 S12 S13
+ S14 S15
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(14,24) VDD VSS
+ INA INB INC IND STR INH QA QB QC QD QABAR QBBAR QCBAR QDBAR
+ SA RA SB RB SC RC SD RD S0O S1O S2O S3O S4O S5O S6O S7O S8O S9O S10O S11O
+ S12O S13O S14O S15O
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+     SA = {INA & STR}
+     RA = {(~INA) & STR}
+     SB = {INB & STR}
+     RB = {(~INB) & STR}
+     SC = {INC & STR}
+     RC = {(~INC) & STR}
+     SD = {IND & STR}
+     RD = {(~IND) & STR}
+     NOR1 = {QABAR & QBBAR}
+     NOR2 = {QA & QBBAR}
+     NOR3 = {QABAR & QB}
+     NOR4 = {QA & QB}
+     NOR5 = {QCBAR & QDBAR}
+     NOR6 = {QC & QDBAR}
+     NOR7 = {QCBAR & QD}
+     NOR8 = {QC & QD}
+     S0O = {(NOR5 & NOR1 & (~INH))}
+     S1O = {(NOR5 & NOR2 & (~INH))}
+     S2O = {(NOR5 & NOR3 & (~INH))}
+     S3O = {(NOR5 & NOR4 & (~INH))}
+     S4O = {(NOR6 & NOR1 & (~INH))}
+     S5O = {(NOR6 & NOR2 & (~INH))}
+     S6O = {(NOR6 & NOR3 & (~INH))}
+     S7O = {(NOR6 & NOR4 & (~INH))}
+     S8O = {(NOR7 & NOR1 & (~INH))}
+     S9O = {(NOR7 & NOR2 & (~INH))}
+     S10O = {(NOR7 & NOR3 & (~INH))}
+     S11O = {(NOR7 & NOR4 & (~INH))}
+     S12O = {(NOR8 & NOR1 & (~INH))}
+     S13O = {(NOR8 & NOR2 & (~INH))}
+     S14O = {(NOR8 & NOR3 & (~INH))}
+     S15O = {(NOR8 & NOR4 & (~INH))}

U2 SRFF(4) VDD VSS
+ $D_HI $D_HI $D_HI
+ SA SB SC SD RA RB RC RD QA QB QC QD QABAR QBBAR QCBAR QDBAR
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(16,0,1) VDD VSS
+ S0O S1O S2O S3O S4O S5O S6O S7O S8O S9O S10O S11O S12O S13O S14O S15O
+ INH
+ S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 S11 S12 S13 S14 S15
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN: 
+          INHIBIT = {CHANGED(INH,0)}
+ PINDLY:
+          S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 S11 S12 S13 S14 S15 = {
+            CASE(
+          INHIBIT & (TRN_LH | TRN_HL), DELAY(-1,400NS,800NS),
+          (TRN_LH | TRN_HL), DELAY(-1,550NS,1100NS),
+          DELAY(-1,401NS,801NS))}

U4 CONSTRAINT(5) VDD VSS
+ STR INA INB INC IND
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+     CLOCK HL = STR
+     DATA(4) = INA INB INC IND
+     SETUPTIME = 125NS
+ WIDTH:
+      NODE = STR
+      MIN_HI = 175NS

.ENDS CD4514B

*-------------------------------------------------------------CD4515B-----

* 4 Bit Latched/4 to 16 Line Decoders
* National CMOS Logic Databook, 1988, pages 5-270 to 5-274
* jat 9/11/95

.SUBCKT CD4515B
+ INA INB INC IND STR INH S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 S11 S12 S13
+ S14 S15
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(14,24) VDD VSS
+ INA INB INC IND STR INH QA QB QC QD QABAR QBBAR QCBAR QDBAR
+ SA RA SB RB SC RC SD RD S0O S1O S2O S3O S4O S5O S6O S7O S8O S9O S10O S11O
+ S12O S13O S14O S15O
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+     SA = {INA & STR}
+     RA = {(~INA) & STR}
+     SB = {INB & STR}
+     RB = {(~INB) & STR}
+     SC = {INC & STR}
+     RC = {(~INC) & STR}
+     SD = {IND & STR}
+     RD = {(~IND) & STR}
+     NOR1 = {QABAR & QBBAR}
+     NOR2 = {QA & QBBAR}
+     NOR3 = {QABAR & QB}
+     NOR4 = {QA & QB}
+     NOR5 = {QCBAR & QDBAR}
+     NOR6 = {QC & QDBAR}
+     NOR7 = {QCBAR & QD}
+     NOR8 = {QC & QD}
+     S0O = {~(NOR5 & NOR1 & (~INH))}
+     S1O = {~(NOR5 & NOR2 & (~INH))}
+     S2O = {~(NOR5 & NOR3 & (~INH))}
+     S3O = {~(NOR5 & NOR4 & (~INH))}
+     S4O = {~(NOR6 & NOR1 & (~INH))}
+     S5O = {~(NOR6 & NOR2 & (~INH))}
+     S6O = {~(NOR6 & NOR3 & (~INH))}
+     S7O = {~(NOR6 & NOR4 & (~INH))}
+     S8O = {~(NOR7 & NOR1 & (~INH))}
+     S9O = {~(NOR7 & NOR2 & (~INH))}
+     S10O = {~(NOR7 & NOR3 & (~INH))}
+     S11O = {~(NOR7 & NOR4 & (~INH))}
+     S12O = {~(NOR8 & NOR1 & (~INH))}
+     S13O = {~(NOR8 & NOR2 & (~INH))}
+     S14O = {~(NOR8 & NOR3 & (~INH))}
+     S15O = {~(NOR8 & NOR4 & (~INH))}

U2 SRFF(4) VDD VSS
+ $D_HI $D_HI $D_HI
+ SA SB SC SD RA RB RC RD QA QB QC QD QABAR QBBAR QCBAR QDBAR
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(16,0,1) VDD VSS
+ S0O S1O S2O S3O S4O S5O S6O S7O S8O S9O S10O S11O S12O S13O S14O S15O
+ INH
+ S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 S11 S12 S13 S14 S15
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN: 
+          INHIBIT = {CHANGED(INH,0)}
+ PINDLY:
+          S0 S1 S2 S3 S4 S5 S6 S7 S8 S9 S10 S11 S12 S13 S14 S15 = {
+            CASE(
+          INHIBIT & (TRN_LH | TRN_HL), DELAY(-1,400NS,800NS),
+          (TRN_LH | TRN_HL), DELAY(-1,550NS,1100NS),
+          DELAY(-1,401NS,801NS))}

U4 CONSTRAINT(5) VDD VSS
+ STR INA INB INC IND
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+     CLOCK HL = STR
+     DATA(4) = INA INB INC IND
+     SETUPTIME = 125NS
+ WIDTH:
+      NODE = STR
+      MIN_HI = 175NS

.ENDS CD4515B

*------------------------------------------------------------------CD4516B--

* Binary Up/Down Counter
* National CMOS Logic Databook, 1988, pages 5-252 to 5-258
* jat 9/11/95

.SUBCKT CD4516B
+ P1 P2 P3 P4 Q1 Q2 Q3 Q4 CLK U/D RESET PREENAB CIN COUT
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(17,14) VDD VSS
+ RESET PREENAB CLK P1 P2 P3 P4 CIN U/D Q1O Q2O Q3O Q4O Q1BARO Q2BARO
+ Q3BARO Q4BARO 
+ CLOCK PRESET1 RESET1 PRESET2 RESET2 PRESET3 RESET3 PRESET4 RESET4 
+ TE1 TE2 TE3 TE4 COUTO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  CLOCK = {~(RESET | PREENAB | CLK)}
+  PRESET1 = {~((~RESET) & PREENAB & P1)}
+  RESET1 = {((~RESET) & (~PREENAB)) | ((~RESET) & PREENAB & P1)}
+  PRESET2 = {~((~RESET) & PREENAB & P2)}
+  RESET2 = {((~RESET) & (~PREENAB)) | ((~RESET) & PREENAB & P2)}
+  PRESET3 = {~((~RESET) & PREENAB & P3)}
+  RESET3 = {((~RESET) & (~PREENAB)) | ((~RESET) & PREENAB & P3)}
+  PRESET4 = {~((~RESET) & PREENAB & P4)}
+  RESET4 = {((~RESET) & (~PREENAB)) | ((~RESET) & PREENAB & P4)}
+  TE1 = {~CIN}
+  UDBAR = {~U/D}
+  TE2INA = {~(TE1 & Q1O)}
+  TE2INB = {~(TE1 & Q1BARO)}
+  TE2INC = {UDBAR}
+  TE2IND = {U/D}
+  TE2 = {~((TE2INA | TE2INC) & (TE2INB | TE2IND))}
+  TE3INA = {~(Q2O & U/D)}
+  TE3INB = {~(Q2BARO & UDBAR)}
+  TE3INC = {TE2INA}
+  TE3IND = {TE2INB}
+  TE3 = {~((TE3INA | TE3INC) & (TE3INB | TE3IND))}
+  TE4INA = {~(Q3BARO & Q2BARO & UDBAR)}
+  AND4 = {Q2O & Q3O}
+  TE4INB = {~(U/D & AND4)}
+  TE4INC = {TE2INB}
+  TE4IND = {TE2INA}
+  TE4 = {~((TE4INA | TE4INC) & (TE4INB | TE4IND))}
+  NANDCOUT1 = {~(Q2BARO & Q3BARO & Q4BARO & UDBAR)}
+  ANDCOUT = {Q3O & Q2O}
+  NANDCOUT2 = {~(Q4O & ANDCOUT & U/D)}
+  COUTO = {(NANDCOUT1 | TE4INC) & (NANDCOUT2 | TE4IND)}

U2 JKFF(1) VDD VSS
+ PRESET1 RESET1 CLOCK
+ TE1 TE1 Q1O Q1BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) VDD VSS
+ PRESET2 RESET2 CLOCK
+ TE2 TE2 Q2O Q2BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) VDD VSS
+ PRESET3 RESET3 CLOCK
+ TE3 TE3 Q3O Q3BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) VDD VSS
+ PRESET4 RESET4 CLOCK
+ TE4 TE4 Q4O Q4BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 PINDLY(5,0,4) VDD VSS
+ Q1O Q2O Q3O Q4O COUTO
+ CLK RESET PREENAB CIN
+ Q1 Q2 Q3 Q4 COUT
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          EDGE = {CHANGED_LH(CLK,0)}
+          REPRE = {CHANGED(RESET,0) | CHANGED(PREENAB,0)}
+          CARRYIN = {CHANGED(CIN,0)}
+ PINDLY:
+        Q1 Q2 Q3 Q4 = {
+         CASE(
+          REPRE & (TRN_LH | TRN_HL), DELAY(-1,285NS,570NS),
+          EDGE & (TRN_LH | TRN_HL), DELAY(-1,220NS,500NS),
+          DELAY(-1,286NS,571NS))}
+        COUT = {
+          CASE(
+          REPRE & (TRN_LH | TRN_HL), DELAY(-1,420NS,860NS),
+          CARRYIN & (TRN_LH | TRN_HL), DELAY(-1,260NS,500NS),
+          EDGE & (TRN_LH | TRN_HL), DELAY(-1,315NS,630NS),
+          DELAY(-1,421NS,861NS))}

U7 CONSTRAINT(5) VDD VSS
+ CLK RESET PREENAB U/D CIN
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ WIDTH:
+    NODE = CLK
+    MIN_LO = 160NS
+    MIN_HI = 160NS
+ SETUP_HOLD:
+    CLOCK LH = CLK
+    DATA(1) = CIN
+    SETUPTIME = 100NS
+ SETUP_HOLD:
+    CLOCK LH = CLK
+    DATA(1) = U/D
+    SETUPTIME = 200NS
+ FREQ:
+    NODE = CLK
+    MAXFREQ = 3.1MEG
+ WIDTH:
+    NODE = RESET
+    MIN_HI = 90NS
+ WIDTH:
+     NODE = PREENAB
+     MIN_HI = 90NS
+ SETUP_HOLD:
+     CLOCK LH = CLK
+     DATA(2) = RESET PREENAB
+     SETUPTIME_LO = 170NS

.ENDS CD4516B

*-----------------------------------------------------------CD4517B------

* Dual 64 Bit Static Shift Register
* Motorola CMOS Logic Databook, 1991, pages 6-288 to 6-291
* jat 9/11/95

.SUBCKT CD4517B
+ CLK D WE Q16 Q32 Q48 Q64
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 DFF(64) VDD VSS
+ $D_HI $D_HI CLK
* 64 D Nodes
+ D 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27
+ 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52
+ 53 54 55 56 57 58 59 60 61 62 63
* 64 Q Nodes
+ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27
+ 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52
+ 53 54 55 56 57 58 59 60 61 62 63 64
* 64 Qbar Nodes
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(4,1,0) VDD VSS
+ 16 32 48 64
+ WE
+ Q16 Q32 Q48 Q64
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+    ENABLE LO = WE
+       Q16 Q32 Q48 Q64 = {
+         CASE(
+           TRN_LH | TRN_HL, DELAY(-1,475NS,770NS),
+           DELAY(-1,476NS,771NS))}

U3 CONSTRAINT(3) VDD VSS
+ CLK D WE
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ WIDTH:
+     NODE = CLK
+     MIN_LO = 170NS
+     MIN_HI = 170NS
+ FREQ:
+     NODE = CLK
+     MAXFREQ = 3MEG
+ SETUP_HOLD:
+     CLOCK LH = CLK
+     DATA(1) = D
+     HOLDTIME = 75NS
+ SETUP_HOLD:
+     CLOCK LH = CLK
+     DATA(1) = WE
+     SETUPTIME = 170NS
+     HOLDTIME = 160NS

.ENDS CD4517B

*-------------------------------------------------------------CD4518B-----

* Dual Synchronous Up Counter
* National CMOS Logic Databook, 1988, pages 5-275 to 5-279
* jat 9/11/95

.SUBCKT CD4518B
+ RESET CLOCK ENAB Q1 Q2 Q3 Q4
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(7,5) VDD VSS
+ ENAB CLOCK RESET Q1O Q2O Q3O Q4BARO
+ CLKIN RESETBAR CLKIN2 CLKIN3 CLKIN4
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+      CLKIN = {ENAB & (~CLOCK)}
+      RESETBAR = {~RESET}
+      CLKIN2 = {Q1O & CLKIN & Q4BARO}
+      CLKIN3 = {Q1O & CLKIN & Q2O}
+      NANDX = {~(Q3O & Q2O)}
+      NANDIN = {~(NANDX & Q4BARO)}
+      CLKIN4 = {Q1O & CLKIN & NANDIN}

U2 JKFF(1) VDD VSS
+ $D_HI RESETBAR CLKIN
+ $D_HI $D_HI Q1O Q1BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) VDD VSS
+ $D_HI RESETBAR CLKIN2
+ $D_HI $D_HI Q2O Q2BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) VDD VSS
+ $D_HI RESETBAR CLKIN3
+ $D_HI $D_HI Q3O Q3BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) VDD VSS
+ $D_HI RESETBAR CLKIN4
+ $D_HI $D_HI Q4O Q4BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 PINDLY(4,0,1) VDD VSS
+ Q1O Q2O Q3O Q4O
+ RESET
+ Q1 Q2 Q3 Q4
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+      RESETIT = {CHANGED_LH(RESET,0)}
+ PINDLY:
+       Q1 Q2 Q3 Q4 = {
+        CASE(
+      RESETIT & TRN_HL, DELAY(-1,220NS,560NS),
+      TRN_LH | TRN_HL, DELAY(-1,325NS,650NS),
+      DELAY(-1,326NS,651NS))}

U7 CONSTRAINT(3) VDD VSS
+ CLOCK ENAB RESET
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ FREQ:
+       NODE = CLOCK
+       MAXFREQ = 3MEG
+ WIDTH:
+       NODE = CLOCK
+       MIN_LO = 10NS
+       MIN_HI = 10NS
+ WIDTH:
+       NODE = ENAB
+       MIN_LO = 125NS
+       MIN_HI = 125NS
+ WIDTH:
+       NODE = RESET
+       MIN_HI = 180NS

.ENDS CD4518B

*-------------------------------------------------------------CD4519B-----

* 4 Bit AND/OR Selector
* National CMOS Logic Databook, 1988, pages 5-280 to 5-283
* jat 9/11/95

.SUBCKT CD4519B
+ A B X0 X1 X2 X3 Y0 Y1 Y2 Y3 Z0 Z1 Z2 Z3
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(10,4) VDD VSS
+ A B X0 X1 X2 X3 Y0 Y1 Y2 Y3
+ Z0O Z1O Z2O Z3O
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   XNOR0 = {~((~((~A) | X0)) ^ (~((~B) | Y0)))}
+   Z0O = {XNOR0 & (~((~A) & (~B)))}
+   XNOR1 = {~((~((~A) | X1)) ^ (~((~B) | Y1)))}
+   Z1O = {XNOR1 & (~((~A) & (~B)))}
+   XNOR2 = {~((~((~A) | X2)) ^ (~((~B) | Y2)))}
+   Z2O = {XNOR2 & (~((~A) & (~B)))}
+   XNOR3 = {~((~((~A) | X3)) ^ (~((~B) | Y3)))}
+   Z3O = {XNOR3 & (~((~A) & (~B)))}

U2 PINDLY(4,0,0) VDD VSS
+ Z0O Z1O Z2O Z3O
+ Z0 Z1 Z2 Z3
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+       Z0 Z1 Z2 Z3 = {
+         CASE(
+         TRN_LH | TRN_HL, DELAY(-1,180NS,360NS),
+         DELAY(-1,181NS,361NS))}

.ENDS CD4519B

*-------------------------------------------------------------CD4520B-----

* Dual Synchronous Up Counter
* National CMOS Logic Databook, 1988, pages 5-275 to 5-279
* jat 9/11/95

.SUBCKT CD4520B
+ RESET CLOCK ENAB Q1 Q2 Q3 Q4
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(6,5) VDD VSS
+ ENAB CLOCK RESET Q1O Q2O Q3O
+ CLKIN RESETBAR CLKIN2 CLKIN3 CLKIN4
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+      CLKIN = {ENAB & (~CLOCK)}
+      RESETBAR = {~RESET}
+      CLKIN2 = {Q1O & CLKIN}
+      CLKIN3 = {Q1O & CLKIN & Q2O}
+      CLKIN4 = {Q1O & Q2O & Q3O & CLKIN}

U2 JKFF(1) VDD VSS
+ $D_HI RESETBAR CLKIN
+ $D_HI $D_HI Q1O Q1BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) VDD VSS
+ $D_HI RESETBAR CLKIN2
+ $D_HI $D_HI Q2O Q2BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) VDD VSS
+ $D_HI RESETBAR CLKIN3
+ $D_HI $D_HI Q3O Q3BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) VDD VSS
+ $D_HI RESETBAR CLKIN4
+ $D_HI $D_HI Q4O Q4BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 PINDLY(4,0,1) VDD VSS
+ Q1O Q2O Q3O Q4O
+ RESET
+ Q1 Q2 Q3 Q4
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+      RESETIT = {CHANGED_LH(RESET,0)}
+ PINDLY:
+       Q1 Q2 Q3 Q4 = {
+        CASE(
+      RESETIT & TRN_HL, DELAY(-1,220NS,560NS),
+      TRN_LH | TRN_HL, DELAY(-1,325NS,650NS),
+      DELAY(-1,326NS,651NS))}

U7 CONSTRAINT(3) VDD VSS
+ CLOCK ENAB RESET
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ FREQ:
+       NODE = CLOCK
+       MAXFREQ = 3MEG
+ WIDTH:
+       NODE = CLOCK
+       MIN_LO = 10NS
+       MIN_HI = 10NS
+ WIDTH:
+       NODE = ENAB
+       MIN_LO = 125NS
+       MIN_HI = 125NS
+ WIDTH:
+       NODE = RESET
+       MIN_HI = 180NS

.ENDS CD4520B

*----------------------------------------------------------CD4522B--------

* Programmable Divide by N 4 Bit BCD Counter
* National CMOS Logic Databook, 1988, pages 5-284 to 5-291
* jat 9/12/95

.SUBCKT CD4522B
+ DP1 DP2 DP3 DP4 Q1 Q2 Q3 Q4 CLK INH PREENAB MR ZERO CF
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,14) VDD VSS
+ CLK INH PREENAB DP1 DP2 DP3 DP4 MR Q2O Q3O Q4O Q1BARO Q2BARO Q3BARO Q4BARO
+ CF
+ CLOCK PRESET1 RESET1 PRESET2 RESET2 PRESET3 RESET3 PRESET4 RESET4 T4 T3 T2
+ R S
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+     CLOCK = {~((~((~CLK) | INH)) | PREENAB)}
+     PRESET1 = {~((~MR) & PREENAB & DP1)}
+     RESET1 = {((~MR) & (~PREENAB)) | ((~MR) & PREENAB & DP1)}
+     PRESET2 = {~((~MR) & PREENAB & DP2)}
+     RESET2 = {((~MR) & (~PREENAB)) | ((~MR) & PREENAB & DP2)}
+     PRESET3 = {~((~MR) & PREENAB & DP3)}
+     RESET3 = {((~MR) & (~PREENAB)) | ((~MR) & PREENAB & DP3)}
+     PRESET4 = {~((~MR) & PREENAB & DP4)}
+     RESET4 = {((~MR) & (~PREENAB)) | ((~MR) & PREENAB & DP4)}
+     T4 = {Q3BARO & Q2BARO & Q1BARO}
+     NAND4 = {~(Q4BARO & T4)}
+     T3 = {Q2BARO & Q1BARO & NAND4}
+     T2 = {Q1BARO & NAND4}
+     NOR0 = {~(Q2O | Q3O | Q4O)}
+     NAND0 = {~(NOR0 & Q1BARO & CF)}
+     AND0 = {NOR0 & Q1BARO & CF & (~PREENAB)}
+     NORR = {~(MR | (~(INH | (~CLK))))}
+     ANDR1 = {NORR & PREENAB}
+     ANDR2 = {(~PREENAB) & NAND0}
+     R = {ANDR1 | ANDR2}
+     S = {AND0 | MR}

U2 JKFF(1) VDD VSS
+ PRESET1 RESET1 CLOCK
+ $D_HI $D_HI Q1O Q1BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) VDD VSS
+ PRESET2 RESET2 CLOCK
+ T2 T2 Q2O Q2BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) VDD VSS
+ PRESET3 RESET3 CLOCK
+ T3 T3 Q3O Q3BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) VDD VSS
+ PRESET4 RESET4 CLOCK
+ T4 T4 Q4O Q4BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 SRFF(1) VDD VSS
+ $D_HI $D_HI $D_HI
+ S R ZEROO $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 PINDLY(5,0,1) VDD VSS
+ Q1O Q2O Q3O Q4O ZEROO
+ CLK
+ Q1 Q2 Q3 Q4 ZERO
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+        Q1 Q2 Q3 Q4 = {
+          CASE(
+            CHANGED_LH(CLK,0) & (TRN_LH | TRN_HL), DELAY(-1,350NS,825NS),
+            DELAY(-1,351NS,826NS))}
+        ZERO = {
+          CASE(
+            CHANGED_LH(CLK,0) & (TRN_LH | TRN_HL), DELAY(-1,200NS,500NS),
+            DELAY(-1,201NS,501NS))}

U8 CONSTRAINT(7) VDD VSS
+ CLK PREENAB DP1 DP2 DP3 DP4 MR
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ WIDTH:
+    NODE = CLK
+    MIN_HI = 120NS
+    MIN_LO = 120NS
+ FREQ:
+    NODE = CLK
+    MAXFREQ = 2.9MEG
+ SETUP_HOLD:
+    CLOCK LH = PREENAB
+    DATA(4) = DP1 DP2 DP3 DP4
+    HOLDTIME = 40NS
+ WIDTH:
+    NODE = PREENAB
+    MIN_HI = 120NS
+ WIDTH:
+    NODE = MR
+    MIN_HI = 160NS

.ENDS CD4522B

*----------------------------------------------------------CD4526B--------

* Programmable Divide by N 4 Bit Binary Counter
* National CMOS Logic Databook, 1988, pages 5-284 to 5-291
* jat 9/12/95

.SUBCKT CD4526B
+ DP1 DP2 DP3 DP4 Q1 Q2 Q3 Q4 CLK INH PREENAB MR ZERO CF
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,14) VDD VSS
+ CLK INH PREENAB DP1 DP2 DP3 DP4 MR Q2O Q3O Q4O Q1BARO Q2BARO Q3BARO Q4BARO
+ CF
+ CLOCK PRESET1 RESET1 PRESET2 RESET2 PRESET3 RESET3 PRESET4 RESET4 T4 T3 T2
+ R S
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+     CLOCK = {~((~((~CLK) | INH)) | PREENAB)}
+     PRESET1 = {~((~MR) & PREENAB & DP1)}
+     RESET1 = {((~MR) & (~PREENAB)) | ((~MR) & PREENAB & DP1)}
+     PRESET2 = {~((~MR) & PREENAB & DP2)}
+     RESET2 = {((~MR) & (~PREENAB)) | ((~MR) & PREENAB & DP2)}
+     PRESET3 = {~((~MR) & PREENAB & DP3)}
+     RESET3 = {((~MR) & (~PREENAB)) | ((~MR) & PREENAB & DP3)}
+     PRESET4 = {~((~MR) & PREENAB & DP4)}
+     RESET4 = {((~MR) & (~PREENAB)) | ((~MR) & PREENAB & DP4)}
+     T4 = {Q3BARO & Q2BARO & Q1BARO}
+     T3 = {Q2BARO & Q1BARO}
+     T2 = {Q1BARO}
+     NOR0 = {~(Q2O | Q3O | Q4O)}
+     NAND0 = {~(NOR0 & Q1BARO & CF)}
+     AND0 = {NOR0 & Q1BARO & CF & (~PREENAB)}
+     NORR = {~(MR | (~(INH | (~CLK))))}
+     ANDR1 = {NORR & PREENAB}
+     ANDR2 = {(~PREENAB) & NAND0}
+     R = {ANDR1 | ANDR2}
+     S = {AND0 | MR}

U2 JKFF(1) VDD VSS
+ PRESET1 RESET1 CLOCK
+ $D_HI $D_HI Q1O Q1BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) VDD VSS
+ PRESET2 RESET2 CLOCK
+ T2 T2 Q2O Q2BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) VDD VSS
+ PRESET3 RESET3 CLOCK
+ T3 T3 Q3O Q3BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) VDD VSS
+ PRESET4 RESET4 CLOCK
+ T4 T4 Q4O Q4BARO
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 SRFF(1) VDD VSS
+ $D_HI $D_HI $D_HI
+ S R ZEROO $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 PINDLY(5,0,1) VDD VSS
+ Q1O Q2O Q3O Q4O ZEROO
+ CLK
+ Q1 Q2 Q3 Q4 ZERO
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+        Q1 Q2 Q3 Q4 = {
+          CASE(
+            CHANGED_LH(CLK,0) & (TRN_LH | TRN_HL), DELAY(-1,350NS,825NS),
+            DELAY(-1,351NS,826NS))}
+        ZERO = {
+          CASE(
+            CHANGED_LH(CLK,0) & (TRN_LH | TRN_HL), DELAY(-1,200NS,500NS),
+            DELAY(-1,201NS,501NS))}

U8 CONSTRAINT(7) VDD VSS
+ CLK PREENAB DP1 DP2 DP3 DP4 MR
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ WIDTH:
+    NODE = CLK
+    MIN_HI = 120NS
+    MIN_LO = 120NS
+ FREQ:
+    NODE = CLK
+    MAXFREQ = 2.9MEG
+ SETUP_HOLD:
+    CLOCK LH = PREENAB
+    DATA(4) = DP1 DP2 DP3 DP4
+    HOLDTIME = 40NS
+ WIDTH:
+    NODE = PREENAB
+    MIN_HI = 120NS
+ WIDTH:
+    NODE = MR
+    MIN_HI = 160NS

.ENDS CD4526B

*------------------------------------------------------------CD4527B------

* BCD Rate Multiplier
* Motorola CMOS Logic Databook, 1991, pages 6-315 to 6-320
* jat 9/12/95

.SUBCKT CD4527B
+ A B C D STR CLK EINBAR CASC SET CLR EOUT OUT OUTBAR NINE
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(17,11) VDD VSS
+ CLR SET EINBAR QA QB QC QD QABAR QCBAR QDBAR A B C D CLK STR CASC
+ RESETBAR SETBAR CLRBAR TA TB TC TD OUTBARO OUTO NINEO EOUTO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    RESETBAR = {~(CLR | SET)}
+    SETBAR = {~SET}
+    CLRBAR = {~CLR}
+    TA = {~(EINBAR | QC)}
+    TB = {~(EINBAR | QABAR)}
+    ANDC = {QA & QB}
+    NORC = {~(ANDC | QC)}
+    TC = {~(EINBAR | NORC)}
+    TD = {~(EINBAR | QCBAR)}
+    R1 = {A & QC & QDBAR}
+    R2 = {B & QABAR & QB}
+    R3 = {C & QA}
+    R4 = {D & QCBAR}
+    NORR = {~(R1 | R2 | R3 | R4)}
+    OUTBARO = {(NORR | CLK | STR) & (~CASC)}
+    OUTO = {CASC | (~OUTBARO)}
+    NINEO = {QC & QD}
+    EOUTO = {QDBAR | QCBAR | EINBAR}

U2 JKFF(1) VDD VSS
+ $D_HI RESETBAR CLK
+ TA TA QA QABAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) VDD VSS
+ $D_HI RESETBAR CLK
+ TB TB QB QBBAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) VDD VSS
+ SETBAR CLRBAR CLK
+ TC TC QC QCBAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) VDD VSS
+ SETBAR CLRBAR CLK
+ TD TD QD QDBAR
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 PINDLY(4,0,5) VDD VSS
+ OUTO OUTBARO NINEO EOUTO
+ CLK SET CLR CASC STR
+ OUT OUTBAR NINE EOUT
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+     EDGE = {CHANGED(CLK,0)}
+     SC = {CHANGED_LH(SET,0) | CHANGED_LH(CLR,0)}
+     CASCADE = {CHANGED_LH(CASC,0)}
+     STROBE = {CHANGED_LH(STR,0)}
+ PINDLY:
+     OUT = {
+      CASE(
+        CASCADE & (TRN_LH | TRN_HL), DELAY(-1,125NS,250NS),
+        STROBE & (TRN_LH | TRN_HL), DELAY(-1,130NS,260NS),
+        SC & (TRN_LH | TRN_HL), DELAY(-1,380NS,760NS),
+        EDGE & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+        DELAY(-1,381NS,761NS))}
+     OUTBAR = {
+      CASE(
+        STROBE & (TRN_LH | TRN_HL), DELAY(-1,130NS,260NS),
+        SC & (TRN_LH | TRN_HL), DELAY(-1,380NS,760NS),
+        EDGE & (TRN_LH | TRN_HL), DELAY(-1,125NS,250NS),
+        DELAY(-1,381NS,761NS))}
+     EOUT = {
+      CASE(
+        EDGE & (TRN_LH | TRN_HL), DELAY(-1,295NS,590NS),
+        DELAY(-1,296NS,591NS))}
+     NINE = {
+       CASE(
+        EDGE & (TRN_LH | TRN_HL), DELAY(-1,400NS,800NS),
+        DELAY(-1,401NS,801NS))}

U7 CONSTRAINT(5) VDD VSS
+ CLK SET CLR CLK EINBAR
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 250NS
+   MIN_LO = 250NS
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 2MEG
+ WIDTH:
+   NODE = SET
+   MIN_HI = 80NS
+ WIDTH:
+   NODE = CLR
+   MIN_HI = 80NS
+ SETUP_HOLD:
+   CLOCK HL = CLK
+   DATA(1) = EINBAR
+   SETUPTIME_LO = 175NS

.ENDS CD4527B

*------------------------------------------------------------CD4530B------

* Dual 5 Input Majority Logic Gate
* Motorola CMOS Logic Databook, 1991, pages 6-333 to 6-337
* jat 9/12/95

.SUBCKT CD4530B
+ A B C D E W Z
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(6,1) VDD VSS
+ A B C D E W
+ ZO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  M5 = {(A & B & C) | (A & B & D) | (A & B & E) | (A & C & D) |
+        (A & C & E) | (A & D & E) | (B & C & D) | (B & C & E) |
+        (B & D & E) | (C & D & E)}
+  ZO = {~(M5 ^ W)}

U2 PINDLY(1,0,6) VDD VSS
+ ZO
+ A B C D E W
+ Z
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    MODE1 = {CHANGED(D,0) & (A == '1) & (C == '1) & (W == '1) &
+             (B == '0) & (E == '0)}
+    MODE2 = {(CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) |
+             CHANGED(E,0)) & (W == '1)}
+    MODE3 = {CHANGED(W,0) & (A == '0) & (B == '0) & (C == '0) &
+             (D == '0) & (E == '0)}
+ PINDLY:
+     Z = {
+      CASE(
+         MODE1 & TRN_LH, DELAY(-1,375NS,960NS),
+         MODE1 & TRN_HL, DELAY(-1,430NS,1200NS),
+         MODE2 & TRN_LH, DELAY(-1,255NS,640NS),
+         MODE2 & TRN_HL, DELAY(-1,280NS,750NS),
+         MODE3 & (TRN_LH | TRN_HL), DELAY(-1,230NS,575NS),
+         DELAY(-1,431NS,1201NS))}

.ENDS CD4530B

*------------------------------------------------------------CD4531B------

* 12 Bit Parity Tree
* Motorola CMOS Logic Databook, 1991, pages 6-338 to 6-340
* jat 9/12/95

.SUBCKT CD4531B
+ D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 D11 W Q
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(13,1) VDD VSS
+ D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 D11 W
+ QO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   LEVEL1A = {D0 ^ D1}
+   LEVEL1B = {D2 ^ D3}
+   LEVEL1C = {D4 ^ D5}
+   LEVEL1D = {D6 ^ D7}
+   LEVEL1E = {D8 ^ D9}
+   LEVEL1F = {D10 ^ D11}
+   LEVEL2A = {LEVEL1A ^ LEVEL1B}
+   LEVEL2B = {LEVEL1C ^ LEVEL1D}
+   LEVEL2C = {LEVEL1E ^ LEVEL1F}
+   LEVEL3A = {LEVEL2A ^ LEVEL2B}
+   LEVEL3B = {LEVEL2C ^ W}
+   QO = {LEVEL3A ^ LEVEL3B}

U2 PINDLY(1,0,1) VDD VSS
+ QO
+ W
+ Q
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+    Q = {
+      CASE(
+        CHANGED(W,0) & (TRN_LH | TRN_HL), DELAY(-1,250NS,750NS),
+        DELAY(-1,440NS,1320NS))}

.ENDS CD4531B

*------------------------------------------------------------CD4532B------

* 8 Bit Priority Encoder
* Motorola CMOS Logic Databook, 1991, pages 6-341 to 6-346
* jat 9/13/95

.SUBCKT CD4532B
+ EIN D0 D1 D2 D3 D4 D5 D6 D7 GS Q0 Q1 Q2 EOUT
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(9,5) VDD VSS
+ EIN D0 D1 D2 D3 D4 D5 D6 D7
+ EOUTO Q0O Q1O Q2O GSO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   EOUTO = {EIN & (~D0) & (~D1) & (~D2) & (~D3) & (~D4) & (~D5) &
+           (~D6) & (~D7)}
+   Q0O = {EIN & ((D1 & (~D2) & (~D4) & (~D6)) | (D3 & (~D4) & (~D6)) |
+          (D5 & (~D6)) | D7)}
+   Q1O = {EIN & ((D2 & (~D4) & (~D5)) | (D3 & (~D4) & (~D5)) | D6 | D7)}
+   Q2O = {EIN & (D4 | D5 | D6 | D7)}
+   GSO = {EIN & (D0 | D1 | D2 | D3 | D4 | D5 | D6 | D7)}

U2 PINDLY(5,0,9) VDD VSS
+ EOUTO Q0O Q1O Q2O GSO
+ EIN D0 D1 D2 D3 D4 D5 D6 D7
+ EOUT Q0 Q1 Q2 GS
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          ENAB = {CHANGED(EIN,0)}
+          DATA = {CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) |
+                  CHANGED(D3,0) | CHANGED(D4,0) | CHANGED(D5,0) |
+                  CHANGED(D6,0) | CHANGED(D7,0)}
+ PINDLY:
+    Q0 Q1 Q2 = {
+      CASE(
+        ENAB & (TRN_LH | TRN_HL), DELAY(-1,280NS,560NS),
+        DATA & (TRN_LH | TRN_HL), DELAY(-1,300NS,600NS),
+        DELAY(-1,301NS,601NS))}
+    GS = {
+       CASE(
+        ENAB & (TRN_LH | TRN_HL), DELAY(-1,175NS,350NS),
+        DATA & (TRN_LH | TRN_HL), DELAY(-1,280NS,560NS),
+        DELAY(-1,281NS,561NS))}
+    EOUT = {
+       CASE(
+        ENAB & (TRN_LH | TRN_HL), DELAY(-1,205NS,410NS),
+        DELAY(-1,206NS,411NS))}

.ENDS CD4532B

*------------------------------------------------------------CD4543B------

* CMOS BCD to 7 Segment Display Latch/Decoder/Driver for LCDs
* Harris AnswerFax document # 1327
* jat 12/19/95

.SUBCKT CD4543B
+ LD BCDD BCDC BCDB BCDA PHASE BLANK A B C D E F G
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(9,7) VDD VSS
+ AL ALBAR BL BLBAR CL CLBAR DLBAR BLANK PHASE
+ AO BO CO DO EO FO GO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    NOR1 = {~(BL | CLBAR)}
+    NOR2 = {~(BLBAR | CLBAR)}
+    NOR3 = {~(BL | CL)}
+    NAND1 = {~(DLBAR & NOR3 & AL)}
+    NAND2 = {~(NOR1 & ALBAR)}
+    NAND3 = {~(NOR1 & AL)}
+    NAND4 = {~(ALBAR & CLBAR & BL)}
+    NAND5 = {~(ALBAR & NOR2)}
+    NAND6 = {~(NOR2 & AL)}
+    NAND7 = {~(AL & BL)}
+    NAND8 = {~(NOR3 & DLBAR)}
+    NORB1 = {~(DLBAR | NOR3)}
+    NORB2 = {~(BLANK | NORB1)}
+    NANDA = {~(NORB2 & NAND1 & NAND2)}
+    NANDB = {~(NORB2 & NAND3 & NAND5)}
+    NANDC = {~(NORB2 & NAND4)}
+    NANDD = {~(NORB2 & NAND1 & NAND2 & NAND6)}
+    NANDE = {~(NORB2 & NAND2 & ALBAR)}
+    NANDF = {~(NORB2 & NAND1 & NAND4 & NAND7)}
+    NANDG = {~(NORB2 & NAND6 & NAND8)}
+    AO = {NANDA ^ (~PHASE)}
+    BO = {NANDB ^ (~PHASE)}
+    CO = {NANDC ^ (~PHASE)}
+    DO = {NANDD ^ (~PHASE)}
+    EO = {NANDE ^ (~PHASE)}
+    FO = {NANDF ^ (~PHASE)}
+    GO = {NANDG ^ (~PHASE)}

U2 DLTCH(4) VDD VSS
+ $D_HI $D_HI LD
+ BCDD BCDC BCDB BCDA DL CL BL AL DLBAR CLBAR BLBAR ALBAR
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(7,0,0) VDD VSS
+ AO BO CO DO EO FO GO
+ A B C D E F G
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+    A B C D E F G = {
+       CASE(
+         TRN_LH, DELAY(-1,500NS,1000NS),
+         TRN_HL, DELAY(-1,600NS,1200NS),
+         DELAY(-1,601NS,1201NS))}

U4 CONSTRAINT(5) VDD VSS
+ LD BCDD BCDC BCDB BCDA 
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ WIDTH:
+   NODE = LD
+   MIN_HI = 125NS
+ SETUP_HOLD:
+   CLOCK HL = LD
+   DATA(4) = BCDD BCDC BCDB BCDA
+   SETUPTIME = 15NS

.ENDS CD4543B

*------------------------------------------------------------CD4547B------

* High Current BCD to Seven Segment Decoder /Driver
* Motorola CMOS Logic Databook, 1991, pages 6-393 to 6-397
* jat 9/13/95

.SUBCKT CD4547B
+ BLBAR BCDA BCDB BCDC BCDD A B C D E F G
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(5,7) VDD VSS
+ BCDA BCDB BCDC BCDD BLBAR
+ AO BO CO DO EO FO GO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    BCDABAR = {~BCDA}
+    BCDBBAR = {~BCDB}
+    BCDCBAR = {~BCDC}
+    BCDDBAR = {~BCDD}
+    NOR1 = {~(BCDBBAR | BCDC)}
+    NOR2 = {~(BCDABAR | BCDBBAR | BCDCBAR)}
+    NOR3 = {~(BCDA | BCDBBAR | BCDCBAR)}
+    NOR4 = {~(BCDABAR | BCDB | BCDCBAR)}
+    NOR5 = {~(BCDA | BCDB | BCDCBAR)}
+    NOR6 = {~(BCDA | BCDBBAR | BCDC)}
+    NOR7 = {~(BCDABAR | BCDB | BCDC)}
+    NOR8 = {~(BCDABAR | BCDB | BCDC | BCDD)}
+    NOR9 = {~(BCDB | BCDC | BCDD)}
+    NANDBL = {~(BCDBBAR & BCDCBAR)}
+    ANDBL = {NANDBL & BCDD}
+    ORBL = {ANDBL | (~BLBAR)}
+    AO = {~(ORBL | NOR3 | NOR5 | NOR8)}
+    BO = {~(ORBL | NOR3 | NOR4)}
+    CO = {~(ORBL | NOR6)}
+    DO = {~(ORBL | NOR5 | NOR2 | NOR7)}
+    EO = {~(ORBL | NOR5 | BCDA)}
+    FO = {~(ORBL | NOR1 | NOR2 | NOR8)}
+    GO = {~(ORBL | NOR2 | NOR9)}

U2 PINDLY(7,0,5) VDD VSS
+ AO BO CO DO EO FO GO
+ BCDA BCDB BCDC BCDD BLBAR
+ A B C D E F G
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    DATA = {CHANGED(BCDA,0) | CHANGED(BCDB,0) | CHANGED(BCDC,0) |
+            CHANGED(BCDD,0)}
+    BLANK = {CHANGED(BLBAR,0)}
+ PINDLY:
+     A B C D E F G = {
+       CASE(
+    BLANK & TRN_LH, DELAY(-1,750NS,1500NS),
+    BLANK & TRN_HL, DELAY(-1,500NS,1000NS),
+    DATA & (TRN_LH | TRN_HL), DELAY(-1,750NS,1500NS),
+    DELAY(-1,751NS,1501NS))}

.ENDS CD4547B

*------------------------------------------------------------CD4554B-----

* 2 Bit by 2 Bit Parallel Binary Multiplier
* Motorola CMOS Logic Databook, 1991, pages 6-418 to 6-421
* jat 9/13/95

.SUBCKT CD4554B
+ X0 X1 Y0 Y1 K0 K1 M0 M1 M2 S0 S1 S2 C1 C0
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(9,5) VDD VSS
+ X0 X1 Y0 Y1 K0 K1 M0 M1 M2
+ SA SC SD CB CD
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    LA = {X0 & Y0}
+    XORA = {M0 ^ LA}
+    ANDA1 = {M0 & LA}
+    ANDA2 = {K0 & XORA}
+    SA = {XORA ^ K0}
+    CA = {ANDA2 | ANDA1}
+    LB = {X0 & Y1}
+    XORB = {M1 ^ LB}
+    ANDB1 = {M1 & LB}
+    ANDB2 = {CA & XORB}
+    SB = {XORB ^ CA}
+    CB = {ANDB2 | ANDB1}
+    LC = {X1 & Y0}
+    XORC = {SB ^ LC}
+    ANDC1 = {SB & LC}
+    ANDC2 = {K1 & XORC}
+    SC = {XORC ^ K1}
+    CC = {ANDC2 | ANDC1}
+    LD = {X1 & Y1}
+    XORD = {M2 ^ LD}
+    ANDD1 = {M2 & LD}
+    ANDD2 = {CC & XORD}
+    SD = {XORD ^ CC}
+    CD = {ANDD2 | ANDD1}

U2 PINDLY(5,0,2) VDD VSS
+ SA SC SD CB CD
+ K0 M0
+ S0 S1 S2 C0 C1
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+      K = {CHANGED(K0,0)}
+      M = {CHANGED(M0,0)}
+ PINDLY:
+    C0 = {
+      CASE(
+         K & (TRN_LH | TRN_HL), DELAY(-1,270NS,675NS),
+         DELAY(-1,271NS,676NS))}
+    S2 = {
+      CASE(
+         M & (TRN_LH | TRN_HL), DELAY(-1,680NS,1700NS),
+         DELAY(-1,681NS,1701NS))}
+    S0 S1 C1 = {
+      CASE(
+         DELAY(-1,681NS,1701NS))}

.ENDS CD4554B

*------------------------------------------------------------CD4555B------

* Dual Binary to 1 of 4 Decoder/Demultiplexer
* Motorola CMOS Logic Databook, 1991, pages 6-422 to 6-424
* jat 9/13/95

.SUBCKT CD4555B
+ A B EBAR Q0 Q1 Q2 Q3
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(3,4) VDD VSS
+ A B EBAR
+ Q0O Q1O Q2O Q3O
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   Q0O = {(~A) & (~B) & (~EBAR)}
+   Q1O = {  A  & (~B) & (~EBAR)}
+   Q2O = {(~A) &   B  & (~EBAR)}
+   Q3O = {  A  &   B  & (~EBAR)}

U2 PINDLY(4,0,3) VDD VSS
+ Q0O Q1O Q2O Q3O 
+ A B EBAR
+ Q0 Q1 Q2 Q3
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    AB = {CHANGED(A,0) | CHANGED(B,0)}
+    E = {CHANGED(EBAR,0)}
+ PINDLY:
+      Q0 Q1 Q2 Q3 = {
+        CASE(
+    E & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+    AB & (TRN_LH | TRN_HL), DELAY(-1,220NS,440NS),
+    DELAY(-1,221NS,441NS))}

.ENDS CD4555B

*------------------------------------------------------------CD4556B------

* Dual Binary to 1 of 4 Decoder/Demultiplexer
* Motorola CMOS Logic Databook, 1991, pages 6-422 to 6-424
* jat 9/13/95

.SUBCKT CD4556B
+ A B EBAR Q0 Q1 Q2 Q3
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(3,4) VDD VSS
+ A B EBAR
+ Q0O Q1O Q2O Q3O
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   Q0O = {~((~A) & (~B) & (~EBAR))}
+   Q1O = {~(  A  & (~B) & (~EBAR))}
+   Q2O = {~((~A) &   B  & (~EBAR))}
+   Q3O = {~(  A  &   B  & (~EBAR))}

U2 PINDLY(4,0,3) VDD VSS
+ Q0O Q1O Q2O Q3O 
+ A B EBAR
+ Q0 Q1 Q2 Q3
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    AB = {CHANGED(A,0) | CHANGED(B,0)}
+    E = {CHANGED(EBAR,0)}
+ PINDLY:
+      Q0 Q1 Q2 Q3 = {
+        CASE(
+    E & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+    AB & (TRN_LH | TRN_HL), DELAY(-1,220NS,440NS),
+    DELAY(-1,221NS,441NS))}

.ENDS CD4556B

*------------------------------------------------------------CD4558B-----

* BCD to Seven Segment Decoder
* Motorola CMOS Logic Databook, 1991, pages 6-429 to 6-433
* jat 9/13/95

.SUBCKT CD4558B
+ BCDA BCDB BCDC BCDD ENABLE RBIBAR RBOBAR A B C D E F G
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(6,8) VDD VSS
+ ENABLE RBIBAR BCDA BCDB BCDC BCDD
+ AO BO CO DO EO FO GO RBOBARO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   ENABLEBAR = {~ENABLE}
+   RBI = {~RBIBAR}
+   BCDABAR = {~BCDA}
+   BCDBBAR = {~BCDB}
+   BCDCBAR = {~BCDC}
+   BCDDBAR = {~BCDD}
+   BRANCHA = {(BCDA & BCDBBAR & BCDCBAR) | (BCDABAR & BCDC)}
+   TREEA = {~(BRANCHA & BCDDBAR)}
+   TREEB = {~((BCDA & BCDBBAR & BCDDBAR) | (BCDABAR & BCDB & BCDC))}
+   BRANCHC = {(BCDA & BCDBBAR & BCDDBAR) | (BCDABAR & BCDB)}
+   TREEC = {~(BRANCHC & BCDCBAR)}
+   BRANCHD = {(BCDBBAR & BCDCBAR) | (BCDB & BCDC)}
+   LIMBD2 = {BRANCHD & BCDA}
+   LIMBD3 = {BCDBBAR & BCDC & BCDABAR}
+   TREED = {~(LIMBD2 | LIMBD3)}
+   TREEE = {~(((BCDB | BCDD) & BCDA) | (BCDBBAR & BCDC))}
+   TREEF = {~((BCDA | BCDCBAR) & BCDB)}
+   TREEG = {~((BCDBBAR & BCDCBAR & BCDDBAR) | (BCDA & BCDB & BCDC))}
+   NANDOUT = {~(BCDABAR & BCDBBAR & BCDCBAR & BCDDBAR)}
+   NOROUT1 = {~(NANDOUT | ENABLEBAR | RBIBAR)}
+   ANDOUT1 = {BCDCBAR & BCDBBAR}
+   NOROUT2 = {~(ANDOUT1 | BCDDBAR)}
+   ANDOUT2 = {ENABLEBAR & RBIBAR}
+   NOROUT3 = {~(ANDOUT2 | NOROUT1 | NOROUT2)}
+   NANDA = {~(TREEA & NOROUT3)}
+   NANDB = {~(TREEB & NOROUT3)}
+   NANDC = {~(TREEC & NOROUT3)}
+   NANDD = {~(TREED & NOROUT3)}
+   NANDE = {~(TREEE & NOROUT3)}
+   NANDF = {~(TREEF & NOROUT3)}
+   NANDG = {~(TREEG & NOROUT3)}
+   ENNAND = {~(ENABLEBAR & RBI)}
+   AO = {~(ENNAND & NANDA)}
+   BO = {~(ENNAND & NANDB)}
+   CO = {~(ENNAND & NANDC)}
+   DO = {~(ENNAND & NANDD)}
+   EO = {~(ENNAND & NANDE)}
+   FO = {~(ENNAND & NANDF)}
+   GO = {~(ENNAND & NANDG)}
+   RBOBARO = {~((~ENNAND) | NOROUT1)}

U2 PINDLY(8,0,0) VDD VSS
+ AO BO CO DO EO FO GO RBOBARO
+ A B C D E F G RBOBAR
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+    A B C D E F G RBOBAR = {
+      CASE(
+        TRN_LH, DELAY(-1,580NS,1160NS),
+        TRN_HL, DELAY(-1,780NS,1560NS),
+        DELAY(-1,781NS,1561NS))}

.ENDS CD4558B

*------------------------------------------------------------CD4560B-----

* NBCD Adder
* Motorola CMOS Logic Databook, 1991, pages 6-434 to 6-444
* jat 9/13/95

.SUBCKT CD4560B
+ CIN A1 A2 A3 A4 B1 B2 B3 B4 S1 S2 S3 S4 COUT
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(9,5) VDD VSS
+ CIN A1 A2 A3 A4 B1 B2 B3 B4
+ S1O S2O S3O S4O COUTO
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    NAND1IN = {~(A1 & B1)}
+    NOR1IN = {~((A1 & NAND1IN) | (B1 & NAND1IN))}
+    OR1IN = {~NOR1IN}
+    AND1IN = {~NAND1IN}
+    NAND2IN = {~(A2 & B2)}
+    OR2IN = {(A2 & NAND2IN) | (B2 & NAND2IN)}
+    AND2IN = {~NAND2IN}
+    NAND3IN = {~(A3 & B3)}
+    OR3IN = {(A3 & NAND3IN) | (B3 & NAND3IN)}
+    NAND4IN = {~(A4 & B4)}
+    NOR4IN = {~((A4 & NAND4IN) | (B4 & NAND4IN))}
+    NAND1OUT = {~(CIN & NOR1IN)}
+    S1O = {~((CIN & NAND1OUT) | (NAND1OUT & NOR1IN))}
+    BRANCH2 = {~((CIN & OR1IN) | AND1IN)}
+    XOR2 = {BRANCH2 ^ OR2IN}
+    XNOR2 = {~XOR2}
+    BRANCH3 = {~((CIN & OR1IN & OR2IN) | (AND1IN & OR2IN) | AND2IN)}
+    XOR3 = {BRANCH3 ^ OR3IN}
+    BRANCH4 = {~((CIN & OR1IN & OR2IN & OR3IN) | (AND1IN & OR2IN & OR3IN) | 
+                  (AND2IN & OR3IN))}
+    NANDX = {~(BRANCH4 & NAND3IN & NOR4IN)}
+    NOR41 = {~((NAND3IN & BRANCH4 & NANDX) | (NANDX & NOR4IN))}
+    OR41 = {~NOR41}
+    NOR42 = {~((BRANCH4 & NAND3IN & NAND4IN) | (NOR4IN & NAND4IN))}
+    OR42 = {~NOR42}
+    S2O = {~((XOR2 & NOR41 & OR42) | (XNOR2 & OR41) | (XOR3 & OR41) |
+             (XNOR2 & NOR42))}
+    S3O = {~((XOR3 & OR42) | (XOR2 & OR41) | (XNOR2 & NOR42))}
+    S4O = {(XOR2 & XOR3 & OR41) | (XNOR2 & NOR42)}
+    COUTO = {~((XOR2 & XOR3 & OR42) | (OR42 & NOR41))}

U2 PINDLY(5,0,9) VDD VSS
+ S1O S2O S3O S4O COUTO
+ CIN A1 A2 A3 A4 B1 B2 B3 B4
+ S1 S2 S3 S4 COUT
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   DATA = {CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0) | CHANGED(A4,0) |
+           CHANGED(B1,0) | CHANGED(B2,0) | CHANGED(B3,0) | CHANGED(B4,0)}
+   CARRY = {CHANGED(CIN,0)}
+ PINDLY:
+    S1 S2 S3 S4 = {
+      CASE(
+        DATA & (TRN_LH | TRN_HL), DELAY(-1,750NS,2100NS),
+        CARRY & TRN_LH, DELAY(-1,800NS,2250NS),
+        CARRY & TRN_HL, DELAY(-1,650NS,1800NS),
+        DELAY(-1,801NS,2251NS))}
+    COUT = {
+       CASE(
+        DATA & (TRN_LH | TRN_HL), DELAY(-1,650NS,1800NS),
+        CARRY & (TRN_LH | TRN_HL), DELAY(-1,550NS,1500NS),
+        DELAY(-1,651NS,1801NS))}

.ENDS CD4560B

*------------------------------------------------------------CD4562B------

* 128 Bit Static Shift Register
* Motorola CMOS Logic Databook, 1991, pages 6-451 to 6-454
* jat 9/13/95

.SUBCKT CD4562B
+ DATA CLOCK Q16 Q32 Q48 Q64 Q80 Q96 Q112 Q128
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 DFF(128) VDD VSS
+ $D_HI $D_HI CLOCK
* 128 D Nodes
+ DATA 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
+ 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
+ 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75
+ 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
+ 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119
+ 120 121 122 123 124 125 126 127
* 128 Q Nodes
+ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
+ 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
+ 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75
+ 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100
+ 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119
+ 120 121 122 123 124 125 126 127 128
* 128 Qbar Nodes
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ D0_EFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(8,0,0) VDD VSS
+ 16 32 48 64 80 96 112 128
+ Q16 Q32 Q48 Q64 Q80 Q96 Q112 Q128
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+   Q16 Q32 Q48 Q64 Q80 Q96 Q112 Q128 = {
+     CASE(
+       TRN_LH | TRN_HL, DELAY(-1,600NS,1200NS),
+       DELAY(-1,601NS,1201NS))}

U3 CONSTRAINT(2) VDD VSS
+ CLOCK DATA
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ WIDTH:
+   NODE = CLOCK
+   MIN_HI = 300NS
+   MIN_LO = 300NS
+ FREQ:
+   NODE = CLOCK
+   MAXFREQ = 1.9MEG
+ SETUP_HOLD:
+   CLOCK LH = CLOCK
+   DATA(1) = DATA
+   HOLDTIME = 267NS

.ENDS CD4562B

*------------------------------------------------------------CD4572UB----

* Hex Gate
* Motorola CMOS Logic Databook, 1991, pages 6-481 to 6-483
* jat 9/14/95

.SUBCKT CD4572UB
+ INA OUTA INB OUTB IN1C IN2C OUTC IND OUTD INE OUTE IN1F IN2F OUTF
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(8,6) VDD VSS
+ INA INB IN1C IN2C IND INE IN1F IN2F
+ OUTA OUTB OUTC OUTD OUTE OUTF
+ DLY IO_4000UB MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    OUTA = {~INA}
+    OUTB = {~INB}
+    OUTC = {~(IN1C | IN2C)}
+    OUTD = {~IND}
+    OUTE = {~INE}
+    OUTF = {~(IN1F & IN2F)}

.MODEL DLY UGATE(TPLHMN = -1 TPLHTY = 90NS TPLHMX = 180NS
+                TPHLMN = -1 TPHLTY = 90NS TPHLMX = 180NS)

.ENDS CD4572UB

*------------------------------------------------------------CD4584B------

* Hex Schmitt Trigger
* Motorola CMOS Logic Databook, 1991, pages 6-504 to 6-506
* jat 9/14/95

.SUBCKT CD4584B
+ IN1 IN2 IN3 IN4 IN5 IN6 OUT1 OUT2 OUT3 OUT4 OUT5 OUT6
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 INVA(6) VDD VSS
+ IN1 IN2 IN3 IN4 IN5 IN6 OUT1 OUT2 OUT3 OUT4 OUT5 OUT6
+ DLY IO_4000B_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY UGATE(TPLHMN=-1 TPLHTY=125NS TPLHMX=250NS
+                TPHLMN=-1 TPHLTY=125NS TPHLMX=250NS)

.ENDS CD4584B

*------------------------------------------------------------CD4585B------

* 4 Bit Magnitude Comparator
* Motorola CMOS Logic Databook, 1991, pages 6-507 to 6-510
* jat 9/14/95

.SUBCKT CD4585B
+ A0 A1 A2 A3 B0 B1 B2 B3 AGREATBIN ALESSBIN AEQUALBIN AGREATBOUT
+ ALESSBOUT AEQUALBOUT
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(10,3) VDD VSS
+ A0 A1 A2 A3 B0 B1 B2 B3 ALESSBIN AEQUALBIN
+ AGREATBOUT ALESSBOUT AEQUALBOUT
+ DLY IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   NAND31 = {~((~A3) & B3)}
+   NAND32 = {~((~B3) & A3)}
+   NAND33 = {~(NAND31 & NAND32)}
+   NAND21 = {~((~A2) & B2)}
+   NAND22 = {~((~B2) & A2)}
+   NAND23 = {~(NAND21 & NAND22)}
+   NAND11 = {~((~A1) & B1)}
+   NAND12 = {~((~B1) & A1)}
+   NAND13 = {~(NAND11 & NAND12)}
+   NAND01 = {~((~A0) & B0)}
+   NAND02 = {~((~B0) & A0)}
+   NAND03 = {~(NAND01 & NAND02)}
+   OR2 = {NAND33 | NAND21}
+   OR3 = {NAND33 | NAND23 | NAND11}
+   OR4 = {NAND33 | NAND23 | NAND13 | NAND01}
+   OR5 = {NAND33 | NAND23 | NAND13 | NAND03 | (~ALESSBIN)}
+   ALESSBOUT = {~(NAND31 & OR2 & OR3 & OR4 & OR5)}
+   AEQUALBOUT = {~(NAND33 | NAND23 | NAND13 | NAND03 | (~AEQUALBIN))}
+   AGREATBOUT = {~(ALESSBOUT | AEQUALBOUT)}

.MODEL DLY UGATE(TPLHMN=-1 TPLHTY=430NS TPLHMX=860NS
+                TPHLMN=-1 TPHLTY=430NS TPHLMX=860NS)

.ENDS CD4585B

*------------------------------------------------------------CD4723B------

* Dual 4-Bit Addressable Latch
* National CMOS Logic Databook, 1988, pages 5-323 to 5-329
* jat 9/12/95

.SUBCKT CD4723B
+ CL DA DB EBAR A0 A1 Q0A Q1A Q2A Q3A Q0B Q1B Q2B Q3B
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(4,8) VDD VSS
+ A0 A1 EBAR CL
+ G0 G1 G2 G3 CLR0 CLR1 CLR2 CLR3
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   G0 = {(~A0) & (~A1) & (~EBAR)}
+   G1 = {  A0  & (~A1) & (~EBAR)}
+   G2 = {(~A0) &   A1  & (~EBAR)}
+   G3 = {  A0  &   A1  & (~EBAR)}
+   CLR0 = {~((EBAR & CL) | ((~EBAR) & CL & (~G0)))}
+   CLR1 = {~((EBAR & CL) | ((~EBAR) & CL & (~G1)))}
+   CLR2 = {~((EBAR & CL) | ((~EBAR) & CL & (~G2)))}
+   CLR3 = {~((EBAR & CL) | ((~EBAR) & CL & (~G3)))}

U2 DLTCH(1) VDD VSS
+ $D_HI CLR0 G0
+ DA Q0AO $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DLTCH(1) VDD VSS
+ $D_HI CLR1 G1
+ DA Q1AO $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 DLTCH(1) VDD VSS
+ $D_HI CLR2 G2
+ DA Q2AO $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 DLTCH(1) VDD VSS
+ $D_HI CLR3 G3
+ DA Q3AO $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 DLTCH(1) VDD VSS
+ $D_HI CLR0 G0
+ DB Q0BO $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 DLTCH(1) VDD VSS
+ $D_HI CLR1 G1
+ DB Q1BO $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 DLTCH(1) VDD VSS
+ $D_HI CLR2 G2
+ DB Q2BO $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 DLTCH(1) VDD VSS
+ $D_HI CLR3 G3
+ DB Q3BO $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 PINDLY(8,0,9) VDD VSS
+ Q0AO Q1AO Q2AO Q3AO Q0BO Q1BO Q2BO Q3BO
+ EBAR DA DB CLR0 CLR1 CLR2 CLR3 A0 A1
+ Q0A Q1A Q2A Q3A Q0B Q1B Q2B Q3B
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+     ADD = {CHANGED(A0,0) | CHANGED(A1,0)}
+     ENABLE = {CHANGED_HL(EBAR,0)}
+     DATAINA = {CHANGED(DA,0)}
+     DATAINB = {CHANGED(DB,0)}
+     CLEAR0 = {CHANGED_HL(CLR0,0)}
+     CLEAR1 = {CHANGED_HL(CLR1,0)}
+     CLEAR2 = {CHANGED_HL(CLR2,0)}
+     CLEAR3 = {CHANGED_HL(CLR3,0)}
+ PINDLY:
+     Q0A = {
+       CASE(
+         CLEAR0 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAINA) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q1A = {
+       CASE(
+         CLEAR1 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAINA) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q2A = {
+       CASE(
+         CLEAR2 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAINA) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q3A = {
+       CASE(
+         CLEAR3 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAINA) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q0B = {
+       CASE(
+         CLEAR0 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAINB) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q1B = {
+       CASE(
+         CLEAR1 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAINB) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q2B = {
+       CASE(
+         CLEAR2 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAINB) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q3B = {
+       CASE(
+         CLEAR3 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAINB) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}

U11 CONSTRAINT(6) VDD VSS
+ A0 A1 CL EBAR DA DB
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ WIDTH:
+   NODE = DA
+   MIN_LO = 100NS
+   MIN_HI = 100NS
+ WIDTH:
+   NODE = DB
+   MIN_LO = 100NS
+   MIN_HI = 100NS
+ WIDTH:
+   NODE = A0
+   MIN_LO = 200NS
+   MIN_HI = 200NS
+ WIDTH:
+   NODE = A1
+   MIN_LO = 200NS
+   MIN_HI = 200NS
+ WIDTH:
+   NODE = CL
+   MIN_HI = 75NS
+ SETUP_HOLD:
+  CLOCK HL = EBAR
+  DATA(2) = DA DB
+  SETUPTIME = 40NS
+  HOLDTIME = 60NS

.ENDS CD4723B

*------------------------------------------------------------CD4724B------

* 8-Bit Addressable Latch
* National CMOS Logic Databook, 1988, pages 5-323 to 5-329
* jat 9/12/95

.SUBCKT CD4724B
+ CL D EBAR A0 A1 A2 Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ OPTIONAL:  VDD=$G_CD4000_VDD VSS=$G_CD4000_VSS
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(6,16) VDD VSS
+ A0 A1 A2 EBAR D CL
+ G0 G1 G2 G3 G4 G5 G6 G7 CLR0 CLR1 CLR2 CLR3 CLR4 CLR5 CLR6 CLR7
+ D0_GATE IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   G0 = {(~A0) & (~A1) & (~A2) & (~EBAR)}
+   G1 = {  A0  & (~A1) & (~A2) & (~EBAR)}
+   G2 = {(~A0) &   A1  & (~A2) & (~EBAR)}
+   G3 = {  A0  &   A1  & (~A2) & (~EBAR)}
+   G4 = {(~A0) & (~A1) &   A2  & (~EBAR)}
+   G5 = {  A0  & (~A1) &   A2  & (~EBAR)}
+   G6 = {(~A0) &   A1  &   A2  & (~EBAR)}
+   G7 = {  A0  &   A1  &   A2  & (~EBAR)}
+   CLR0 = {~((EBAR & CL) | ((~EBAR) & CL & (~G0)))}
+   CLR1 = {~((EBAR & CL) | ((~EBAR) & CL & (~G1)))}
+   CLR2 = {~((EBAR & CL) | ((~EBAR) & CL & (~G2)))}
+   CLR3 = {~((EBAR & CL) | ((~EBAR) & CL & (~G3)))}
+   CLR4 = {~((EBAR & CL) | ((~EBAR) & CL & (~G4)))}
+   CLR5 = {~((EBAR & CL) | ((~EBAR) & CL & (~G5)))}
+   CLR6 = {~((EBAR & CL) | ((~EBAR) & CL & (~G6)))}
+   CLR7 = {~((EBAR & CL) | ((~EBAR) & CL & (~G7)))}

U2 DLTCH(1) VDD VSS
+ $D_HI CLR0 G0
+ D Q0O $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DLTCH(1) VDD VSS
+ $D_HI CLR1 G1
+ D Q1O $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 DLTCH(1) VDD VSS
+ $D_HI CLR2 G2
+ D Q2O $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 DLTCH(1) VDD VSS
+ $D_HI CLR3 G3
+ D Q3O $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 DLTCH(1) VDD VSS
+ $D_HI CLR4 G4
+ D Q4O $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 DLTCH(1) VDD VSS
+ $D_HI CLR5 G5
+ D Q5O $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 DLTCH(1) VDD VSS
+ $D_HI CLR6 G6
+ D Q6O $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 DLTCH(1) VDD VSS
+ $D_HI CLR7 G7
+ D Q7O $D_NC
+ D0_GFF IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 PINDLY(8,0,13) VDD VSS
+ Q0O Q1O Q2O Q3O Q4O Q5O Q6O Q7O
+ EBAR D CLR0 CLR1 CLR2 CLR3 CLR4 CLR5 CLR6 CLR7 A0 A1 A2
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ IO_4000B MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+     ADD = {CHANGED(A0,0) | CHANGED(A1,0) | CHANGED(A2,0)}
+     ENABLE = {CHANGED_HL(EBAR,0)}
+     DATAIN = {CHANGED(D,0)}
+     CLEAR0 = {CHANGED_HL(CLR0,0)}
+     CLEAR1 = {CHANGED_HL(CLR1,0)}
+     CLEAR2 = {CHANGED_HL(CLR2,0)}
+     CLEAR3 = {CHANGED_HL(CLR3,0)}
+     CLEAR4 = {CHANGED_HL(CLR4,0)}
+     CLEAR5 = {CHANGED_HL(CLR5,0)}
+     CLEAR6 = {CHANGED_HL(CLR6,0)}
+     CLEAR7 = {CHANGED_HL(CLR7,0)}
+ PINDLY:
+     Q0 = {
+       CASE(
+         CLEAR0 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAIN) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q1 = {
+       CASE(
+         CLEAR1 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAIN) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q2 = {
+       CASE(
+         CLEAR2 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAIN) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q3 = {
+       CASE(
+         CLEAR3 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAIN) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q4 = {
+       CASE(
+         CLEAR4 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAIN) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q5 = {
+       CASE(
+         CLEAR5 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAIN) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q6 = {
+       CASE(
+         CLEAR6 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAIN) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}
+     Q7 = {
+       CASE(
+         CLEAR7 & TRN_HL, DELAY(-1,175NS,350NS),
+         ADD & (TRN_LH | TRN_HL), DELAY(-1,225NS,450NS),
+         (ENABLE | DATAIN) & (TRN_LH | TRN_HL), DELAY(-1,200NS,400NS),
+         DELAY(-1,226NS,451NS))}

U11 CONSTRAINT(6) VDD VSS
+ A0 A1 A2 CL EBAR D
+ IO_4000B IO_LEVEL={IO_LEVEL}
+ WIDTH:
+   NODE = D
+   MIN_LO = 100NS
+   MIN_HI = 100NS
+ WIDTH:
+   NODE = A0
+   MIN_LO = 200NS
+   MIN_HI = 200NS
+ WIDTH:
+   NODE = A1
+   MIN_LO = 200NS
+   MIN_HI = 200NS
+ WIDTH:
+   NODE = A2
+   MIN_LO = 200NS
+   MIN_HI = 200NS
+ WIDTH:
+   NODE = CL
+   MIN_HI = 75NS
+ SETUP_HOLD:
+  CLOCK HL = EBAR
+  DATA(1) = D
+  SETUPTIME = 40NS
+  HOLDTIME = 60NS

.ENDS CD4724B